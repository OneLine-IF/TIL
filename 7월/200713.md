1. Runnalbe 인터페이스는 내가 따로 만들어줄 필요가 없는데 원래 존재하는 인터페이스인가?
Thread 클래스도 마찬가지인가?

### 44강 (인터페이스 굉장히 많이 사용하므로 매우 중요!!)

1. 인터페이스 (인터 페이스는 엄연히 상속과는 다른 것이다.)

	- 인터페이스는 추상 메서드로만 구현되어 있는 것을 가르킨다.
	- 자바에서는 단일 상속만 지원하므로 추상 클래스를 하나 이상 상속받을 수 없다.
	- 자바에서는 인터페이스를 통해 반드시 구현해야 하는 메서드를 동시에 여러 개 구현할 수 있다.
	- 인터페이스는 다중 상속을 지원하기 위해서 제공되는 것이 아니라 하나의 클래스를 여러 종류의 참조 변수를 통해 접근할 수 있고 메서드를 호출할 수 있도록 지원되는 개념이다.
	- 인터페이스에 정의된 메서드는 모두 추상 메서드이며 변수는 static final 변수이다.
	- 메서드를 선언할 때 abstract 키워드를 붙히지 않아도 추상 메서드로 간주한다.
	- 변수에 static final을 붙히지 않아도 static final로 간주한다.

1. 인터페이스의 및 구현

	- interface 인터페이스이름{
		변수 선언...
		메서드 선언... 
	  }

	- class 클래스이름 extends 부모클래스 implements 인터페이스1, 인터페이스2{ ... }

```Java
public class InterfaceTest {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// interA a = new InterA();// 인터페이스이기에 객체 생성이 불가능하다.
		TestClass t = new TestClass();
		
		t.methodA();
		t.methodB();// 이렇게하면 정상적으로 오버라이딩한 메서드가 호출된다.
		
		System.out.println(t.a);
		System.out.println(t.b);
		
		// t.a = 100;
		// t.b = 200;// 인터페이스에서 선언한 변수는 static final 변수이므로 값을 변경 불가
		
		InterA ia = new TestClass();// 인터페이스형 참조변수
		InterB ib = new TestClass();
		
		ia.methodA();
		ib.methodB();
		
		System.out.println(InterA.a);// static 변수이기에 바로 접근이 가능하다.
		System.out.println(InterB.b);
	}

}

class TestClass implements InterA, InterB{

	@Override
	public void methodA() {
		// TODO Auto-generated method stub
		System.out.println("InterA의 메서드");
	}

	@Override
	public void methodB() {
		// TODO Auto-generated method stub
		System.out.println("InterB의 메서드");
	}
	
}

class TestClass2 implements InterC{
	public void methodC() {
		
	}

	@Override
	public void methodA() {
		// TODO Auto-generated method stub
		
	}
}
```

1. 학 습 정 리

	- 인터페이스는 다중 상속을 지원하는 개념이 아니고 인터페이스를 통해 여러 종류의 참조 변수를 통한 접근을 지원하기 위해 제공된다.

	- 인터페이스에서 제공하는 메서드는 모두 추상 메서드 이므로 반드시 구현을 해야 한다.

	- 인터페이스에서 제공하는 변수는 모두 static final 이므로 변수에 값을 넣을 수 없다.

### 45강

1. 쓰레드

	- 프로그램을 작성하다 보면 동시에 여러 개의 일을 해야 할 때가 있다.
	- ex) 동시에 2개의 반복문을 돌리고 싶을 때!!
	- 이러한 멀티 프로세싱을 구현할 수 있도록 제공하는 것이 쓰레드이다.

1. 쓰레드 작성법

	- 쓰레드를 작성하는 방법은 Thread 클래스를 상속 받는 방법과 Runnable 인터페이스를 구현하는 방법 두 가지가 있다. 

	- 클래스 상속 방법 : Thread 클래스를 상속 받고 run.메서드를 구현해 주면 된다.

	class 클래스이름 extends Thread{
		public void run(){
			소스코드
		}
	} 

	- 인터페이스 구현법 : Runnable 인터페이스를 구현하고 run 메서드를 구현하면 된다.

	class 클래스이름 implements Runnalbe{
		public void run(){
			소스코드
		}
	}

1. 쓰레드 사용법  
	- Thread 클레스를 상속 받았을 경우에는 상속 받은 클래스의 객체를 생성하고 start 메서드를 호출해준다.
	- interface를 사용할 경우에는 Thread 클래스의 객체를 생성하고 생성자에 인터페이스를 구현한 클래스의 객체를 넣어준다. 그 이후에 start 메서드를 호출해준다. 

```Java
public class ThreadTest {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Thread1 t1 = new Thread1();
		t1.start();
		
		Thread2 t2 = new Thread2();
		Thread t = new Thread(t2);
		t.start();
		
		
		while(true) {
			try {
				Thread.sleep(1000);
			}catch(Exception e) {}
			System.out.print("*");
		}
		
	}

}

class Thread1 extends Thread{
	
	public void run() {
		while(true) {
			try {
				Thread.sleep(1000);
			}catch(Exception e) {}
			System.out.print("-");
		}
	}
}

class Thread2 implements Runnable{

	@Override
	public void run() {
		// TODO Auto-generated method stub
		while(true) {
			try	 {
				Thread.sleep(1000);
			}catch(Exception e) {}
			System.out.print("_");
		}
	}
	
}
```

1. 학 습 정 리

	- 쓰레드는 동시에 여러 개의 작업을 하고 싶을 때 사용하는 개념이다.

	- 쓰레드를 사용하기 위해서는 Thread 클래스 상속 받거나 Runnable 인터페이스를 구현하고 run 메서드를 구현해준다.

### 46강

1. 쓰레드의 우선순위

	- 자바의 쓰레드는 우선 순위라는 것을 가지고 있다.
	- 하나의 프로그램에서 동시에 여러 개의 쓰레드가 운영될 경우 우선 처리할 쓰레드를 결정하는데 쓰레드 우선 순위를 이용한다.
	- 우선 순위 값은 1 ~ 10까지이며 기본 값은 5이다.
	- 쓰레드의 우선 순위 값이 10이면 가장 먼저 처리할 확률이 높아지고 1이면 다른 것보다 늦게 처리될 확률이 높아진다.
	- 우선 순위가 높다고 해서 반드시 가장 먼저 처리되는 것은 아니고 가장 먼저 처리될 확률이 높아지는 것 뿐이다.

```Java
public class PriotrityTest {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Thread1 t1 = new Thread1();
		Thread2 t2 = new Thread2();
		
		// System.out.println(t1.getPriority());
		// System.out.println(t2.getPriority());
		
		t1.setPriority(1);
		t2.setPriority(10);
		
		t1.start();
		t2.start();
	}

}

class Thread1 extends Thread{
	
	public void run() {
		for(int i = 0; i < 100; i++) {
			System.out.print("*");
		}
	}
}

class Thread2 extends Thread{
	
	public void run() {
		for(int i = 0; i < 100; i++) {
			System.out.print("_");
		}
	}
}
```

1. 학 습 정 리

	- 우선 처리될 쓰레드를 결정하는데는 우선 순위 값을 이용한다.
	- 1 ~ 10 사이의 값이며 기본값은 5이다.
	- 값이 높으면 먼저 처리될 확률이 높아진다.
	- 값이 낮으면 나중에 처리될 확률이 높아진다.

### 47강

1. 쓰레드의 동기화

	1. 임계영역

		- 동시의 여러 개의 쓰레드가 특정 소스코드 혹은 메서드를 동시에 접근할 경우 해당 메서드를 서로 사용하려고 하는데 이처럼 여러 개의 쓰레드가 동시에 접근할 수 있는 코드 영역 혹은 메서드를 임계 영역이라고 부른다.
		- 프로그램에서 임계 영역이 있을 경우 프로그램 전체의 심각한 오류를 발생 시킬 수도 있다.
		- 자바에서는 동기화를 통해 이러한 부분을 해결할 수 있다.

	1. 동기화

		- 동기화를 하게 되면 임계영역 때문에 발생되는 문제를 막아줄 수 있다.
		- 동기화를 하게 되면 쓰레드가 접근하는 순서대로 코드를 처리하고 늦게 도착하는 쓰레드는 기다렸다가 먼저 도착한 쓰레드의 작업이 완료가 되면 다음 쓰레드가 작업을 하게 된다.
		- 동기화는 메서드를 동기화 하는 방법과 코드의 일부분을 동기화 하는 방법으로 나눠진다.  

	1. 메서드의 동기화

		- 여러 개의 쓰레드가 호출하는 메서드가 있다고 한다면 메서드의 코드는 임계영역에 해당한다. 
		- 이런 경우에는 메서드 전체를 동기화 하면되는데 다음과 같이 작성해 주면된다.

		- public synchronized void method(){ 임계영역 코드 }

	1. 코드의 동기화

		- Run 메서드의 코드 일부분을 동기화 하고자 할 때는 임계 영역에 해당하는 코드 부분을 synchronized 블록으로 묶어 주면 된다.

		- synchronized(클래스 혹은 객체){ 임계영역 코드 }

```Java
public class Sync1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Thread1 t = new Thread1();// 쓰레드를 상속받은 클래스의 객체를 생성한다.
		
		Thread t1 = new Thread(t, "T1");
		Thread t2 = new Thread(t, "T2");// 쓰레드 클래스를 따로따로 생성한다.
		
		t1.start();
		t2.start();
	}

}

class Thread1 extends Thread{
	
	public void run() {
		synchronized(this) {
			
			for(int i = 0; i < 10; i++) {
				try {
					Thread.sleep(1000);
				}catch(Exception e) {}
				System.out.println(Thread.currentThread().getName() + " : " + i);
			}
		}
	}
}
```

1. 학 슴 정 리

	- 여러 개의 쓰레드가 메서드 혹은 특정 코드를 같이 사용하는 것을 임계 영역이라고 부른다. 

	- 임계 영역으로 인해 발생되는 오류를 방지하기 위해서는 동기화를 해주면 된다.