### 네이버_부스트코스_2

## 테이블 레이아웃, 스크롤뷰 사용하기

1. 테이블 레이아웃 (TableLayout)

	- 격자 모양으로 뷰를 배치할 때 사용

    - 테이블 레이아웃에 아래의 코드 작성 -> 내용물을 각각 하나의 칼럼으로 보고 여유 공간이 없도록 줄을 칼럼들로 채운다. 

```Java
android:stretchColumns="0,1,2" // 한 줄에 3개의 칼럼(칸)이 들어가도록 설정

android:layout_span="2" // 해당 위젯의 너비를 칼럼 2개짜리로 만듦

android:layout_column="1" // 인덱스값 0,1,2 중 1(가운데)에 해당하는 위치
android:layout_column="2" // 인덱스값 0,1,2 중 2(마지막)에 해당하는 위치
```

1. 특징

	- 각각의 행은 <TableRow>태그를 이용해 추가

	- 그 안에 몇 개의 뷰를 추가하는가에 따라 열의 개수가 결정

	- 여러 개의 <TableRow>가 추가될 수 있고 각각의 <TableRow> 안에는 여러 개의 뷰가 들어갈 수 있는 구조로 되어 있음  

1. 스크롤뷰 (ScrollView)

	- 스크롤 기능을 쉽게 만들 수 있도록 함

	- 이미지뷰나 텍스트뷰들의 뷰를 스크롤뷰로 감싸주면 스크롤뷰가 뷰의 영역을 계산하고 화면에 보이는 공간을 넘어갔을 때 자동으로 스크롤을 만들어 줌

## 이벤트 처리하기

<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-664406248">

1. 대표적인 이벤트

	- 터치 이벤트 : 화면을 손가락으로 누를 때 발생하는 이벤트

	- 키 이벤트 : 키패드나 하드웨어 버튼을 누를 때 발생하는 이벤트

	- 제스처 이벤트 : 터치 이벤트 중에서 일정 패턴을 만들어 내는 이벤트

	- 포커스 : 뷰마다 순서대로 주어지는 포커스 (자주 쓰이지 x)

	- 화면 방향 변경 : 화면의 방향이 가로/세로로 바뀜에 따라 발생하는 이벤트

<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-664407119">

1. MainActivity.java
```Java
package com.example.event;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.view.GestureDetector;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {
    TextView textView;

    GestureDetector detector;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.textView);

        View view = findViewById(R.id.view);
        view.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                int action = event.getAction();

                float curX = event.getX();
                float curY = event.getY();

                if(action == MotionEvent.ACTION_DOWN){
                    println("손가락 눌렸음 : " + curX + ", " + curY);
                } else if(action == MotionEvent.ACTION_MOVE){
                    println("손가락 움직임 : " + curX + ", " + curY);
                } else if(action == MotionEvent.ACTION_UP){
                    println("손가락 떼졌음 : " + curX + ", " + curY);
                }

                return true;
            }
        });

        detector = new GestureDetector(this, new GestureDetector.OnGestureListener() {
            @Override
            public boolean onDown(MotionEvent motionEvent) {
                println("onDown() 호출됨.");
                return true;
            }

            @Override
            public void onShowPress(MotionEvent motionEvent) {
                println("onShowPress() 호출됨.");
            }

            @Override
            public boolean onSingleTapUp(MotionEvent motionEvent) {
                println("onSingleTapUp() 호출됨.");
                return true;
            }

            @Override
            public boolean onScroll(MotionEvent motionEvent, MotionEvent motionEvent1, float distanceX, float distanceY) {
                println("onScroll() 호출됨 : " + distanceX + ", " + distanceY);
                return true;
            }

            @Override
            public void onLongPress(MotionEvent motionEvent) {
                println("onLongPress() 호출됨.");
            }

            @Override
            public boolean onFling(MotionEvent motionEvent, MotionEvent motionEvent1, float velocityX, float velocityY) {
                println("onFling() 호출됨 : " + velocityX + ", " + velocityY);
                return true;
            }
        });

        View view2 = findViewById(R.id.view2);
        view2.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                detector.onTouchEvent(event);
                return true;
            }
        });
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if(keyCode == KeyEvent.KEYCODE_BACK){
            Toast.makeText(this, "시스템 BACK 버튼 눌림.", Toast.LENGTH_LONG).show();
            return true;
        }

        return false;
    }

    public void println(String data) {
        textView.append(data + "\n");
    }

}
```

1. 키 입력 이벤트 처리하기 

<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-664409084">

1. activity_main.xml
```Java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <View
        android:id="@+id/view"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:background="#03A9F4" />

    <View
        android:id="@+id/view2"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:background="#FFC107" />

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">

        <TextView
            android:id="@+id/textView"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:textColor="#000000"
            android:textSize="16dp" />
        
    </ScrollView>

    <EditText
        android:id="@+id/editTextTextPersonName2"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:background="@drawable/my_selector"
        android:ems="10"
        android:inputType="textPersonName"
        android:text="Name" />

</LinearLayout>
```

1. my_selector.xml
```Java
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:state_focused="true" // 넣고 안넣고 무슨 차이?
        android:state_pressed="true"
        android:drawable="@drawable/red"/>

    <item
        android:drawable="@drawable/blue"/>
</selector>
```

- 클릭 이벤트는 터치 이벤트를 단순화한 것인데요, 터치 이벤트는 손가락으로 터치했을 때 생기는 각각의 상태를 다룰 수 있도록 해 줍니다.

- 손가락을 누른 상태, 손가락을 누르고 움직이는 상태, 손가락을 뗀 상태를 각각 이벤트로 전달합니다.

1. 터치 이벤트 처리하기

	- 뷰 객체에 OnTouchListener를 설정하고 싶다면 setOnTouchListener 메소드를 사용합니다.
	
	- OnTouchListener 안에는 onTouch 메소드를 정의할 수 있는데 뷰가 터치되었을 때 이 메소드가 자동으로 호출됩니다.

	- MotionEvent 객체에는 터치된 곳의 좌표와 함께 터치된 상태가 전달됩니다.

1. 키 이벤트 처리하기

	- 키패드의 키가 눌렸을 때는 키 이벤트가 발생합니다.

	- 사용자가 누를 수 있는 키로는 a, b, c와 같은 알파벳이나 1, 2, 3과 같은 숫자가 있을 수 있지만 그 외에도 시스템 BACK 키나 시스템 HOME 키도 있을 수 있습니다.

	- 화면 하단에 항상 보이는 키인데 이 키를 눌렀을 때도 이벤트를 받을 수 있는 거죠. 그 중에서도 시스템 BACK 키는 자주 사용됩니다.

	- 이 경우에는 간단하게 onBackPressed 메소드를 재정의하면 됩니다.

	- 아니면 키 이벤트를 직접 처리할 수도 있습니다.
	
	- 키 이벤트를 처리하고 싶다면 onKeyDown 메소드를 재정의하고 파라미터로 전달된 KeyEvent 객체를 참조합니다.

## 토스트와 대화상자

1. 토스트 보여주기

    - 토스트 : 간단한 메시지를 잠깐 보여주었다가 없어지는 뷰로 애플리케이션 위에 떠 있는 뷰라 할 수 있음

```Java
Toast.makeText(Context context, Stirng message, int duration)


public void setGravity(int gravity, int xOffset, int yOffset)
public void setMargin(float horizontalMargin, float verticalMargin)
```

- 토스트는 간단한 메시지를 잠깐 보여주었다가 없어지는 뷰인데, 앱 화면에 종속되지 않습니다.   

- 토스트 메시지를 보여주고 싶다면 다음과 같은 코드 형태를 사용합니다.

```Java
Toast.makeText(Context context, String message, int duration).show();
```

- 스낵바를 사용할 때의 코드 형태는 토스트를 사용할 때와 유사함
- 다만 Snackbar의 make 메소드를 호출할 때 첫 번째 파라미터로 뷰 객체를 넣어주어야 한다는 점이 다름

```Java
Snackbar.make(v, "스낵바입니다.", Snackbar.LENGTH_LONG).show();
```

1. MainActivity.java
```Java
package com.example.toast;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import com.google.android.material.snackbar.Snackbar;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Button button = (Button) findViewById(R.id.button); // 버튼 객체를 찾아서 변수에 할당
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Toast toast = Toast.makeText(getApplicationContext(), "위치가 바뀐 토스트",Toast.LENGTH_LONG);
                toast.setGravity(Gravity.TOP|Gravity.LEFT,200,200);
                toast.show();
            }
        });

        Button button2 = (Button) findViewById(R.id.button2); // 버튼 객체를 찾아서 변수에 할당
        button2.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                LayoutInflater inflater = getLayoutInflater();
                View layout = inflater.inflate(R.layout.toastborder, (ViewGroup)findViewById(R.id.toast_layout_root));
                // 메모리의 객체화, 뷰 객체가 리턴된다.

                TextView text = (TextView) layout.findViewById(R.id.text);
                text.setText("모양을 바꾼 토스트");

                Toast toast = new Toast(getApplicationContext());
                toast.setGravity(Gravity.CENTER,0,-100);
                toast.setDuration(Toast.LENGTH_LONG);
                toast.setView(layout); // 토스트 객체에 XML 레이아웃을 설정

                toast.show();
            }
        });

        Button button3 = (Button) findViewById(R.id.button3); // 버튼 객체를 찾아서 변수에 할당
        button3.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Snackbar.make(view, "스낵바입니다.", Snackbar.LENGTH_LONG).show();
            }
        });
    }
}
```

1. toastborder.xml -> layout 폴더에 들어있음
```Java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:id="@+id/toast_layout_root">

    <TextView
        android:id="@+id/text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:padding="20dp"
        android:textSize="40dp"
        android:background="@drawable/toast"
        />

</LinearLayout>
```

1. toast.xml -> drawable 폴더에 들어있음
```Java
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">

    <stroke
        android:width="4dp"
        android:color="#ffffff00"/>

    <solid
        android:color="#ff883300"/>
    <padding
        android:left="20dp"
        android:top="20dp"
        android:right="20dp"
        android:bottom="20dp"/>
    <corners
        android:radius="15dp"/>

</shape>
```

1. 알림 대화상자 보여주기

    - 알림 대화상자는 사용자에게 어떤 내용을 알려주거나 '아니오', '예' 버튼을 선택하도록 만들고 싶을 때 사용

    - 알림 대화상자는 AlertDialog 객체를 만들고 show 메소드를 이용해 화면에 표시

    - AlertDialog 객체를 만들 때는 AlertDialog.Builder 객체를 사용

    - 알림 대화상자에는 타이틀, 안내 메시지, 아이콘 그리고 예, 아니오 버튼 등을 설정

1. MainActicity.java

    - activity_main.xml에 버튼과 텍스트뷰 하나 추가해준 다음 실시

```Java
package com.example.dialog;

import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;

import android.content.DialogInterface;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import com.google.android.material.snackbar.Snackbar;

public class MainActivity extends AppCompatActivity {
    TextView textView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.textView);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                showMessage();
            }
        });
    }

    public void showMessage() {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle("안내");
        builder.setMessage("종료하시겠습니까?");
        builder.setIcon(android.R.drawable.ic_dialog_alert);

        builder.setPositiveButton("예", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialogInterface, int i) {
                Snackbar.make(textView, "예 버튼이 눌렸습니다.", Snackbar.LENGTH_LONG).show();
            }
        });

        builder.setNegativeButton("아니오", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialogInterface, int i) {
                Snackbar.make(textView, "아니오 버튼이 눌렸습니다.", Snackbar.LENGTH_LONG).show();
            }
        });

        AlertDialog dialog = builder.create(); // 이때 대화상자가 만들어지는 것
        dialog.show();
    }
}
```

## 비트맵 버튼 만들기

1. 나인패치(Nine Patch) 이미지란?

    - 이미지가 늘어나거나 줄어들 때 생기는 이미지 왜곡을 해결하는 방법을 정의한 것

    - 서로 다른 해상도를 가진 여러 단말에 dp 단위로 뷰의 크기를 맞추다 보면 이미지 크기가 자동 조절되면서 왜곡되는 현상 발생 -> 나인패치 이미지로 해결 

    - 나인패치 이미지는 이런 문제를 해결하기 위해 만들어진 것으로, 원래 이미지보다 한 픽셀씩 크게 만들고 가장자리 픽셀에는 늘어날 수 있는지, 늘어나면 안 되는지를 색상으로 구분

    - 이미지 파일 이름에 .9 

    - https://recipes4dev.tistory.com/132 -> 나인패치 이미지 말들기

1. 비트맵 버튼 만들기

    - 비트맵 버튼을 직접 만들어 normal일 경우와 clicked일 경우의 이미지를 표시

- 나인패치 이미지를 적용하는 대표적인 경우가 바로 버튼인데 이렇게 배경 부분을 이미지로 지정하여 만든 버튼은 아무리 눌러도 이미지의 변화가 없어 사용자가 버튼을 눌렀는지 안 눌렀는지 알 수 없다는 단점이 있음

- 비트캡 이미지를 이용해 버튼의 상태를 표시하려면 버튼이 눌렀을 때와 뗴어졌을 때를 이벤트로 구분하여 처리함

<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-664748849">

```Java
public void onMeasure (int widthMeasureSpec, int heightMeasureSpec)
public void onDraw(Canvas canvas)

void setMeasureDimension(int measuredWidth, int measuredHeight)
```

- 버튼의 배경에 이미지를 설정하고 그 버튼이 눌렸을 때 배경 이미지를 다르게 보여주고 싶다면 버튼을 상속해서 새로운 버튼을 만들고 터치 이벤트를 처리, 그 다음 invalidate 메서드를 이용하여 화면 갱신.

1. BitmapButton.java
```Java
package com.example.button;

import android.content.Context;
import android.graphics.Color;
import android.util.AttributeSet;
import android.view.MotionEvent;

import androidx.appcompat.widget.AppCompatButton;

public class BitmapButton extends AppCompatButton {
    public BitmapButton(Context context) {
        super(context);

        init(context); // 아래의 메서드를 이용해 초기화하는 것
    }

    public BitmapButton(Context context, AttributeSet attrs) {
        super(context, attrs);

        init(context); // 아래의 메서드를 이용해 초기화하는 것
    }

    private void init(Context context) {
        setBackgroundResource(R.drawable.title_bitmap_button_normal);

        float textSize = getResources().getDimension(R.dimen.text_size);
        setTextSize(textSize);

        setTextColor(Color.WHITE);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        int action = event.getAction();

        switch(action) {
            case MotionEvent.ACTION_DOWN:
                setBackgroundResource(R.drawable.title_bitmap_button_clicked);

                break;
            case MotionEvent.ACTION_UP:
                setBackgroundResource(R.drawable.title_bitmap_button_normal);

                break;
        }

        invalidate();

        return true;
    }

}
```

1. dimens.xml
```Java
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <dimen name = "text_size">12dp</dimen>

</resources>
```

1. activity_main.xml
```Java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:orientation="vertical">

<com.example.button.BitmapButton
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Hello World!"
    />

</LinearLayout>
```

## 인플레이션 이해하기

1. 의문

    - 안드로이드에서는 사용자의 눈에 보이는 화면의 배치 부분을 XML 파일로 쉽게 만들 수 있도록 XML 레이아웃 파일과 소스 파일을 분리

    - 분리해둔 XML 레이아웃 파일에 들어있는 버튼을 소스 파일에서도 사용하게 되는데 어떤 과정을 거쳐서 분리된 파일에 넣어둔 정보를 알아낼 수 있는 걸까요?

    - 인플레이션은 그 해답이 될 수 있습니다.


<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-665358483">

- 2개의 파일이 모여서 하나의 파일을 구성한다.

<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-665358894">

<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-665359492">

<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-665360248">

1. SetContentView() 메서드의 역할

    - setContentView() 메서드의 역할

        - 화면에 나타낼 뷰를 지정하는 역할
        - XML 레이아웃의 내용을 메모리 상에 객체화하는 역할

```Java
[Reference]

public void setContentView (int layoutResID)
public void setContentView (View view [, ViewGroup.LayoutParams params])
```

- 전체 화면 중에서 일부분만을 차지하는 화면 구성요소들을 XML 레이아웃에서 로딩하여 보여줄 수 없을까?

    - Layoutinflater 라는 클래스를 제공하며, 이 클래스는 시스템 서비스로 제공됨

- 시스템 서비스 : 안드로이드 단말기가 실행이 됐을 때, 뒷단에서 미리 실행이 되는, 화면이 없는 것을 서비스라고 한다.

* 부분 화면인 경우에는 직접 메모리에 객체화를 해야 된다. 즉, 직접 인플레이션 과정을 걸쳐야 된다고 하는 걸 생각!! 

- 다른 것들을 담을 수 있는 영역을 확보했을 때 container 라고 하는 ID 이름을 많이 사용한다. 

1. 부분화면 인플레이션 코드

- MainActivity

```Java
package com.example.layoutinflater;

import androidx.appcompat.app.AppCompatActivity;

import android.content.Context;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.Button;
import android.widget.FrameLayout;

public class MainActivity extends AppCompatActivity {
    FrameLayout container; // new View.OnClickListener() {} 에서 이 변수를 참조해주기위해

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main); // 해당 레이아읏 전체를 메모리 객체화 -> 레이아웃 인플레이션
        // 하지만 위의 해당 레이아웃 아래에 새로운 레이아웃(부분 화면)을 추가해줄 경우 우리가 직접 인플레이션해야 함

        container = (FrameLayout) findViewById(R.id.container);


        // 위 setContentView~ 코드와 아래의 코드와 순서를 바꿔주면 NullPointException 이 발생
        Button button = findViewById(R.id.button);
        // XML 파일에 버튼을 만들어주면  메모리 객체를 만들어준다.
        // 하지만 우리는 메모리가 만들어지는 위치를 모른다. 그래서 이렇게 찾아서 변수에 할당.
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                // 버튼을 클릭했을 때, 아까 우리가 만든 sub1.xml 이라고 하는 xml 레이아웃의 내용을 메모리에 객체화하는 인플레이션 과정을 거치면
                // 우리가 공간을 확보한 container 에다가 붙여줄 수가 있어요.
                LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);
                // 여기서 우리가 container 라고 하는 걸 지정하면 FrameLayout 이라고 해서 부분화면을 위해서 확보한 공간에 붙여주는 것
                inflater.inflate(R.layout.sub1, container, true);
                // 이곳에서부터 부분화면에서 만들었던 위젯들이 있다면 findViewById 로 찾을 수 있다.

            }
        });
    }
}
```

- sub1.xml -> layout 폴더에 새로 만들어준 다음

- activity_main.xml -> 부분화면 영역으로 활용할 FrameLayout 하나 넣어 놓고 Layout 이름을 container 로 설정

1. 핵 심 정 리

    -  XML 레이아웃에 버튼을 넣어두었다면 이 버튼을 소스 코드에서도 사용할 수 있어야 하는데 어떤 과정을 거쳐서 인식하게 되는 것일까요?

    - 소스 코드에서 XML 레이아웃 파일을 이해하려면 setContentView 메소드의 파라미터로 해당 XML 레이아웃 파일을 지정해주어야 합니다.

    - activity_main.xml 파일이 layout 폴더 안에 들어있으니 R.layout.activity_main 을 전달

    - 뷰의 경우에는 직접 인플레이션

## 리스트뷰 만들기 

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-666280690">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-666280747">

1. 리스트뷰로 보여줄 때 해야할 일들

    - 아이템을 위한 XML 레이아웃 정의하기 

        - 리스트뷰에 들어갈 각 아이템의 레이아웃을 XML로 정의함

    - 아이템을 위한 뷰 정의하기

        - 리스트뷰에 들어갈 각 아이템을 하나의 뷰로 정의. 이 뷰는 여러 개의 뷰를 담고 있는 뷰그룹이어야 함

        - 이것은 부분화면과 같아서 (1)번에서 정의한 XML 레이아웃을 인플레이션 후 설정해야 함

    - 어댑터 정의하기

        - 데이터 관리 역할을 하는 어댑터 클래스를 만들고 그 안에 각 아이템으로 표시할 뷰를 리턴하는 getView() 메서드를 정의함

    - 리스트뷰 정의하기

        - 화면에 보여줄 리스트뷰를 만들고 그 안에 데이터가 선택되었을 때 호출될 리스너 객체를 정의함

1. 특징

    - 어댑터는 데이터를 관리하면서 동시에 위젯을 통해 보일 각각의 아이템을 위해 뷰를 만들어주기까지 합니다.

    - 각각의 아이템은 독립적인 뷰로 만들어지게 되고 이 뷰들이 모여있는 형태를 유지해 주는 것이 리스트뷰

    - 각각의 아이템을 위한 뷰도 어댑터에서 만들어주기 때문에 리스트뷰는 어댑터의 getView 메소드를 호출하여 뷰 객체를 반환받은 후 화면에 보여주게 됩니다.

1. MainActivity.java
```Java
package com.example.list;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.BaseAdapter;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.Toast;

import java.util.ArrayList;

public class MainActivity extends AppCompatActivity {
    SingerAdapter adapter;

    EditText editText;
    EditText editText2;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        editText = (EditText) findViewById(R.id.editText);
        editText2 = (EditText) findViewById(R.id.editText2);

        ListView listView = (ListView) findViewById(R.id.listView);

        adapter = new SingerAdapter();
        adapter.addItem(new SingerItem("소녀시대","010-1000-1000", R.drawable.ic_12));
        adapter.addItem(new SingerItem("걸스데이","010-2000-2000", R.drawable.ic_15));
        adapter.addItem(new SingerItem("여자친구","010-3000-3000", R.drawable.ic_19));
        adapter.addItem(new SingerItem("티아라","010-4000-4000", R.drawable.ic_all));
        adapter.addItem(new SingerItem("애프터스쿨","010-5000-5000", R.drawable.ic_12));

        listView.setAdapter(adapter);

        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> adapterView, View view, int position, long l) {
                SingerItem item = (SingerItem) adapter.getItem(position);
                Toast.makeText(getApplicationContext(), "선택 : " + item.getName(), Toast.LENGTH_LONG).show();
            }
        });

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                String name = editText.getText().toString();
                String mobile = editText2.getText().toString();

                adapter.addItem(new SingerItem(name, mobile, R.drawable.ic_12));
                adapter.notifyDataSetChanged();
            }
        });
    }

    class SingerAdapter extends BaseAdapter {
        ArrayList<SingerItem> items = new ArrayList<SingerItem>();

        @Override
        public int getCount() { // 몇개의 아이템이 있는지
            return items.size();
        }

        public void addItem(SingerItem item){
            items.add(item);
        }

        @Override
        public Object getItem(int i) {
            return items.get(i);
        }

        @Override
        public long getItemId(int i) {
            return i;
        }
        // 뷰는 레이아웃으로 구성이 돼야 될 거에요. 그러면 레이아웃에 해당하는 거를 부분 화면으로
        // 하나 정의를 하고 이걸 이용해서 객체를 만든 다음 데이터를 설정하고 리턴을 해주는 게 가장 좋은 방법 중 하나!
        @Override
        public View getView(int position, View ConvertView, ViewGroup parent) {
            SingerItemView view = null;
            if(ConvertView == null) { // 쓸데없는 메모리 낭비를 막기 위해서
                view = new SingerItemView(getApplicationContext());
            } else {
                view = (SingerItemView) ConvertView;
            }
            SingerItem item = items.get(position); // ArrayList 에서 해당 인덱스(position)의 값 가져온다.
            view.setName(item.getName());
            view.setMobile(item.getMobile());
            view.setImage(item.getResId());

            return view;
        }
    }
}
```

1. SingerItemView.java
```Java
package com.example.list;

import android.content.Context;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

import androidx.annotation.Nullable;

import org.w3c.dom.Text;

public class SingerItemView extends LinearLayout {
    TextView textView;
    TextView textView2;
    ImageView imageView;

    public SingerItemView(Context context) {
        super(context);

        init(context);
    }

    public SingerItemView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);

        init(context);
    }

    private void init(Context context){
        LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        inflater.inflate(R.layout.singer_item, this, true);
        // 앞 강의에서 다룬 내용
        textView = (TextView) findViewById(R.id.textView);
        textView2 = (TextView) findViewById(R.id.textView2);
        imageView = (ImageView) findViewById(R.id.imageView);
    }

    public void setName(String name){
        textView.setText(name);
    }

    public void setMobile(String mobile){
        textView2.setText(mobile);
    }

    public void setImage(int resId){
        imageView.setImageResource(resId);
    }
}

```

1. SingerItem.java
```Java
package com.example.list;

public class SingerItem {

    String name;
    String mobile;
    int resId;

    public SingerItem(String name, String mobile, int resId) {
        this.name = name;
        this.mobile = mobile;
        this.resId =resId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getMobile() {
        return mobile;
    }

    public void setMobile(String mobile) {
        this.mobile = mobile;
    }

    public int getResId() {
        return resId;
    }

    public void setResId(int resId) {
        this.resId = resId;
    }

    @Override
    public String toString() {
        return "SingerItem{" +
                "name='" + name + '\'' +
                ", mobile='" + mobile + '\'' +
                '}';
    }
}
```

1. 스피너(콤보박스) 사용하기

    - 스피너는 이미 선택된 아이템이 보이는 뷰와 아이템을 선택하기 위해 보이는 뷰가 서로 다릅니다. 따라서 두 개의 뷰가 있어야 합니다.

    - ArrayAdapter는 아이템을 위한 여러 개의 데이터를 담아두기 위해 미리 만들어진 것이며 android.R.layout.simple_spinner_item 은 하나의 아이템을 위해 미리 만들어진 레이아웃

1. MainActivity.java
```Java
package com.example.spinner;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Spinner;
import android.widget.TextView;

public class MainActivity extends AppCompatActivity {
    TextView textView;

    String[] items = {"소녀시대","걸스데이","티아라","여자친구"};

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.textView);

        Spinner spinner = (Spinner) findViewById(R.id.spinner);
        ArrayAdapter<String> adapter = new ArrayAdapter<String>(
                this, android.R.layout.simple_spinner_item, items
        );
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        spinner.setAdapter(adapter);

        spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> adapterView, View view, int position, long l) {
                textView.setText(items[position]);
            }

            @Override
            public void onNothingSelected(AdapterView<?> adapterView) {
                textView.setText("선택 : ");
            }
        });
    }
}
```

1. 그리드뷰 사용하기

    - 리스트뷰 코드에서 살짝만 변경하면 된다!

1. activity_main.xml 에 그리드뷰 추가
```Java
<GridView
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:numColumns="2" />
```

1. 리스트뷰의 MainActivity.java 에서 아래 코드들로 수정!
```Java
GridView gridView = (GridView) findViewById(R.id.gridView);

gridView.setAdapter(adapter);

gridView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> adapterView, View view, int position, long l) {
                SingerItem item = (SingerItem) adapter.getItem(position);
                Toast.makeText(getApplicationContext(), "선택 : " + item.getName(), Toast.LENGTH_LONG).show();
            }
        });
```
