### 네이버_부스트코스_3

## 화면 전환하기

1. 화면 구성과 화면 간 전환

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-667897186">

1. MainActivity.java
```Java
package com.example.intent;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        // xml 파일을 인플레이션한 것 -> 위젯과 같은 것들을 메모리 객체화!
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            // 버튼을 눌렀을 때, onClick 안에 있는 코드들이 실행된다.
            @Override
            public void onClick(View view) {
                Intent intent = new Intent(getApplicationContext(), MenuActivity.class);
                // 메뉴 화면을 띄우고 싶다고 시스템 쪽에 알려줘야! 그것이 인텐트 활용하는 것!
                startActivityForResult(intent, 101);
                // 시스템 쪽으로 보내고 다시 메인 화면으로 돌아오기 위한 코드 설정

            }
        });
    }
    // 응답을 받을 메서드 정의
    @Override
    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        super.onActivityResult(requestCode, resultCode, data);

        if (requestCode == 101) {// 메뉴 화면에서 넘긴 코드인지 확인
            String name = data.getStringExtra("name");
            Toast.makeText(getApplicationContext(),"메뉴화면으로부터 응답 : " + name, Toast.LENGTH_LONG).show();
            
        }

    }
}
```

1. MenuActivity.java
```Java
package com.example.intent;

import androidx.appcompat.app.AppCompatActivity;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;

public class MenuActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_menu);

        Button button2 = (Button) findViewById(R.id.button2);
        button2.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                // 메뉴 화면에서 메인 화면으로 데이터를 전달하고 싶다면? 또, intent 활용
                Intent intent = new Intent();
                intent.putExtra("name","mike"); // 시스템에서 인텐트를 받았다고 하더라도 Extra data는 해석하지 않음
                // 그냥 통과시켜버리기에 MainActivity로 전달됨
                setResult(Activity.RESULT_OK,intent);

                finish(); // 메뉴 화면을 없앤다. 왜냐하면 메뉴 화면이 두번쨰로 실행된 것이라
                // 메인 화면이 아래 깔려 있기 때문에 이 화면을 취소하면 메인 화면으로 돌아가는 것
            }
        });
    }
}
```

1.AndroidManifest.xml
```Java
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.intent">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".MenuActivity"
            android:label="메뉴"
            android:theme="@style/Theme.AppCompat.Light.Dialog"></activity>
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-667897293">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-667897628">

<img src="https://github.com/OneLine-IF/TestLab/issues/2
#issuecomment-667897791
">

- 애플리케이션 구성요소 중의 하나를 만들어 프로젝트에 추가하면 시스템이 이것들을 다루게 되는 거죠. 따라서 새로 추가한 구성요소는 시스템이 알고 있어야 합니다.

- 매니페스트(AndroidManifest.xml) 파일에 어떤 구성요소가 추가되었는지를 넣어두면 앱이 설치될 때 시스템이 이 파일을 보고 구성요소를 확인. 반드시 매니페스트 파일에 그 정보를 넣어주어야 합니다.

- 새로운 액티비티를 실행한 후에 다시 원래의 액티비티로 돌아가고 싶다면 단순히 finish 메소드를 호출하기만 하면 됩니다. 왜냐하면, 어플리케이션에서 실행되는 액티비티는 안드로이드 태스크(Android Task)에서 스택(Activity Stack)형태로 관리되며 이때 순서는 각 액티비티가 열린 순서와 같기 때문입니다.

## 인텐트 살펴보기

1. 인텐트

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-667898084">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-667898321">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-667898444">

1. MainActivity.java
```Java
package com.example.callintent;

import androidx.appcompat.app.AppCompatActivity;
import androidx.core.view.KeyEventDispatcher;

import android.content.ComponentName;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;

public class MainActivity extends AppCompatActivity {
    EditText editText;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        editText = (EditText) findViewById(R.id.editText);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                String receiver = editText.getText().toString();
                Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse("tel:" + receiver));
                startActivity(intent);

                /* 이런 식으로 지정해줄 수도 있다.
                Intent intent2 = new Intent();
                ComponentName name = new ComponentName("com.example.callintent", "com.example.callintent.MenuActivity");
                intent2.setComponent(name);
                startActivity(intent2);
                 */
            }
        });
    }
}
```

- 인텐트는 시스템으로 전달되는 일종의 명령을 담고 있는 객체. 시스템이 이해할 수 있는 객체를 하나 만들어둔 것.

- 인텐트 안에 들어가는 정보 중에서 가장 중요한 것은 액션 정보. 전화걸기를 시스템에 요청할 때는 ACTION_VIEW나 ACTION_DIAL 액션을 넣어줄 수 있는데 이렇게 하면 시스템에서 어떤 동작을 원하는지 이해.

```Java
Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse("tel:01010001000")); 
startActivity(intent);
```

- 이전 시간에 만들었던 메뉴 액티비티를 띄우고 싶다면 MenuActivity.class 라는 클래스 인스턴스를 인텐트의 파라미터로 넘겨주는 방법과 그 외에도 ComponentName 객체를 만들어 설정하는 방법이 있습니다.

```Java
Intent intent = new Intent();

ComponentName name = new ComponentName("org.techtown.intent",
                                                      "org.techtown.intent.MenuActivity");

intent.setComponent(name);          
startActivityForResult(intent, 101);
```

- 실행하고 싶은 액티비티를 문자열로만 지정할 수 있어서 동적으로 액티비티를 지정해주고 싶을 때 사용

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-667898552">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-667898655">

1. 부가데이터

    - 액티비티를 시스템으로 전달하여 실행시킬 때 인텐트가 사용
    - 시스템에서 이해할 수 있는 객체로 만든 것이 인텐트인데, 이 인텐트 안에는 여러 가지 정보가 들어갈 수 있습니다.
    - 인텐트에 설정하는 플래그에 대해 알아보고, 인텐트에 부가데이터로 넣어 전달하는 Parcelable에 대해서도 알아봅시다.
    - 플래그: 인텐트에 추가할 수 있는 옵션

1. 액티비티 플래그 사용 예
```Java
Intent intent = new Intent(getBaseContext(),AnotherActivity.class); // 인텐트 객체 생성 
intent.putExtra("startCount",String.valueOf(startCount)); // 부가 데이터 넣기
intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); // 인텐트 플래그 설정
startActivityForResult(intent, REQUEST_CODE_ANOTHER); // 인텐트 띄우기
```

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-668392366">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-668393111">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-668393284">

- 인텐트가 메뉴 액티비티까지 전달되므로 메뉴 액티비티에서는 전달받은 인텐트 안에 들어있는 데이터를 꺼내어 사용
- 인텐트는 시스템을 통해 다른 액티비티로 전달될 수 있는데 액티비티뿐만 아니라 다른 애플리케이션 구성요소로도 전달될 수 있습니다.
- 부가 데이터는 시스템에서 건드리지 않고 전달만 되며 인텐트 안에 번들(Bundle) 객체가 들어가 있어 그 안에 데이터를 넣을 때는 put …, 문자열을 가져올 때는 get … 메소드를 사용

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-668393314">

1. 액티비티 A에서 액티비티 B를 실행하고 다시 액티비티 A로 돌아오는 과정

- 액티비티 A에서는 인텐트 객체를 만들고 put … 메소드를 이용해 부가데이터를 넣어줍니다.
- 그리고 startActivityForResult 메소드를 호출합니다.
- 액티비티 B가 실행된 후 setResult 메소드를 호출하면서 인텐트를 전달하고 finish 메소드를 호출하면 액티비티 A로 돌아옵니다.
- 액티비티 B에서도 인텐트 안에 부가데이터를 넣어 전달할 수 있는데 이 인텐트는 액티비티 A의 onActivityResult 메소드가 호출되면서 전달받을 수 있습니다.

1. Serializable 과 Parcelable

- ArrayList와 같은 객체들은 이미 Serializable 인터페이스를 구현하고 있으므로 그대로 부가데이터로 추가할 수 있으며, 그 외에 Person과 같이 직접 정의하는 객체들은 Parcelable 인터페이스를 구현한 후 부가데이터로 추가하는 것을 권장

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-668394229">

1. MainActivity.java
```Java
package com.example.parcelable;

import androidx.appcompat.app.AppCompatActivity;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;

import java.util.ArrayList;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Intent intent = new Intent(getApplicationContext(), MenuActivity.class);
                // 여기세 엑스트라 데이터를 넣어주겠다는
                ArrayList<String> names = new ArrayList<String>();
                names.add("김진수");
                names.add("황수연");

                intent.putExtra("names", names);

                SimpleData data = new SimpleData(100, "Hello");
                intent.putExtra("data", data);

                startActivityForResult(intent, 101);

            }
        });
    }
}
```

1. MenuActivity.java
```Java
package com.example.parcelable;

import androidx.appcompat.app.AppCompatActivity;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;

import java.util.ArrayList;

public class MenuActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_menu);

        Button button2 = (Button) findViewById(R.id.button2);
        button2.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                finish();
            }
        });

        Intent passedIntent = getIntent();
        processIntent(passedIntent);
    }

    private void processIntent(Intent intent){
        if(intent != null) {
            ArrayList<String> names = (ArrayList<String>) intent.getSerializableExtra("names");
            if(names != null) {
                Toast.makeText(getApplicationContext(), "전달받은 이름 리스트 갯수 : " + names.size(), Toast.LENGTH_LONG).show();
            }

            SimpleData data = (SimpleData) intent.getParcelableExtra("data");
            if(data != null) {
                Toast.makeText(getApplicationContext(), "전달받은 SimpleData : " + data.message, Toast.LENGTH_LONG).show();
            }
        }
    }
}
```

1. SimpleData.java
```Java
package com.example.parcelable;

import android.os.Parcel;
import android.os.Parcelable;
import android.security.identity.IdentityCredentialStore;

public class SimpleData implements Parcelable {

    int number;
    String message;

    public SimpleData(int number, String message) {// 생성자 만들어주기
        this.number = number;
        this.message = message;
    }

    public SimpleData(Parcel src) {// 이것도 마찬가지로 생성자, Parcel 데이터를 받았을 경우
        number = src.readInt();
        message = src.readString();
    }

    public static final Parcelable.Creator CREATOR = new Parcelable.Creator() {
        // 바로 객체를 만들면서 할당해주는 형태
        public SimpleData createFromParcel (Parcel src) {
            return new SimpleData(src);
        }

        public SimpleData[] newArray(int size) {
            return new SimpleData[size];
        }
    };

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel parcel, int i) {// Parcel 객체로 만들어준다.
        // Parcel 이 결국에는 데이터를, 이 객체 안에 있는 데이터를 다른 데 전달할 때 사용되는 객체라고 생각
        parcel.writeInt(number);
        parcel.writeString(message);
    }
}

```

## 수명주기 이해하기

1. 액티비티 수명주기

    - 실행(Running): 화면 상에 액티비티가 보이면서 실행되어 있는 상태. 액티비티 스택의 최상위에 있으며 포커스를 가지고 있음.

    - 일시 중지(Paused): 사용자에게 보이기는 하지만 다른 액티비티가 위에 있어 포커스를 받지 못하는 상태. 대화상자가 위에 있어 일부가 가려져 있는 경우에 해당함

    - 중지(Stopped): 다른 액티비티에 의해 완전히 가려져 보이지 않는 상태

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-669183004">

- 액티비티는 안드로이드 시스템에 관리되기 때문에 언제라도 중지되거나 메모리에서 삭제될 수 있습니다.

- 를 들어, 전화가 오는 경우 통화를 우선으로 처리해야 하기 때문에 메모리가 모자란다면 여러분의 앱을 임의로 종료

- 수명주기는 화면의 상태에 따라 달라지는데 각각의 상태에 따라 자동으로 호출되는 메소드가 다릅니다.

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-669183237">

- 화면이 없어질 때 데이터를 임시로 저장해두었다가 화면이 다시 보일 때 복구할 수 있어야 하는데 이때 사용되는 메소드가 onPause와 onResume

- onPause 메소드는 화면이 눈에서 보이지 않게 될 때 항상 호출되므로 이때 데이터를 저장해둘 수 있습니다. 데이터는 SharedPreferences를 이용하면 간단하게 저장

- onResume 메소드는 화면이 다시 보일 때 항상 호출되므로 이때 저장해 둔 데이터를 가져와 화면에 설정

```Java
package com.example.lifecycle;

import androidx.appcompat.app.AppCompatActivity;

import android.app.Activity;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Toast.makeText(this, "onCreate() 호출됨", Toast.LENGTH_LONG).show();

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                finish();
            }
        });
    }
    // 5개의 메서드 generate
    @Override
    protected void onStart() {
        super.onStart();

        Toast.makeText(this, "onStart() 호출됨", Toast.LENGTH_LONG).show();
    }

    @Override
    protected void onStop() {
        super.onStop();

        Toast.makeText(this, "onStop() 호출됨", Toast.LENGTH_LONG).show();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();

        Toast.makeText(this, "onDestroy() 호출됨", Toast.LENGTH_LONG).show();
    }

    @Override
    protected void onPause() {
        super.onPause();

        Toast.makeText(this, "oonPause() 호출됨", Toast.LENGTH_LONG).show();
        // sharedpreferences 는 간단하게 어떤 설정 정보 같은 걸 저장하는 그런 방법이다라고 생각을 하시면 됩니다.
        SharedPreferences pref = getSharedPreferences("pref", Activity.MODE_PRIVATE);
        SharedPreferences.Editor editor = pref.edit();
        editor.putString("name", "소녀시대");
        editor.commit();
    }

    @Override
    protected void onResume() {
        super.onResume();

        Toast.makeText(this, "onResume() 호출됨", Toast.LENGTH_LONG).show();

        SharedPreferences pref = getSharedPreferences("pref", Activity.MODE_PRIVATE);
        if(pref != null) {
            String name = pref.getString("name","");
            Toast.makeText(this, "복구된 이름 : " + name, Toast.LENGTH_LONG).show();
        }
    }
}
```

## 서비스 이용하기

1. 서비스 

    - 화면이 없더라도 기능이 실행될 수 있게 해주는 것이 서비스

    - 프로젝트 영역에서 New -> Service -> Service 메뉴를 이용해 서비스 추가

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-669183362">

- 화면 없이 백그라운드에서 실행되는 하나의 단위를 서비스(Service)

- 서비스는 애플리케이션 구성요소이므로 프로젝트에 추가할 때 반드시 매니페스트 파일에도 추가

- 서비스는 startService 메소드를 호출하면 시작

- 서비스는 항상 실행되어 있을 수 있도록 비정상 종료되는 상황이 벌어지더라도 시스템에 의해 자동으로 재시작

- startService 메소드를 호출할 때도 인텐트 객체를 파라미터로 전달해야 하며 이 인텐트 객체는 시스템으로 전달된 후 시스템에서 지정한 서비스를 만들고 실행하는 과정을 거치게 됩니다.

- 그 안에 부가데이터를 넣어 전달할 수 있으므로 서비스로 데이터를 전달하고 싶은 경우에는 startService가 더 자주 호출될 수 있습니다.

- 그런데 이 때의 startService 메소드는 서비스를 시작시키기 위한 목적이 아니라 명령이나 데이터를 전달하기 위한 용도로 사용됩니다.

- 이렇게 startService 메소드를 호출하면서 인텐트 안에 넣어 전달한 명령이나 데이터를 잘 처리할 수 있도록 onStartCommand라는 메소드를 사용할 수 있습니다.

```Java
public class MyService extends Service {

  @Override
  public void onCreate() {
    super.onCreate();

    Log.d(TAG, "onCreate() 호출됨.");
  }

  @Override
  public int onStartCommand(Intent intent, int flags, int startId) {
    Log.d(TAG, "onStartCommand() 호출됨.");
 
    return super.onStartCommand(intent, flags, startId);
  }

}
```

- 서비스에서 액티비티로 데이터를 전달할 때는 인텐트를 사용하며 인텐트 안에 부가데이터를 넣어 보냅니다.

```Java
Intent showIntent = new Intent(getApplicationContext(), MainActivity.class);
showIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);

showIntent.putExtra("command", "show");
showIntent.putExtra("name", "mike");

startActivity(showIntent);
```

- 화면이 없는 서비스에서 화면이 있는 액티비티를 띄울 때는 태스크(Task)를 새로 만들어서 연결

- 액티비티가 화면에 보인 상태에서 위와 같이 startActivity를 호출하면 액티비티는 새로 만들어지지 않고 기존 액티비티를 그대로 사용

- 그리고 액티비티의 onNewIntent 메소드가 자동으로 호출

```Java
@Override
protected void onNewIntent(Intent intent) {
    processIntent(intent);

    super.onNewIntent(intent);
}
```

1. MainActivity.java
```Java
package com.example.service;

import androidx.appcompat.app.AppCompatActivity;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {
    EditText editText;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        editText = (EditText) findViewById(R.id.editText);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                String name = editText.getText().toString();

                Intent intent = new Intent(getApplicationContext(),MyService.class);
                // 데이터를 전달하기 위한 과정
                intent.putExtra("command","show");
                intent.putExtra("name", name);
                startService(intent);// 화면이 아니라 서비스를 실행할 때는 StartService 를 해줍니다.

            }
        });

         Intent passedIntent = getIntent();
         processCommand(passedIntent);
    }

    @Override
    protected void onNewIntent(Intent intent) {
        processCommand(intent);

        super.onNewIntent(intent);
    }

    private void processCommand(Intent intent) {
        if(intent != null) {
            String command = intent.getStringExtra("command");
            String name = intent.getStringExtra("name");

            Toast.makeText(this, "서비스로부터 전달받은 데이터 : " + command + ", " + name, Toast.LENGTH_LONG).show();
        }
    }
}
```

1. MyService.java
```Java
package com.example.service;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.IBinder;
import android.util.Log;

public class MyService extends Service {
    private static final String TAG = "MyService";

    public MyService() {
    }

    @Override
    public void onCreate() {
        super.onCreate();
        // 실제로는 StartService를 아무리 여러번 실행한다고 하더라도 얘는 이미 만들어져 있어서 새로 만들어지지 않는다.
        // 그래서 문제는 인텐트 안에 넣어 서 전달하는 게 OnCreate() 안에서 확인할 수가 없는 문제가 생긴다.
        Log.d(TAG, "onCreate() 호출됨.");
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.d(TAG, "onStartCommand() 호출됨.");
        // 그래서 서비스는 인텐트로 전달한 엑스트라 데이터든가 이런 것들을 확인할 때는
        // OnStartCommand()로 확인한다. 우리말로 하면 명령어를 처리해주세요~
        if(intent == null) {// 서비스가 종료됐을 때도 다시 자동으로 실행해달라고 하는 옵션
            return Service.START_NOT_STICKY;
        } else {// intent 가 null 이 아닐 때는 깔끔하게 메서드 이용해서 intent 처리!
            processCommand(intent);
        }

        return super.onStartCommand(intent, flags, startId);
    }

    private void processCommand(Intent intent) {
        String command = intent.getStringExtra("command");
        String name = intent.getStringExtra("name");

        Log.d(TAG, "전달받은 데이터 : " + command + ", " + name);

        try {
            Thread.sleep(5000);
        } catch(Exception e) {}

        Intent showIntent = new Intent(getApplicationContext(), MainActivity.class);
        showIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK|
                Intent.FLAG_ACTIVITY_SINGLE_TOP|
                Intent.FLAG_ACTIVITY_CLEAR_TOP);// 화면이 없는 곳에서 있는 것을 띄울 수 있다.
        showIntent.putExtra("command", "show");
        showIntent.putExtra("name", name + " from service.");
        startActivity(showIntent);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();

        Log.d(TAG, "onDestroy() 호출됨.");
    }

    @Override
    protected void attachBaseContext(Context newBase) {
        super.attachBaseContext(newBase);
    }

    @Override
    public IBinder onBind(Intent intent) {// 자주 사용하지 않음
        throw new UnsupportedOperationException("Not yet implemented");
    }
}

```

## 브로드캐스트 수신자

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-670389862">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-670389928">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-670389999">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-670390093">

1. 브로드캐스팅이란?

    - 메시지를 여러 대상에게 전달하는 것

    - 안드로이드는 여러 애플리케이션 구성 요소에게 메시지를 전달하고 싶은 경우 브로드캐스팅을 사용. 가장 전형적인 예가 SMS 메시지를 받을 때.

    - 앱에서 브로드캐스팅 메시지를 받고 싶다면 브로드캐스트 수신자를 만들어 등록

    - New 메뉴를 이용해 새로운 브로드캐스트 수신자를 만들면 이 정보도 매니페스트 파일에 추가됩니다. <receiver> 태그를 이용해 추가되는데, 이 태그 안에는 <intent-filter> 태그를 이용해 어떤 브로드캐스팅 메시지를 받고 싶은지 지정

    - 브로드캐스팅 메시지는 인텐트 객체로 만들어져 전달
    - MS 메시지를 받고 싶어 만든 SmsReceiver 클래스는 다음과 같이 등록

```Java
<receiver android:name=".SmsReceiver">
  <intent-filter>
    <action android:name="android.provider.Telephony.SMS_RECEIVED"/>
  </intent-filter>
</receiver>
```

- <intent-filter> 태그 안에 들어있는 <action> 태그는 SMS_RECEIVED 라는 name 속성값을 가지고 있습니다.

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-670390185">

1. SMS 메시지 받기

- 브로드캐스트 수신자를 만들면 그 안에서 onReceive 메소드를 재정의할 수 있으며 메시지를 수신하면 이 메소드가 자동으로 호출

```Java
public class SmsReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        Log.i(TAG, "onReceive() 메소드 호출됨.");
      }
}
```

- SMS를 수신할 때는 권한이 있어야 하며 AndroidManifest.xml 파일 안에  RECEIVE_SMS 권한을 추가하면 수신할 수 있습니다.

```Java
<uses-permission android:name="android.permission.RECEIVE_SMS" />
```

- SMS 수신 권한은 위험 권한이라서 앱 실행 시에 사용자에게 권한 승인을 받아야 합니다. 만약 실행 시에 권한 승인을 받는 코드를 넣기 힘들다면 build.gradle 파일에서 targetSdkVersion을 22이하로 낮추어줍니다.

1. SmsActivity.java
```Java
package com.example.smsreceiver;

import androidx.appcompat.app.AppCompatActivity;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;

public class SmsActivity extends AppCompatActivity {
    EditText editText;
    EditText editText2;
    EditText editText3;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_sms);

        editText = (EditText) findViewById(R.id.editText);
        editText2 = (EditText) findViewById(R.id.editText2);
        editText3 = (EditText) findViewById(R.id.editText3);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                finish();
            }
        });

        Intent passedIntent = getIntent();
        processCommand(passedIntent);
    }

    @Override
    protected void onNewIntent(Intent intent) {
        processCommand(intent);

        super.onNewIntent(intent);
    }

    private void processCommand(Intent intent) {
        if(intent != null) {
            String sender = intent.getStringExtra("sender");
            String contents = intent.getStringExtra("contents");
            String receivedDate = intent.getStringExtra("receivedDate");

            editText.setText(sender);
            editText3.setText(contents);
            editText2.setText(receivedDate);
        }
    }
}
```

1. SmsReceiver.java
```Java
package com.example.smsreceiver;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.telephony.SmsMessage;
import android.util.Log;

import java.text.SimpleDateFormat;
import java.util.Date;

public class SmsReceiver extends BroadcastReceiver {

    private static final String TAG = "SmsReceiver";

    private static SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm");

    @Override
    public void onReceive(Context context, Intent intent) {// 인텐트 안에 sms 데이터가 들어가 있다! -> 이걸 뽑아보자~
       Log.d(TAG, "onReceive() 호출됨.");

       Bundle bundle = intent.getExtras();// 번들은 해쉬태그처럼 엑스트라스를 담고 있음
       SmsMessage[] messages = parseSmsMessage(bundle);

        if(messages.length > 0) {// 한개라도 sms 데이터가 있다는 것
            String sender = messages[0].getOriginatingAddress();
            Log.d(TAG,"sender : " + sender);

            String contents = messages[0].getMessageBody().toString();
            Log.d(TAG, "contents : " + contents);

            Date receivedDate = new Date(messages[0].getTimestampMillis());
            Log.d(TAG, "received date : " + receivedDate);

            sendToActivity(context, sender, contents, receivedDate);
        }
    }

    private void sendToActivity(Context context, String sender, String contents, Date receivedDate) {
        Intent intent = new Intent(context, SmsActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK|
                Intent.FLAG_ACTIVITY_SINGLE_TOP|
                Intent.FLAG_ACTIVITY_CLEAR_TOP);
        intent.putExtra("sender", sender);
        intent.putExtra("contents", contents);
        intent.putExtra("receivedDate", format.format(receivedDate));

        context.startActivity(intent);
    }

    // 메시지를 뽑아내기 위한 메서드
    private  SmsMessage[] parseSmsMessage(Bundle bundle) {
        Object[] objs = (Object[]) bundle.get("pdus");// pdus 약속된 명령어
        SmsMessage[] messages = new SmsMessage[objs.length];

        for(int i = 0; i < objs.length; i++) {
            if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                String format = bundle.getString("format");
                messages[i] = SmsMessage.createFromPdu((byte[])objs[i], format);
            } else {
                messages[i] = SmsMessage.createFromPdu((byte[]) objs[i]);
            }
        }

        return messages;
    }

}

```

## 위험권한 부여하기

1. 들어가기 전에

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-670390284">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-670390618">

- 앞에서 브로드캐스트 수신자(BroadcastReceiver)로 SMS 문자 수신 기능을 만들려면 RECEIVE_SMS 권한이 필요하다는 것

- 위험 권한이 무엇이고 어떻게 하면 사용자에게 권한 부여를 요청할 수 있는지 알아봅시다.

1. 위험 권한

    - 마시멜로 버전부터는 권한을 일반 권한(Normal Permission)과 위험 권한(Dangerous Permission)으로 나누었습니다.

    - 그 이전에는 앱을 설치하는 시점에서만 권한을 부여할 것인지 물어보았는데 사용자가 아무런 생각 없이 앱을 설치하는 경우가 많아 앱에서 아무리 많은 권한을 요구해도 그냥 승인되는 경우가 많았기 때문입니다.

    - 위험 권한은 앱이 실행된 후에 사용자에게 권한 허용을 요청

    - 위험 권한으로 분류된 주요 권한들을 보면 대부분 개인정보가 담겨있는 정보에 접근하거나 개인정보를 만들어낼 수 있는 단말의 주요 장치에 접근하는 경우에 부여되는 권한이라는 것을 알 수 있습니다.

1. MainActivity.java
```Java
package com.example.smsreceiver;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import android.Manifest;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        // 권한이 있는지 확인
        int permissionCheck = ContextCompat.checkSelfPermission(this, Manifest.permission.RECEIVE_SMS);
        if(permissionCheck == PackageManager.PERMISSION_GRANTED) {
            Toast.makeText(this, "SMS 수신 권한 주어져 있음.", Toast.LENGTH_LONG).show();
        } else {
            Toast.makeText(this, "SMS 수신 권한 없음.", Toast.LENGTH_LONG).show();

            //if(ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.RECEIVE_SMS)) {
            //    Toast.makeText(this,"SMS 권한 설명 필요함.", Toast.LENGTH_LONG).show();
            //} else {
                ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.RECEIVE_SMS}, 1);
            //}
        }
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        switch (requestCode) {
            case 1:
                if (grantResults.length > 0) {
                    if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                        Toast.makeText(this, "SMS 수신 권한을 사용자가 승인함.",Toast.LENGTH_LONG).show();
                    } else if (grantResults[0] == PackageManager.PERMISSION_DENIED) {
                        Toast.makeText(this,"SMS 수신 권한을 사용자가 거부함.", Toast.LENGTH_LONG).show();
                    }
                } else {
                    Toast.makeText(this,"SMS 수신 권한을 부여받지 못함.", Toast.LENGTH_LONG).show();
                }

        }
    }
}
```
