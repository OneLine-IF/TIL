### 네이버_부스트코스_2

## 테이블 레이아웃, 스크롤뷰 사용하기

1. 테이블 레이아웃 (TableLayout)

	- 격자 모양으로 뷰를 배치할 때 사용

    - 테이블 레이아웃에 아래의 코드 작성 -> 내용물을 각각 하나의 칼럼으로 보고 여유 공간이 없도록 줄을 칼럼들로 채운다. 

```Java
android:stretchColumns="0,1,2" // 한 줄에 3개의 칼럼(칸)이 들어가도록 설정

android:layout_span="2" // 해당 위젯의 너비를 칼럼 2개짜리로 만듦

android:layout_column="1" // 인덱스값 0,1,2 중 1(가운데)에 해당하는 위치
android:layout_column="2" // 인덱스값 0,1,2 중 2(마지막)에 해당하는 위치
```

1. 특징

	- 각각의 행은 <TableRow>태그를 이용해 추가

	- 그 안에 몇 개의 뷰를 추가하는가에 따라 열의 개수가 결정

	- 여러 개의 <TableRow>가 추가될 수 있고 각각의 <TableRow> 안에는 여러 개의 뷰가 들어갈 수 있는 구조로 되어 있음  

1. 스크롤뷰 (ScrollView)

	- 스크롤 기능을 쉽게 만들 수 있도록 함

	- 이미지뷰나 텍스트뷰들의 뷰를 스크롤뷰로 감싸주면 스크롤뷰가 뷰의 영역을 계산하고 화면에 보이는 공간을 넘어갔을 때 자동으로 스크롤을 만들어 줌

## 이벤트 처리하기

<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-664406248">

1. 대표적인 이벤트

	- 터치 이벤트 : 화면을 손가락으로 누를 때 발생하는 이벤트

	- 키 이벤트 : 키패드나 하드웨어 버튼을 누를 때 발생하는 이벤트

	- 제스처 이벤트 : 터치 이벤트 중에서 일정 패턴을 만들어 내는 이벤트

	- 포커스 : 뷰마다 순서대로 주어지는 포커스 (자주 쓰이지 x)

	- 화면 방향 변경 : 화면의 방향이 가로/세로로 바뀜에 따라 발생하는 이벤트

<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-664407119">

1. MainActivity.java
```Java
package com.example.event;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.view.GestureDetector;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {
    TextView textView;

    GestureDetector detector;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.textView);

        View view = findViewById(R.id.view);
        view.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                int action = event.getAction();

                float curX = event.getX();
                float curY = event.getY();

                if(action == MotionEvent.ACTION_DOWN){
                    println("손가락 눌렸음 : " + curX + ", " + curY);
                } else if(action == MotionEvent.ACTION_MOVE){
                    println("손가락 움직임 : " + curX + ", " + curY);
                } else if(action == MotionEvent.ACTION_UP){
                    println("손가락 떼졌음 : " + curX + ", " + curY);
                }

                return true;
            }
        });

        detector = new GestureDetector(this, new GestureDetector.OnGestureListener() {
            @Override
            public boolean onDown(MotionEvent motionEvent) {
                println("onDown() 호출됨.");
                return true;
            }

            @Override
            public void onShowPress(MotionEvent motionEvent) {
                println("onShowPress() 호출됨.");
            }

            @Override
            public boolean onSingleTapUp(MotionEvent motionEvent) {
                println("onSingleTapUp() 호출됨.");
                return true;
            }

            @Override
            public boolean onScroll(MotionEvent motionEvent, MotionEvent motionEvent1, float distanceX, float distanceY) {
                println("onScroll() 호출됨 : " + distanceX + ", " + distanceY);
                return true;
            }

            @Override
            public void onLongPress(MotionEvent motionEvent) {
                println("onLongPress() 호출됨.");
            }

            @Override
            public boolean onFling(MotionEvent motionEvent, MotionEvent motionEvent1, float velocityX, float velocityY) {
                println("onFling() 호출됨 : " + velocityX + ", " + velocityY);
                return true;
            }
        });

        View view2 = findViewById(R.id.view2);
        view2.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                detector.onTouchEvent(event);
                return true;
            }
        });
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if(keyCode == KeyEvent.KEYCODE_BACK){
            Toast.makeText(this, "시스템 BACK 버튼 눌림.", Toast.LENGTH_LONG).show();
            return true;
        }

        return false;
    }

    public void println(String data) {
        textView.append(data + "\n");
    }

}
```

1. 키 입력 이벤트 처리하기 

<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-664409084">

1. activity_main.xml
```Java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <View
        android:id="@+id/view"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:background="#03A9F4" />

    <View
        android:id="@+id/view2"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:background="#FFC107" />

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">

        <TextView
            android:id="@+id/textView"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:textColor="#000000"
            android:textSize="16dp" />
        
    </ScrollView>

    <EditText
        android:id="@+id/editTextTextPersonName2"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:background="@drawable/my_selector"
        android:ems="10"
        android:inputType="textPersonName"
        android:text="Name" />

</LinearLayout>
```

1. my_selector.xml

```Java
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:state_focused="true" // 넣고 안넣고 무슨 차이?
        android:state_pressed="true"
        android:drawable="@drawable/red"/>

    <item
        android:drawable="@drawable/blue"/>
</selector>
```

- 클릭 이벤트는 터치 이벤트를 단순화한 것인데요, 터치 이벤트는 손가락으로 터치했을 때 생기는 각각의 상태를 다룰 수 있도록 해 줍니다.

- 손가락을 누른 상태, 손가락을 누르고 움직이는 상태, 손가락을 뗀 상태를 각각 이벤트로 전달합니다.

1. 터치 이벤트 처리하기

	- 뷰 객체에 OnTouchListener를 설정하고 싶다면 setOnTouchListener 메소드를 사용합니다.
	
	- OnTouchListener 안에는 onTouch 메소드를 정의할 수 있는데 뷰가 터치되었을 때 이 메소드가 자동으로 호출됩니다.

	- MotionEvent 객체에는 터치된 곳의 좌표와 함께 터치된 상태가 전달됩니다.

1. 키 이벤트 처리하기

	- 키패드의 키가 눌렸을 때는 키 이벤트가 발생합니다.

	- 사용자가 누를 수 있는 키로는 a, b, c와 같은 알파벳이나 1, 2, 3과 같은 숫자가 있을 수 있지만 그 외에도 시스템 BACK 키나 시스템 HOME 키도 있을 수 있습니다.

	- 화면 하단에 항상 보이는 키인데 이 키를 눌렀을 때도 이벤트를 받을 수 있는 거죠. 그 중에서도 시스템 BACK 키는 자주 사용됩니다.

	- 이 경우에는 간단하게 onBackPressed 메소드를 재정의하면 됩니다.

	- 아니면 키 이벤트를 직접 처리할 수도 있습니다.
	
	- 키 이벤트를 처리하고 싶다면 onKeyDown 메소드를 재정의하고 파라미터로 전달된 KeyEvent 객체를 참조합니다.

## 토스트와 대화상자

1. 토스트 보여주기

    - 토스트 : 간단한 메시지를 잠깐 보여주었다가 없어지는 뷰로 애플리케이션 위에 떠 있는 뷰라 할 수 있음

```Java
Toast.makeText(Context context, Stirng message, int duration)


public void setGravity(int gravity, int xOffset, int yOffset)
public void setMargin(float horizontalMargin, float verticalMargin)
```

- 토스트는 간단한 메시지를 잠깐 보여주었다가 없어지는 뷰인데, 앱 화면에 종속되지 않습니다.   

- 토스트 메시지를 보여주고 싶다면 다음과 같은 코드 형태를 사용합니다.

```Java
Toast.makeText(Context context, String message, int duration).show();
```

- 스낵바를 사용할 때의 코드 형태는 토스트를 사용할 때와 유사함
- 다만 Snackbar의 make 메소드를 호출할 때 첫 번째 파라미터로 뷰 객체를 넣어주어야 한다는 점이 다름

```Java
Snackbar.make(v, "스낵바입니다.", Snackbar.LENGTH_LONG).show();
```

1. MainActivity.java
```Java
package com.example.toast;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import com.google.android.material.snackbar.Snackbar;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Button button = (Button) findViewById(R.id.button); // 버튼 객체를 찾아서 변수에 할당
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Toast toast = Toast.makeText(getApplicationContext(), "위치가 바뀐 토스트",Toast.LENGTH_LONG);
                toast.setGravity(Gravity.TOP|Gravity.LEFT,200,200);
                toast.show();
            }
        });

        Button button2 = (Button) findViewById(R.id.button2); // 버튼 객체를 찾아서 변수에 할당
        button2.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                LayoutInflater inflater = getLayoutInflater();
                View layout = inflater.inflate(R.layout.toastborder, (ViewGroup)findViewById(R.id.toast_layout_root));
                // 메모리의 객체화, 뷰 객체가 리턴된다.

                TextView text = (TextView) layout.findViewById(R.id.text);
                text.setText("모양을 바꾼 토스트");

                Toast toast = new Toast(getApplicationContext());
                toast.setGravity(Gravity.CENTER,0,-100);
                toast.setDuration(Toast.LENGTH_LONG);
                toast.setView(layout); // 토스트 객체에 XML 레이아웃을 설정

                toast.show();
            }
        });

        Button button3 = (Button) findViewById(R.id.button3); // 버튼 객체를 찾아서 변수에 할당
        button3.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Snackbar.make(view, "스낵바입니다.", Snackbar.LENGTH_LONG).show();
            }
        });
    }
}
```

1. toastborder.xml -> layout 폴더에 들어있음
```Java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:id="@+id/toast_layout_root">

    <TextView
        android:id="@+id/text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:padding="20dp"
        android:textSize="40dp"
        android:background="@drawable/toast"
        />

</LinearLayout>
```

1. toast.xml -> drawable 폴더에 들어있음
```Java
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">

    <stroke
        android:width="4dp"
        android:color="#ffffff00"/>

    <solid
        android:color="#ff883300"/>
    <padding
        android:left="20dp"
        android:top="20dp"
        android:right="20dp"
        android:bottom="20dp"/>
    <corners
        android:radius="15dp"/>

</shape>
```

1. 알림 대화상자 보여주기

    - 알림 대화상자는 사용자에게 어떤 내용을 알려주거나 '아니오', '예' 버튼을 선택하도록 만들고 싶을 때 사용

    - 알림 대화상자는 AlertDialog 객체를 만들고 show 메소드를 이용해 화면에 표시

    - AlertDialog 객체를 만들 때는 AlertDialog.Builder 객체를 사용

    - 알림 대화상자에는 타이틀, 안내 메시지, 아이콘 그리고 예, 아니오 버튼 등을 설정

1. MainActicity.java

    - activity_main.xml에 버튼과 텍스트뷰 하나 추가해준 다음 실시

```Java
package com.example.dialog;

import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;

import android.content.DialogInterface;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import com.google.android.material.snackbar.Snackbar;

public class MainActivity extends AppCompatActivity {
    TextView textView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.textView);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                showMessage();
            }
        });
    }

    public void showMessage() {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle("안내");
        builder.setMessage("종료하시겠습니까?");
        builder.setIcon(android.R.drawable.ic_dialog_alert);

        builder.setPositiveButton("예", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialogInterface, int i) {
                Snackbar.make(textView, "예 버튼이 눌렸습니다.", Snackbar.LENGTH_LONG).show();
            }
        });

        builder.setNegativeButton("아니오", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialogInterface, int i) {
                Snackbar.make(textView, "아니오 버튼이 눌렸습니다.", Snackbar.LENGTH_LONG).show();
            }
        });

        AlertDialog dialog = builder.create(); // 이때 대화상자가 만들어지는 것
        dialog.show();
    }
}
```

## 비트맵 버튼 만들기

1. 나인패치(Nine Patch) 이미지란?

    - 이미지가 늘어나거나 줄어들 때 생기는 이미지 왜곡을 해결하는 방법을 정의한 것

    - 서로 다른 해상도를 가진 여러 단말에 dp 단위로 뷰의 크기를 맞추다 보면 이미지 크기가 자동 조절되면서 왜곡되는 현상 발생 -> 나인패치 이미지로 해결 

    - 나인패치 이미지는 이런 문제를 해결하기 위해 만들어진 것으로, 원래 이미지보다 한 픽셀씩 크게 만들고 가장자리 픽셀에는 늘어날 수 있는지, 늘어나면 안 되는지를 색상으로 구분

    - 이미지 파일 이름에 .9 

    - https://recipes4dev.tistory.com/132 -> 나인패치 이미지 말들기

1. 비트맵 버튼 만들기

    - 비트맵 버튼을 직접 만들어 normal일 경우와 clicked일 경우의 이미지를 표시

- 나인패치 이미지를 적용하는 대표적인 경우가 바로 버튼인데 이렇게 배경 부분을 이미지로 지정하여 만든 버튼은 아무리 눌러도 이미지의 변화가 없어 사용자가 버튼을 눌렀는지 안 눌렀는지 알 수 없다는 단점이 있음

- 비트캡 이미지를 이용해 버튼의 상태를 표시하려면 버튼이 눌렀을 때와 뗴어졌을 때를 이벤트로 구분하여 처리함

<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-664748849">

```Java
public void onMeasure (int widthMeasureSpec, int heightMeasureSpec)
public void onDraw(Canvas canvas)

void setMeasureDimension(int measuredWidth, int measuredHeight)
```

- 버튼의 배경에 이미지를 설정하고 그 버튼이 눌렸을 때 배경 이미지를 다르게 보여주고 싶다면 버튼을 상속해서 새로운 버튼을 만들고 터치 이벤트를 처리, 그 다음 invalidate 메서드를 이용하여 화면 갱신.

1. BitmapButton.java
```Java
package com.example.button;

import android.content.Context;
import android.graphics.Color;
import android.util.AttributeSet;
import android.view.MotionEvent;

import androidx.appcompat.widget.AppCompatButton;

public class BitmapButton extends AppCompatButton {
    public BitmapButton(Context context) {
        super(context);

        init(context); // 아래의 메서드를 이용해 초기화하는 것
    }

    public BitmapButton(Context context, AttributeSet attrs) {
        super(context, attrs);

        init(context); // 아래의 메서드를 이용해 초기화하는 것
    }

    private void init(Context context) {
        setBackgroundResource(R.drawable.title_bitmap_button_normal);

        float textSize = getResources().getDimension(R.dimen.text_size);
        setTextSize(textSize);

        setTextColor(Color.WHITE);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        int action = event.getAction();

        switch(action) {
            case MotionEvent.ACTION_DOWN:
                setBackgroundResource(R.drawable.title_bitmap_button_clicked);

                break;
            case MotionEvent.ACTION_UP:
                setBackgroundResource(R.drawable.title_bitmap_button_normal);

                break;
        }

        invalidate();

        return true;
    }

}
```

1. dimens.xml
```Java
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <dimen name = "text_size">12dp</dimen>

</resources>
```

1. activity_main.xml
```Java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:orientation="vertical">

<com.example.button.BitmapButton
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Hello World!"
    />

</LinearLayout>
```

## 인플레이션 이해하기

1. 의문

    - 안드로이드에서는 사용자의 눈에 보이는 화면의 배치 부분을 XML 파일로 쉽게 만들 수 있도록 XML 레이아웃 파일과 소스 파일을 분리

    - 분리해둔 XML 레이아웃 파일에 들어있는 버튼을 소스 파일에서도 사용하게 되는데 어떤 과정을 거쳐서 분리된 파일에 넣어둔 정보를 알아낼 수 있는 걸까요?

    - 인플레이션은 그 해답이 될 수 있습니다.


<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-665358483">

- 2개의 파일이 모여서 하나의 파일을 구성한다.

<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-665358894">

<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-665359492">

<img src = "https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-665360248">

1. SetContentView() 메서드의 역할

    - setContentView() 메서드의 역할

        - 화면에 나타낼 뷰를 지정하는 역할
        - XML 레이아웃의 내용을 메모리 상에 객체화하는 역할

```Java
[Reference]

public void setContentView (int layoutResID)
public void setContentView (View view [, ViewGroup.LayoutParams params])
```

- 전체 화면 중에서 일부분만을 차지하는 화면 구성요소들을 XML 레이아웃에서 로딩하여 보여줄 수 없을까?

    - Layoutinflater 라는 클래스를 제공하며, 이 클래스는 시스템 서비스로 제공됨

- 시스템 서비스 : 안드로이드 단말기가 실행이 됐을 때, 뒷단에서 미리 실행이 되는, 화면이 없는 것을 서비스라고 한다.

* 부분 화면인 경우에는 직접 메모리에 객체화를 해야 된다. 즉, 직접 인플레이션 과정을 걸쳐야 된다고 하는 걸 생각!! 