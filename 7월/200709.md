### 34강

1. args
	- 프로그램을 실행할 때 사용자가 프로그램으로 직접 값을 넘겨줄 때 사용
	- java 클래스명 값1 값2 값3 -> 값을 문자열 형태로 받음
	- public static void main(String [] args)
	- 값을 3개 넣어주면 args가 3개짜리 배열로 생성이 된다.
	- 'cmd'를 통해 or Run Configurations -> Arguments에 입력

### 35강

1. 생성자(constructor)
	- Java 클래스에서 객체를 생성할 때 자동으로 호출되는 메서드를 의미한다.
	- 생성자는 return type이 없으며 메서드의 이름은 클래스의 이름과 동일하다.
	- 생성자는 객체를 생성할 때 "반드시 수행되어야하는 코드"가 있거나 "초기화 작업"을 하는데 사용된다.
	- 사용 양식 : public 클래스명( 매개변수 ) { 코드 }

1. default 생성자
	- 생성자를 클래스에 만들지 않으면 매개변수가 없는 생성자가 자동으로 만들어지며 내부에는 소스 코드가 없다.
	- 이렇게 매개변수가 없는 생성자를 default 생성자라고 부른다.
	- 생성자를 개발자가 직접 만들 경우 default 생성자는 자동으로 생성되지 않는다.
	
1. 매개 변수가 있는 생성자
	- 생성자는 매개변수를 가질 수 있으며 매개변수가 있는 생성자를 만들 경우 default 생성자가 생성되지 않는다. 
	- 매개변수의 형태를 다르게 하여 여러 개의 생성자를 생성할 수 있으며 객체를 생성할  때 선택할 수 있다.

```Java
package test.pack;

public class PackageTest {

	public static void main(String[] args) {
		new PackageTest();// 객체를 생성
		new PackageTest(10);// 객체를 생성
		new PackageTest(10, 20);// 객체를 생성
	}
	// 매개변수가 없는 생성자 - default 생성자
	public PackageTest() {
		System.out.println("Default 생성자");
	}
	// 매개변수가 있는 생성자
	public PackageTest(int a) {
		System.out.println("넘겨받은 정수값 : " + a);
	}
	// 매개변수가 2개인 생성자
	public PackageTest(int a, int b) {
		System.out.println("두 수의 합 : " + (a+b));
	}
	
}
```
1. 학 습 정 리
	- 객체를 생성할 때 자동으로 호출되는 메서드를 생성자라고 부른다.
	- 매개변수가 없는 생성자를 default 생성자라고 부르며 클래스를 만들 때 생성자를 만들지 않으면 default 생성자가 "자동으로" 추가된다.
	- 생성자는 매개변수를 가질 수 있으며 객체를 생성할 때 값을 전달해 줄 수 있다.
	- 생성자의 매개변수의 형태를 다르게 하여 여러 개의 생성자를 만들 수 있으며 객체를 생성할 때 선택할 수 있다.

### 36강
1. 상속(inheritance)
	- 클래스를 만들 때 다른 클래스가 가지고 있는 메서드 혹은 변수를 가져와서 사용하는 방법 중에 하나이다.
	- 참조와는 달리 메서드와 변수를 물려받아 자기 자신 것처럼 사용하는 개념을 의미한다.
	- 기존에 만든 클래스에 새로운 기능을 추가하거나 이미 만들어진 메서드를 다시 구현할 경우 사용한다.
	- 기존에 만들어진 클래스를 직접 손대지 않고 추가 혹은 수정을 가할 수 있으므로 객체 지향 프로그래밍에서는 굉장히 많이 사용되는 기법이다.
	- 자바에서는 상속을 받기 위한 코드를 작성하지 않으면(개발자가 직접 상속시킨 클래스가 없다면) Object라는 클래스를 자동으로 상속 받게 된다.
1. 부모와 자식
	- 객체 지향 언어에서는 물려 주는 쪽을 부모클래스(Super Class)라고 부르며 물려 받는 쪽을 자식 클래스(Sub Class)라고 부른다.
```Java
package test.pack;

public class PackageTest {

	public static void main(String[] args) {
		Class1 c1 = new Class1();
		c1.v1 = 100;
		c1.method1();
		
		c1.v2 = 200;
		c1.method2();
		
		c1.method3();
	}
	
}
```

```Java
package test.pack;

public class Class1 extends Class2 {// 이렇게 해주면 Class1은 Class2를 상속받는다.
	int v1;
	
	public void method1() {
		System.out.println("Class1의 변수 v1 : " + v1);
	}
	
	public void method3() {
		v2 = 1000;
		method2();
	}
}
```

```Java
package test.pack;

public class Class2 {
	int v2;
	
	public void method2() {
		System.out.println("Class2의 변수 v2 : " + v2);
	}
}
```

1. 학 습 정 리
	- 클래스를 만들 때 특정 클래스의 메서드와 변수를 물려받는 걸 상속이라고 부른다.
	- 물려주는 클래스를 부모(Super Class)라고 부르며 물려받는 쪽을 자식 클래스(Sub Class)라고 부른다.

### 37강 - 상속을 이용한 다양한 기법에 대해 살펴보자

1. 다형성
	- 참조변수를 통한 객체 접근 : 클래스로부터 객체를 생성하고 생성된 객체의 주소 값을 참조변수에 넣어줄 때, "참조변수의 타입에 따라 생성된 객체에 접근할 수 있는 영역은 달라진다."
	- 자식 클래스형 참조변수로 객체 생성 : 자식 + 부모 전체 접근 가능
	- 부모 클래스형 참조변수로 객체 생성 : "접근 영역이 부모 클래스 한정"

```Java
package test.pack;

public class PackageTest {

	public static void main(String[] args) {
		Class1 c1 = new Class1();
		
		c1.Class2V1 = 100;
		c1.Class2Method();
		
		c1.Class1V1 = 300;
		c1.Class1Method();
		
		Class2 c2 = new Class1();
		c2.Class2V1 = 200;
		c2.Class2Method();
		
		// c2.Class1V1 = 400;// 오류 -> 참조 변수의 타입이 부모 클래스
		// c2.Class1Method();// 오류 -> 참조 변수의 타입이 부모 클래스
	}
	
}
```

1. 메서드의 Overriding
	- 부모 클래스가 가지고 있는 메서드를 자식 클래스에서 다시 구현한 것을 가르킨다.
	- 메서드를 Overriding을 하고 부모 클래스의 메서드를 호출하고자 할 때는 super 를 이용한다.

```Java
package test.pack;

public class PackageTest {

	public static void main(String[] args) {
		Class1 c1 = new Class1();
		
		c1.Class2V1 = 100;
		c1.Class2Method();
		
		c1.Class1V1 = 300;
		c1.Class1Method();
		
		c1.Class2Method2();
		
		Class2 c2 = new Class1();
		c2.Class2V1 = 200;
		c2.Class2Method();
		
		// c2.Class1V1 = 400;// 오류 -> 참조 변수의 타입이 부모 클래스
		// c2.Class1Method();// 오류 -> 참조 변수의 타입이 부모 클래스
		
		c2.Class2Method2();// 자식 클래스에 Overiding한 메서드가 호출이 된다. 
	}
	
}
```
```Java
package test.pack;

public class Class1 extends Class2 {// 이렇게 해주면 Class1은 Class2를 상속받는다.
	int Class1V1;
	
	public Class1() {
		super(100);// 자식 클래스의 생성자에서 부모 클래스의 생성자를 선택하여 호출
		System.out.println("자식클래스의 생성자");
	}
	
	public void Class1Method() {
		System.out.println("Class1의 메서드 - Class1V1 : " + Class1V1);
	}
	
	public void Class2Method2() {
		System.out.println("자식 클래스에서 Overriding한 메서드");
		super.Class2Method2();// 이렇게 해주면 부모 클래스의 메서드도 사용 가능
	}
}

```
```Java
package test.pack;

public class Class2 {
	int Class2V1;
	
	public Class2() {
		System.out.println("부모클래스의 생성자");
	}
	
	public Class2(int a) {
		System.out.println("부모클래스의 생성자2 : a - " + a);
	}
	
	public void Class2Method() {
		System.out.println("Class2의 메서드 - Class2V1 : " + Class2V1);
	}
	
	public void Class2Method2() {
		System.out.println("Class2의 메서드2");
	}
}
```
	- 참조 변수의 활용 : 부모 클래스형 참조 변수를 통해 객체에 접근하면 부모 클래스의 영역만 접근하지만 여기서, "호출하려는 메서드가 Overriding 된 경우에는 자식 클래스에서 재정의한 메서드가 호출"이 된다.

핵심 : 부모 클래스가 가지고 있는 메서드를 자식 클래스가 오버라이딩한 경우 자식 클래스의 메서드가 호출된다는 점 기억!!






