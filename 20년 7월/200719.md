## 안드로이드 생명주기
### 1.Activity 생명주기
<img src="https://user-images.githubusercontent.com/32586985/87867578-4adf9e80-c9c9-11ea-91db-0a2154ffd084.PNG">

- Activity의 상태에 따라 함수들이 호출됨
- Activity의 상태에 따라 호출되는 함수들
- onCreate()
	- 최초로 Activity를 실행하면, 처음으로 호출되는 함수
	- 초기화 관련 작업을 하면 좋음
- onStart()
	- 최초로 Activity를 실행하면, onCreate() 다음으로 호출되는 함수
	- onStop() -> onRestart() 다음으로 호출되는 함수이기도 함
	- 이 시점부터는 사용자가 액티비티를 볼 수 있음
- onResume()
	- 최초로 Activity를 실행하면, onStart() 다음으로 호출되는 함수임
	- onPause() 다음으로 호출되는 함수이기도 함
	- 이 시점부터는 Activity가 활성화 된 상태(실행중인 상태)로 봄
- onPause()
	- 만약 onResume()가 호출된 이후에(Activity가 활성화 된 이후에) 다른 Activity가 최상단에서 보여지는(포커스를 잃은) 경우 호출되는 함수임
	- 만약 onPause()가 호출된 이후에(다른 Activity가 최상단에서 보여진 이후에) 다시 기존 Activity로 돌아오는 경우 onResume()가 호출됨
	- 만약 다른 앱이 메모리를 필요로 할 경우 앱 프로세스가 종료될 수 있음
- onStop()
	- 만약 onResume()가 호출된 이후에(Activity가 활성화 된 이후에) 다른 Activity가 최상단에서 보여지는(포커스를 잃은) 경우 + Activity가 완전히 보이지 않는 경우 호출되는 함수임
	- 만약 onStop()이 호출된 이후에(다른 Activity가 최상단에서 보여진 이후에) 다시 기존 Activity로 돌아오는 경우 onStart()가 호출됨
	- 사용자에 의하거나(ex.onBackPressed() 호출), 시스템에 의해(ex. 자원부족)Activity가 완전히 종료되면 onDestroy()가 호출됨
	- 만약 다른 앱이 메모리를 필요로 할 경우 앱 프로세스가 종료될 수 있음
- onDestroy()
	- Activity가 사용자에 의하거나 시스템에 의해 완전히 종료되는 경우 호출되는 함수
		- 사용자에 의해 종료되는 경우 onBackPressed() 호출, finish()등의 경우가 있음(onBackPressed() 호출 시, 기존 실행된 액티비티가 onResume()까지 호출된 후 onDestroy가 호출됨)
		- 시스템에 의해 종료되는 경우는 대표적으로 자원부족 문제를 해결하기 위한(메모리 확보를 위한) 경우가 있음
- onRestart()
	- onStop()이 호출된 이후에(다른 Activity가 최상단에서 보여진 이후에) 다시 기존 Activity로 돌아오는 경우 호출되는 함수
	- onRestart()가 호출된 이후 이어서 onStart()가 호출됨

### 2.Fragment 생명주기
- Fragment는 Activity의 특징 일부를 물려받은 독자적인 생명주기를 가지는 UI컴퍼넌트임
- Activity가 활성화 된 상태(실행중인 상태)에서 작동함
<img src="https://user-images.githubusercontent.com/32586985/87867687-8fb80500-c9ca-11ea-8611-8a1831b9e740.PNG">

- onAttach()
	- Activity에서 Fragment를 추가하면 호출됨
	- 인자로 context를 받아서 Listener interface를 implement한 경우에 Context를 통해 가져올 수 있음
- onCreate()
	- onAttach() 다음으로 호출되는 함수임
	- 액티비티의 onCreate()와 역할이 비슷함
	- 단, UI에 관련된 작업(ex.View와 ViewGroup의 ui바인딩과 같은 작업들...)은 할 수없음
	- 하지만 UI관련된 작업외, Int형...등등의 변수 초기화 등의 작업정도는 가능함
- onCreateView()
	- onCreate() 다음으로 호출되는 함수임
	- 지금부터, Fragment에 속한 UI 관련된 작업을 할 수 있는 단계임
- onActivityCreated()
	- onCreate() 다음으로 호출되는 함수임
	- Fragment가 backStack에서 돌아오면 호출되는 함수이기도 함
	- Activity에서 Fragment 생성이 완료되면 호출되는 함수임
- onStart()
	- onActivityCreated() 다음으로 호출되는 함수임
	- Activity와 마찬가지로 이 시점부터는 사용자가 액티비티를 볼 수 있음
- onResume()
	- onStart() 다음으로 호출되는 함수임
	- Activity와 마찬가지로 이 시점부터는 Fragment가 활성화 된 상태(실행중인 상태)로 봄
- onPause()
	- Fragment의 호스트 Activity가 포커스를 잃고 다른 Activity가 최상단에서 보여지는 경우 호출됨
	- 1번과 같은 경우, Fragment가 backStack으로 들어감
- onStop()
	- Fragment의 호스트 Activity가 포커스를 잃고 다른 Activity가 최상단에서 보여지는 경우 + Activity가 완전히 보이지 않는 경우 호출됨
- onDestroyView()
	- Fragment에 구현된 View가 제거되는 단계임
	- 이 메소드가 호출된 이후 Fragment가 BackStack에서 돌아오면 onCreateView()가 호출됨
- onDestroy()
	- Fragment를 완전히 제거하기 직전임
- onDetach()
	- Fragment가 제거되고, Activity로부터 해제될 때 호출됨

### 3. Service 생명주기
- startService()를 통해 호출된 서비스
- bindService()를 통해 호출된 서비스
<img src="https://user-images.githubusercontent.com/32586985/87867785-96934780-c9cb-11ea-8ac8-fa87faab1fd6.PNG">

- startService()를 통해 호출된 서비스
	- 서비스 스스로가 서비스를 종료하거나, 클라이언트가 stopService()를 호출하는 경우, 서비스는 소멸됨
- bindService()를 통해 호출된 서비스
	- 서비스에 연결된 클라이언트가 모두 unbindService()된 상태면, 서비스는 소멸됨

## 인텐트
### 1. 인텐트 정의
- 일종의 비동기식 메시지 객체
- 안드로이드 시스템으로 전달되어 시스템이 특정 구성 요소를 활성화할지 아니면 구성 요소의 특정 유형을 활성화할지를 나타내는 메시지

### 2. 인텐트 역할
- 앱 구성요소 간에 작업 수행을 위한 정보를 전달하는 역할
- 액티비티 시작 
	- Activity 'A'에서 새로운 Activity 'B'의 인스턴스 시작(결과 수신 X)
		- 'A'에서 startActivity(new Intent(getApplicationContext(),B.class));를 호출
	- Activity 'A'에서 새로운 Activity 'B'의 인스턴스 시작(결과 수신 O)
		- 'A'에서 startActivityForResult(new Intent(getApplicationContext(),B.class));를 호출
		- 'A'의 콜백 메소드 onActivityResult(int requestCode, int resultCode, Intent data)에서 결과로 별도의 Intent 객체를 수신하게 됨
- 서비스 시작
	- 서비스를 시작하여 일회성 작업을 수행
		- Intent를 startService()에 전달
	- 서비스가 클라이언트-서버 인터페이스로 디자인 된 경우, 다른 구성 요소로부터 서비스에 바인드
		- Intent를 bindService()에 전달
- 브로드캐스트 전달
	- 다른 여러 앱에 브로드캐스트 전달
		- Intent를 sendBroadcast() 또는 sendOrderedBroadcast() 또는 sendStickyBroadcast()에 전달하면 됨
	- 구성요소 간 데이터 송수신

### 3. 인텐트 종류
- 명시적 인텐트
	- 시작할 구성 요소 이름 지정
		- 이름 지정(O), 완전히 정규화된 클래스 이름 사용
	- 시작할 구성 요소
		- 일반적으로 본인의 앱의 구성요소
	- 사용하는 경우
		- 본인이 만든 앱이라서 시작하고자 하는 구성 요소의 클래스 이름을 명확히 알고 있을 때
		- 서비스를 시작할 때 앱의 보안을 보장하기 위해서 항상 명시적 인텐트를 사용하고, 인텐트 필터를 선언하지 않음(암시적 인텐트로 서비스 시작하면 어느 서비스가 응답할지 확신할 수 없고, 사용자가 어느 서비스가 시작되는지 볼 수 없어, 보안 위험을 초래하므로, 암시적 인텐트 사용하지 못하게)
	- 안드로이드 시스템의 처리방식(인텐트가 안드로이드 시스템으로 전달되면)
		- 안드로이드 시스템이 즉시 인텐트 객체에서 지정된 앱 구성 요소 시작함
- 암시적 인텐트
	- 시작할 구성 요소 이름 지정
		- 이름 지정(X), 이름 대신, 수행할 일반적인 작업을 선언
	- 시작할 구성 요소
		- 다른 앱의 구성 요소
	- 사용하는 경우
		- 본인이 만들지 않은 앱의 구성 요소의 클래스 이름을 모르지만, 그 구성 요소를 사용하고 싶을 때 
		- 특히 본인이 만든 앱이 할 수 없는 작업을 할 수 있는 다른 앱을 통해 하고자 할 때, 그리고 사용자로 하여금 어느 앱을 선택할지 선택하도록 하고자 할 때 유용함
	- 안드로이드 시스템의 처리방식(인텐트가 안드로이드 시스템으로 전달되면)
		- 안드로이드 시스템이 시작시킬 적절한 구성 요소 찾음(안드로이드 시스템이 설치된, 기기에 있는 다른 여러 앱의 매니페스트 파일에서 선언된 인텐트 필터와 비교하는 방법 사용)
		- 전달된 인텐트와 일치하는(호환되는) 인텐트 필터가 있으면, 시스템이 해당 구성 요소를 시작하면서 인텐트 객체를 전달함
		- 호환되는 인텐트 필터가 여러개면, 시스템이 대화상자를 표시하여 사용자가 어느 앱을 사용할지 직접 선택하도록 함
		- 인텐트 필터
			- 앱의 매니페스트 파일에 들어 있음
			- 해당 구성 요소가 수신하고자 하는 인텐트 유형을 명시해둠
			- 인텐트 필터가 전혀 없는 구성 요소는 명시적 인텐트로만 시작할 수 있음

### 4. 인텐트 기본 요소
- 액션
	- 수행할 기능
	- 예시 -> ACTION_VIEW
- + 데이터
	- 액션이 수행할 대상인 데이터
	- 예시 -> + 웹 페이지 주소
- = 인텐트
	- 데이터를 가지고 어떤 액션을 할지를 나타내는 정보
	- 예시 -> = 웹 브라우저로 해당 웹 페이지를 띄워라 

## 이벤트 처리
- 예시
```XML
<Button
android:id="@+id/btn_start"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:text="Start"/>
```
- OnClickListener 따로 만들어 구현하는 방법
	- onClickListener를 따로 하난 만들고, activity_main.xml에 있는 버튼을 불러와서 버튼에 해당 리스너를 연결시키는 방법
```Java
public class MainActivity extends Activity 
{    
    public void onCreate(Bundle savedInstanceState) 
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
 
        findViewById(R.id.btn_start).setOnClickListener(mClickListener);
    }
 
    Button.OnClickListener mClickListener = new View.OnClickListener() {
        public void onClick(View v) {
                //이곳에 버튼 클릭시 일어날 일을 적습니다.
            }
        }
    };
}
```
- OnClickListener를 생성과 동시에 만드는 방법
	- 새로운 OnClickListener를 만드는 방법, 생성자 new를 이용해서 만듬
```Java
public class MainActivity extends Activity 
{    
    public void onCreate(Bundle savedInstanceState) 
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
 
        findViewById(R.id.btn_start).setOnClickListener(
            new Button.OnClickListener() {
                public void onClick(View v) {
                    //여기에 이벤트를 적어주세요
                }
            }
        );
    }
}
```
- Activity에 OnClickListener 인터페이스를 구현하는 방법
	- MainActivity에서 OnClickListener를 implement하여 구현하는 방법
	- MainActivity가 View.OnClickListener 인터페이스를 받음, 이 액티비티는 public void onClick()메소드가 생기고 이 곳에 할 일을 적고, 버튼의 OnClickListener로 이 액티비티(this)를 연결시켜주면됨 
```Java
public class MainActivity extends Activity implements View.OnClickListener 
{    
    public void onCreate(Bundle savedInstanceState) 
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
 
        Button btn_start =(Button)findViewById(R.id.btn_start);
        btn_start.setOnClickListener(this);
    }
 
    public void onClick(View v) {
        //여기에 할 일을 적어주세요.
    }
}
```
- XML 상에서 onClick 속성을 이용하는 방법
	- activity_main.xml의 button 부분에 onClick=""을 추가함
	- 버튼이 아니더라도 어디에서든 다 쓸 수 있음
```XML
<Button
android:id="@+id/btn_start"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:onClick="btnStart" 
android:text="Start"/>
```
```Java
public class MainActivity extends Activity
{    
    public void onCreate(Bundle savedInstanceState) 
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);    
    }
 
    public void btnStart(View v) { // 위의 XML파일에서 onClick의 변수이름을 메소드로 만듬
        //여기에다 할 일을 적어주세요.
    }
}    
```

## 안드로이드 스레드 처리
- Thread의 필요성
	- 외부 Thread가 없이 Main Thread만으로만 구현하게 된다면, 어떠한 버튼을 눌렀을 때 Main Thread 내부적으로 10초 이상이 걸리는 작업을 한다고 치면, 사용자는 그 일이 끝날 때까지 멈춰있는 화면만 보고 있어야함, 오래 걸리는 작업들을 외부 Thread를 통해 백그라운드 처리하지 않으면 ANR(Android Not Responing)을 보게 됨 
	- ANR이란?
		- Android Not Responing, 애플리케이션이 응답하지 않음
		- 이 에러의 원인은 Main Thread(UI Thread)가 일정 시간 어떤 Task에 잡혀 있으면 발생하게 됨
	- ANR의 발생 요인
		- 애플리케이션이 UI 스레드에 어떠한 I/O 명령(빈번한 네트워크 액세스)으로 인해 막힐 때 
		- 너무 많은 시간을 정교한 메모리 구조를 구축하는데 들일 때
		- Input 이번트(키를 누르거나 화면을 터치하는 등)에 5초 안에 반응을 하지 않을 때
		- BroadcatReceiver가 10초 내로 실행을 끝내지 않을 때(UI가 없는 브로드캐스트 리시버, 서비스도 실행 주체가 메인 스레드이므로 긴 시간을 소모하는 작업인 경우 ANR을 발생시킴)
		- Main Thread(UI)가 일정시간 어떤 Task에 잡혀 있으면 발생하는 에러
	- 예방법
		- 시간 소모가 많은 작업은 스레드를 통해 처리하라
- 안드로이드의 UI는 기본적으로 메인스레드를 주축으로 하는 싱글 스레드 모델로 동작하므로, 메인 스레드에서는 긴 작업을 피해야함
- 긴 작업은 여분의 다른 스레드에서 실행하고 UI를 바꿀 때는 UI 스레드로 접근하도록 스레드가나 통신 방법을 사용해야함
<img src="https://user-images.githubusercontent.com/32586985/87868349-ca706c00-c9cf-11ea-997b-ff050f4d94fd.PNG">

- Handler와 Looper를 이용해 Sub Thread에서 Main Thread로 UI 처리 작업을 전달시킴
- 위와 같이 Main Thread만이 아닌 Sub Thread를 이용할 경우 중간에 처리해주는 매개체로써 사용할 수 있음

## 안드로이드 웹 크롤링
- jsoup 라이브러리를 이용해서 웹 파싱을 할 수 있음
- 필요한 데이터만을 추출하여 확인 할 수 있음
- jsoup는 html, xml등을 파싱할 수 있음
- <uses-permission android:name="android.permission.INTERNET"/>를 추가해줘야함
- 예시
- 그 전에 먼저 레이아웃을 만들어서 텍스트 뷰와 버튼을 하나 만든 상태임
```Java
//테스트1
Elements titles= doc.select("div.news-con h1.tit-news");

System.out.println("-------------------------------------------------------------");
for(Element e: titles){
    System.out.println("title: " + e.text());
    htmlContentInStringFormat += e.text().trim() + "\n";
}

//테스트2
titles= doc.select("div.news-con h2.tit-news");

System.out.println("-------------------------------------------------------------");
for(Element e: titles){
    System.out.println("title: " + e.text());
    htmlContentInStringFormat += e.text().trim() + "\n";
}

//테스트3
titles= doc.select("li.section02 div.con h2.news-tl");

System.out.println("-------------------------------------------------------------");
for(Element e: titles){
    System.out.println("title: " + e.text());
    htmlContentInStringFormat += e.text().trim() + "\n";
}
System.out.println("-------------------------------------------------------------");
```
- doc.select("html의 속성")이 같은 방법으로 데이터만을 뽑을 수 있음

## 안드로이드 파싱
- Json을 이용함, Json은 JavaScript Object Notation의 약자로 데이터를 구조적으로 표현하기 위한 일종의 포맷(Format)으로 네트워크를 통해 데이터를 주고 받을 때 사용되는 경량의 데이터 형식을 의미함 
- Json은 name-value형태의 쌍을 이룸, name과 value는 : 으로 연결됨
- name은 String이기 때문에 반드시 큰따옴표("")로 묵어줘야함, value는 String형 데이터일 때 큰 따옴표("")로 묶어주면 됨, 각 데이터 쌍들의 구분은 쉼표(,)를 사용하여 구분함
- 예시
```JSON
{ "Movies" : [
    {
        "title" : "미션임파서블",
        "grade" : "15세 관람가",
        "category" : "액션"
    },
    {
        "title" : "어벤져스",
        "grade" : "12세 관람가",
        "category" : "액션"
    },
    {
        "title" : "범죄도시",
        "grade" : "19세 관람가",
        "category" : "범죄/스릴러"
    },
    {
        "title" : "",
        "grade" : "",
        "category" : ""
    }
]
}
```
- 위의 JSON 파일을 추가하고 해당 파일을 읽어올 메소드를 구현
```Java
private String getJsonString()
    {
        String json = "";

        try {
            InputStream is = getAssets().open("Movies.json");
            int fileSize = is.available();

            byte[] buffer = new byte[fileSize];
            is.read(buffer);
            is.close();

            json = new String(buffer, "UTF-8");
        }
        catch (IOException ex)
        {
            ex.printStackTrace();
        }

        return json;
    }
```
- Json으로부터 파싱 된 영화 데이터를 담기 위한 클래스
```Java
public class Movie{
    private String title;
    private String Category;
    private String grade;

    public String getTitle() {
        return title;
    }

    public String getCategory() {
        return Category;
    }

    public String getGrade() {
        return grade;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void setCategory(String category) {
        Category = category;
    }

    public void setGrade(String grade) {
        this.grade = grade;
    }

}
```
- getter/setter 함수를 구현하여 외부에서 각 멤버 변수에 접근 가능하도록 구현함
```Java
private void jsonParsing(String json)
    {
        try{
            JSONObject jsonObject = new JSONObject(json);

            JSONArray movieArray = jsonObject.getJSONArray("Movies");

            for(int i=0; i<movieArray.length(); i++)
            {
                JSONObject movieObject = movieArray.getJSONObject(i);

                Movie movie = new Movie();

                movie.setTitle(movieObject.getString("title"));
                movie.setGrade(movieObject.getString("grade"));
                movie.setCategory(movieObject.getString("category"));

                movieList.add(movie);
            }
        }catch (JSONException e) {
            e.printStackTrace();
        }
    }
```