# 48강
- 예외
	- 프로그래밍 상에서 예측이 가능한 오류 사항을 의미함
	- 특정 코드에 대해 오류가 날 수도 있는 사항들을 기재하여 오류가 발생했을 경우 프로그램이 강제 종료되는 것을 막고 오류에 대한 처리를 개발자가 스스로하여 프로그램이 비정상적으로 종료되는 것을 막아주는 기법임
	- 자바에서는 오류가 발생할 수도 있는 코드를 사용할 경우 사용하는 쪽에서 예외처리를 강제적으로 하도록 유도할 수 있음
- Exception
	- 예외가 발생하는 이를 처리해야 하는데 처리를 할 수 있는 기능을 가지고 있는 클래스가 바로 Exception 클래스임
	- Exception 클래스의 경우 예외가 발생되면 사용자에게 메시지를 전달할 수 있는 기능들이 포함되어 있음
	- 기본적인 기능 외에 더 처리할 게 있다면 그에 맞는 Exception을 상속 받은 클래스를 이용하면 됨
	- IOException, InteruptedException...
- RuntimeException
	- 기본사항은 Exception과 동일하지만 Exception을 상속받은 예외클래스는 프로그래밍을 할 때 직접적인 예외처리를 해야만 컴파일에 통과를 하지만 RuntimeException을 상속받은 예외 클래스는 프로그래밍을 할 때 직접적인 예외처리를 하지 않아도 컴파일 되게 허가해줌
	- 하지만 예외가 발생하면 똑같이 강제 종료가 되며 예외가 발생할 수도 있다면 예외 처리를 해줘야 함
	- 하지만 이러한 예외의 경우 if문과 같은 조건문 등을 이용하면 예외 처리없이 오류를 방지할 수 있는 것들만 정의되어 있음
- 예외 처리 블럭
	- 예외처리는 다음과 같은 문법을 통해 처리할 수 있음
	- try {
		  예외가 발생할 수 있는 코드
	  } catch(ArithmeticException e1) {
	  	  arithmeticException이 발생할 경우 처리할 코드
	  } catch(IOException e2) {
	  	  IOException이 발생할 경우 처리할 코드
	  } finally {
  		  예외 발생 여부에 관계없이 처리할 코드
	  }
	- 예외가 발생할 것 같을 때 씀, catch는 여러개 적어도 상관없음
	- catch부분이 실행되도 finally도 실행이 됨
### 실습
```Java
public class ExceptionTest {

		public static void main(String[] args) {
				try {
						System.in.read(); // 오류 발생함, IOException 하지 않은 오류
				} catch (IOException e) {
						e.printStackTrace(); // 예외처리함
				}
		}
}
```
```Java
import java.io.IOException;

public class ExceptionTest {

		public static void main(String[] args) {
				
				int result = 10 / 0; // 예외가 발생함 ArithmeticException 발생, 컴파일은 통과됨
				// 하지만 예외가 발생하면 문제가 생기기때문에 예외가 발생하는 부분을 직접적으로 처리해야함
		}
}
```
```Java
import java.io.IOException;

public class ExceptionTest {

		public static void main(String[] args) {
					TestClass t = new TestClass();
					
					int result = t.method(10, 0); // 예외 발생함, 예외 처리를 해주어야함
					System.out.println(result);
		}
}

class TestClass {

		public int method(int a, int b) { // 두 개의 변수를 받아 나눈 값을 되돌려주는 메소드
				int result = 0;
				try{ // 예외처리함
						result = a / b;
				} catch(ArithmeticException e) {
						System.out.println("0을 입력했습니다"); // 실행 시 위 코드에서 예외가 발생하면 catch의 오류와 맞기 때문에 내용을 출력하게됨
				} finally {
						System.out.println("이 부분은 무조건 실행이 됩니다"); // 예외처리가 되도 예외가 발생하지 않아도 무조건 출력됨
				} // 정상적으로 되도 catch 부분이 되도 무조건 실행이 됨 
				return result;
		}
}
// 예외가 발생할 수 있는 부분을 try ~ catch로 묶어줌
// try 부분 내부에서 예외가 발생했을 경우 catch 부분으로 이동을해서 catch부분의 코드가 실행이됨
// 그리고 finally까지도 실행이됨, finally는 필요가 없으면 사용하지 않아도 됨
```
- throws
	- 메소드에 throws를 사용하면 예외가 발생할 경우 직접 처리하지 않고 메소드를 호출한 곳에서 처리를 하도록 유도할 수 있음
	- 메소드에서 throws를 통해 예외를 전달하면 메소드를 호출하는 쪽은 예외 처리 블록을 이용해 반드시 예외 처리 해줘야함
- throw
	- 메소드 내부에서 예외를 발생시키는 경우에 사용함
	- if문과 같은 조건문을 통해 조건을 검사하고 잘못된 경우라 판단이 되면 예외를 발생시켜 메소드를 호출한 쪽에서 예외를 처리할 수 있도록 유도할 수 있음
### 실습
```Java
import java.io.IOException;

public class ExceptionTest {

		public static void main(String[] args) {
					TestClass t = new TestClass();
					try{
					int result = t.method(10, 2); // 예외처리를 아래는 throws로 하고 메인에서 해도 됨
					// 아래도 똑같이 예외가 발생했지만 throws를 처리했고 main부분은 try ~ catch로 한거임
					} catch(ArithmeticException e){
							System.out.println("예외 발생");
					} catch(IOException e) {
							
					}
					System.out.println(result);
		}
}

class TestClass {

		public int method(int a, int b) throws ArithmeticException, IOException{ 
				// 직접적으로 try ~ catch로 처리하지 않고 throws를 통해 다른 곳으로 처리하는 것임
				
				int result = 0;
				result = a / b;
				// System.in.read();
				if(b > 0) { // 예외를 발생시킴
					throw new ArithmeticException(); // throw를 던지면 코드의 수행이 중단되서 아래의 코드가 오류메시지가 뜸
				} // 이러면 main에서 ArithmeticException의 catch문으로가 출력됨
				return result;
		}
}
```
- 사용자 정의 예외처리
	- 자바에는 무수히 많은 예외처리 클래스를 제공하고 있음
	- 이러한 클래스들 외에 개발자가 만들어서 쓸 경우도 있는데 Exception 클래스를 상속받은 클래스를 만들어주면 됨
	- 만약 어떠한 메시지를 사용자에게 전달하고 싶다면 getMessage메소드를 overriding하면 됨, 이 메소드는 예외가 발생될 때 자동으로 호출됨 
### 실습
```Java
import java.io.IOException;

public class ExceptionTest {

		public static void main(String[] args) {
					TestClass t = new TestClass();
					try{
					int result = t.method(10, 2); // 예외처리를 아래는 throws로 하고 메인에서 해도 됨
					// 아래도 똑같이 예외가 발생했지만 throws를 처리했고 main부분은 try ~ catch로 한거임
					} catch(ArithmeticException e){
							System.out.println("예외 발생");
					} catch(IOException e) {
							
					} catch(MyException e) {
							System.out.println("사용자 정의 예외 발생"); // 아래와 같이 예외가 발생해서
							// 해당 구문 출력됨 
							System.out.println(e.toString()); // 어떠한 Exception이 발생했다라는 메시지가 나옴
							// getMessage메소드 호출, 그곳에 적어놓은 문장이 출력이 됨 
							e.printStackTrace(); // 예외가 어디가 발생했는지 추적할 수 있음 
							// 무슨 라인에서 생겼는지 문제가 있는지 확인해줌
					}
					System.out.println(result);
		}
}

class TestClass {

		public int method(int a, int b) throws ArithmeticException, IOException, MyException{ 
				// 직접적으로 try ~ catch로 처리하지 않고 throws를 통해 다른 곳으로 처리하는 것임
				// RuntimeException 상속 받을경우 throws를 하지 않아도 됨 
				int result = 0;
				result = a / b;
				if(b <= 10) {
						throw new MyException(); // 위의 throws 처리를 해줘야함
				} 
		}
}

class MyException extends Exception{

		public String getMessage() { // 해당 프로그램이 MyException이라는 오류 발생시 자동으로 getMessage를 호출함
				// 그리고 return 시켜주는 문자열을 출력해줌
				return "10보다 큰 값을 넣어주세요";
		}
}
```
### 정리
- 예측이 가능한 오류가 발생했을 경우 이를 처리할 수 있도록 사전에 코드를 작성하는 것을 가르켜 예외 처리라고 부름
- Exception 클래스는 모두 예외 처리 클래스의 부모 클래스임
- 예외가 발생할 수도 있는 곳은 try ~ catch ~ finally 블록을 이용해 처리함
- throws는 예외가 발생할 경우 메소드를 호출한 곳으로 전달함
- throw는 예외를 발생시킬 때 사용함
- 제공되는 예외 처리 클래스외에 사용자가 만들어서 쓸 경우에는 Exception을 상속 받을 클래스를 만들어줌

# 51강
- String
	- String 클래스는 문자열에 대한 작업을 할 수 있도록 제공되는 클래스임
	- 코드상에 " "로 묶인 문자열도 String 클래스의 객체임
	- " "로 묶인 문자열은 가상 머신이 객체를 생성하고 소멸까지도 담당함
	- 프로그래밍을 할 때는 " "로 쓰지만 컴파일을 하게 되면 실제로 String 클래스로부터 객체를 생성하는 것으로 변경됨
- 주요 메소드
<img src="https://user-images.githubusercontent.com/32586985/87214752-62d07600-c36a-11ea-8b7c-c852d9f049f0.PNG">

### 실습
```Java
public class StringTest {


		public static void main(String[] args) {
		
				String str1 = "안녕하세요"; // String 클래스의 객체
				// 문자열 비교
				if(str1 == "안녕하세요") { // str1과 안녕하세요의 주소는 다름, 한 번 만들고 난 후 같은 주소값을 가지고 오기 때문에 같은 문자열이라고 판단을 함
						System.out.println("문자열은 같습니다");
				} else {
						System.out.println("문자열은 다릅니다");
				}

				String str2 = new String("안녕하세요"); // str2의 문자열 객체 직접 생성, 또 다른 string 객체를 만듬
				if(str1 == str2) { // 두 개의 string 클래스 객체가 다르기 때문에 주소값도 다름
						System.out.println("두 문자열의 주소값은 같습니다");
				} else {
						System.out.println("두 문자열의 주소값은 다릅니다");
				}

				String str3 = "안녕하세요";
				if(str1 == str3) { // 같다고 나옴 등호를 가지고 비교를 하면 됨
						System.out.println("두 문자열의 주소값은 같습니다");
				} else {
						System.out.println("두 문자열의 주소값은 다릅니다");
				}
				// 직접 문자열 객체를 생성하는 경우도 있음, 등호를 가지고 같은지 다른지 여부를 알 수 없음
				// 두 스트링 객체가 가지고 있는 문자열을 실제 내용값을 제공하는 메소드를 따로 제공함
				// 실제 내용값을 비교
				if(str1.equals(str2)) { // 직접 순수하게 내용을 가지고 비교함, new를 통해 생성한 경우
				// 가급적 equals를 이용하는 것이 문자열이 같은지를 비교할 때는
						System.out.println("두 문자열은 같습니다");
				} else {
						System.out.println("두 문자열은 다릅니다");
				}

				// 대소문자 비교
				String eng1 = "abCDef";
				String eng2 = "ABcDEF";
				
				if(eng1.equals(eng2)){ // 대소문자가 다르기 때문에 다르다고 나옴
						System.out.println("문자열의 내용은 같습니다");
				} else {
						System.out.println("문자열의 내용은 다릅니다");
				}

				// 대소문자를 무시하고 비교하는 케이스
				if(eng1.equalsIgnoreCase(eng2)){ // 대소문자를 무시하면 같음
						System.out.println("대소문자를 무시하면 같습니다");
				} else {
						System.out.println("대소문자를 무시해도 다릅니다");
				}

				// 문자열을 전부 대소문자를 변경함
				String upperStr = eng1.toUpperCase();
				System.out.println(upperStr);

				String lowerStr = eng1.toLowerCase();
				System.out.println(lowerStr);

				// 문자열이 포함되어 있는지의 여부 검사
				String str4 = "abcdef";
				if(str4.stratsWith("abc")){
						System.out.println("abc로 시작합니다");
				} else {
						System.out.println("abc로 시작하지 않습니다");
				}
			
				if(str4.endsWith("def")){
						System.out.println("def로 끝납니다");
				} else {
						System.out.println("def로 끝나지 않습니다");
				}
				
				// 포함하는지 여부 확인 
				System.out.println(str4.indexOf("c")); // 포함 여부를 인덱스로 확인함
				System.out.println(str4.indexOf("cd")); // 2부터 있으므로 2라고 나옴
				System.out.println(str4.indexOf("ccc")); // -1 나옴 없는 문자열이므로

				// byte 형태로 변환
				byte [] br = str4.getBytes(); // byte 배열 형태로 문자열이 변형해서 나옴
				for(int i = 0; i < br.length; i++) {
						System.out.print(br[i] + " "); // 숫자 형태로 변해서 들어감
				}
				System.out.println();
				// 다시 스트링 형태로 변환, 정상적으로 나옴
				// 외부로 보낼 때 byte형태로 변환한 후 아래와 같은 형태로 문자열 객체를 만들어서 사용하면 됨
				String str100 = new String(br);
				System.out.println(str100);

				// 문자열의 일부를 가져옴
				String str5 = str4.substring(2, 3);
				System.out.println(str5);

				// 문자열의 길이를 측정함
				System.out.println(str4.length());
				System.out.println("안녕하세요".length());

				// 공백제거
				String str6 = "         안녕하세요         ";
				String str7 = str6.trim();
				System.out.println(str6);
				System.out.println(str7);
		}

}
```

# 53강
- Stringtokenizer
	- 문자열을 구분자를 통해 잘라내어 사용할 수 있도록 하는 클래스임
	- 구분자에 의해 잘려진 문자열들을 토큰이라고 부름
	- 구분자를 지정하지 않으면 공백이 구분자가 됨
- 주요 메소드
	- hasMoreElements : 다음에 가져올 토큰이 있는지 여부 검사
	- nextToken : 다음 토큰을 가지고 옴
### 실습
```Java
import java.util.StringTokenizer;

public class StringTokenizerTest {

		public static void main(String[] args) {

				String str = "동해물과 백두산이 마르고 닳도록";

				StringTokenizer st = new StringTokenizer(str); // import 해야함
				
				while(st.hasMoreElements()){
						System.out.println(st.nextToken()); // 구분자가 없을 경우 공백으로 구분
						// 위 문자를 띄어쓰기 기준으로 하나씩 출력함
						// 동해물과
						// 백두산이
						// 마르고
						// 닳도록
				}
				System.out.println("---------------------------");

				st = new StringTokenizer(str);
				while(st.hasMoreElements()) {
						System.out.println(st.nextToken("산")); // 구분자를 산으로 함
						// 동해물과 백두
						// 이 마르고 닳도록
				}
				System.out.println("---------------------------");
				str = "동해^물과 백두_산이 마르_고 닳^도록";
				
				st = new StringTokenizer(str, "_"); // _를 구분으로 해서 나눠짐 str이후 두번째로 값을 넣으면 해당 문자가 구분자로 인식됨
				while(st.hasMoreElements()) {
						System.out.println(st.nextToken());  
				}
				System.out.println("---------------------------");
				st = new StringTokenizer(str, "_");
				while(st.hasMoreTokens()) {
						System.out.println(st.nextToken("^")); // ^ 기준으로 문자열이 잘려나감
				}
				System.out.println("---------------------------");
				st = new StringTokenizer(str, "_", true); // 3번째 true값으로 인해 _ 구분자도 토큰에 포함이됨 기본으로 false값이어 토큰이 포함되지 않음
				while(st.hasMoreTokens()) {
						System.out.println(st.nextToken()); // 구분자도 포함이 되서 _도 출력됨
				}
		}
		
}
```