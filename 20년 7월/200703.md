# 11강
- 상수 -> 프로그램상에서 의미가 변하지 않는 값
- 상수 자체를 코드로 쓰게 된다면 그 값을 변경할 수 없고 표현하는데는 한계가 있음
- 메모리에 넣었다가 CPU가 사용할 때 그 값을 가져옴
- System.out.printf
	- 출력 서식을 가지고 출력할 수 있는 출력문
	- System.out.printf("a : %d b : %s", 100, "안녕하세요");
	- %d(정수), %c(문자), %f(실수형), %s(문자열)
	- %숫자d: 숫자만큼의 공간을 확보하고 빈칸은 빈칸으로 출력함
	- %0숫자d: 숫자만큼 공간을 확보하고 빈칸을 0으로 채워서 출력함
### 실습
```Java
	System.out.printf("정수 : %d\n", 100);
	// 정수 : 100
	System.out.printf("정수 : %d %d\n, 200, 300);
	// 정수 : 200 300

	System.out.printf("%d ~ %d\n", -2147483648, 2147483647);
	// int 범위 안에 있는 값
	System.out.printf("%d ~ %d\n", -2147483649, 2147483648);
	// int 범위를 넘어섬
	System.out.printf("%d ~ %d\n", -2147483649L, 2147483648l);
	// L을 붙이게 되면 8byte의 기억공간을 할당받아 더 많은 숫자를 받을 수 있음

	System.out.printf("%d ~ %d\n", -922337203684775808l, 9223372036854775807l);
	// 큰 범위의 숫자를 사용한다면 l을 붙여서 사용하면됨

	System.out.printf("%c\n", 'a');
	// 문자 출력
	System.out.printf("%d\n", 'a');
	// 서식이 맞지 않아 에러가 뜸

	System.out.printf("%f\n", 123.456);
	// 123.456000
	System.out.printf("%2.2f\n", 123.456);
	// 123.45으로 출력됨, 범위를 제한해서 출력함
	System.out.printf("%.2f\n", 123.456);
	// 123.45 대부분 이런식으로 출력을 함, 정수부분은 상관없으므로

	System.out.printf("%10d\n", 10);
	//           10 -> 빈칸으로 출력함
	System.out.printf("%010d\n", 10);
	// 000000000010 -> 0으로 채워서 출력함

	System.out.printf("%s\n", "반갑습니다");
	// 반갑습니다 
	System.out.printf("%s %d\n", "안녕하세요", 200);
	// 안녕하세요 200 
```
- 코드상에서 변화가 되지 않은 값들을 상수라고함

# 12강
- 변수 -> 프로그램에서 작성의 값의 의미가 수시로 변경될 수 있는 것
- 변수를 사용하면 값을 담을 수 있는 기억 공간이 생기고 그 값을 자유롭게 쓸 수 있음
- 자료형 -> 기억 공간이 자리 잡을 메모리상의 위치와 크기가 필요함
- 그 기억 공간의 크기는 자료형을 통해 결정 할 수 있음
- 양식: 자료형 변수이름 ex) int a
	- 자료형 -> 값을 담을 기억 공간의 크기와 담겨질 값의 형태를 결정함
	- 변수이름 -> 만들어질 기억 공간에 개발자가 접근할 수 있는 이름
- 논리 자료형: boolean
- 정수 자료형
	- byte, char, short, int, long
- 실수 자료형
	- float, double
- 문자열
	- String, 자료형이라기보단 클래스임
- 정수형 기본 자료형
	- int, 정수형 상수 사용시 기본 int형을 잡음
	- 범위가 벗어날 경우 숫자 뒤에 L을 붙혀주면 long형을 잡음
- 실수형 기본 자료형
	- double, 실수형 상수 사용시 기본 double을 잡아줌
	- 사용범위가 크지 않다면 F를 붙여 float형을 써도 됨
### 각자의 자료형을 일단 생각하기, 범위 값이나 byte는 추후에 학습이 필요할 시 자세히 정리하기
### 실습
```Java
	// 논리형(boolean)
boolean bool1 = true; // 참
boolean bool2 = false; // 거짓

System.out.println("bool1 : " + bool1); 
// bool1 : true
System.out.println("bool2 : " + bool2);
// bool2 : false

// 문자형(char)
char char1 = 65;
char char2 = 'A';

System.out.println("char1 : " + char1);
// char1 : A
System.out.println("char2 : " + char2);
// char2 : A

// 정수형
byte byte1 = -128;
byte byte2 = 127;

System.out.println("byte1 : " + byte1);
// byte1 : -128
System.out.println("byte2 : " + byte2);
// byte2 : 127
short short1 = -32768;
short short2 = 32767;

System.out.println("short : " + short1);
// short : -32768
System.out.println("short : " + short2);
// short : 32767
int int1 = -2147483648;
int int2 = 2147483648;

System.out.println("int1 : " + int1);
// int1 : -2147483648
System.out.println("int2 : " + int2);
// int2 : 2147483648

long long1 = -922337203684775808L;
long long2 = 922337203684775807L;

System.out.println("long1 : " + long1);
// long1 : -922337203684775808
System.out.println("long2 : " + long2);
// long2 : 922337203684775807

// 실수형
float float1 = -12.34f;
float float2 = 12.34F;

System.out.println("float1 : " + float1);
// float1 : -12.34
System.out.println("float2 : " + float2);
// float2 : 12.34

double double1 = 12.34;
double double2 = -12.34;

System.out.println("double1 : " + double1);
// double1 : 12.34
System.out.println("double2 : " + double2);
// double2 : -12.34

// 문자열
String str = "안녕하세요";

System.out.println("str : " + str);
// str : 안녕하세요
```

# 13강
- 키보드 입력
	- System.in.read()
		- 자바에서 키보드를 통해 콘솔을 입력 받는 표준입력
		- System.in.read()을 통해 입력을 받게되면 글자 한 개를 입력 받게됨
		- 여러 개를 입력을 받은 경우 System.in.read()을 입력 받을 개수만큼 써줘야함
		- 엔터를 누르게 되면 CR(케리지리턴), LF(라인피드)라는 문자 두 개가 들어감
		- LF는 한 줄 아래로 내리는것, CR은 커서를 제일 앞으로 이동시키는 것
	- BufferedReader
		- System.in은 키보드를 통해 문자 하나를 입력 받지만 BufferedReader를 사용하면 라인 단위로 입력이 가능해짐
### 실습
```Java
int a1 = System.in.read()
System.out.println("a1 : " + a1);
// a 입력 -> a1 : 97
// 문자 하나를 입력 받을 수 있음

int a1 = System.in.read();
System.out.println("a1 : " + a1);
int a2 = System.in.read();
System.out.println("a2 : " + a2);
// ab 입력 -> a1 : 97, a2 : 98 출력
// 각각 입력 받은 값을 출력함

// 위와 같은 방식에서 하나를 입력하고 엔터를 누르게 되면 엔터와 함께 CR과 LF역시
// 문자로 인식하여 인식받음 -> a1 : 97, a2 : 13으로 출력됨

int a1 = System.in.read();
System.in.read();
System.in.read();
System.out.println("a1 : " + a1);
int a2 = System.in.read();
System.out.println("a2 : " + a2);
// a 엔터 b 입력 시 엔터를 인식 받고 a1 : 97, a2 : 98로 출력됨

// System.in.read() 사용시 사용자가 몇 글자를 입력받을지 모르면 문제가 발생함
// 글자를 한 개씩만 입력 받으므로 불편함
```
### 실습2
```Java
InputStreamReader ir = new InputStreamReader(System.in);
BufferedReader br = new BufferedReader(ir);
// 위처럼 입력해서 쓰기 위해서는 해당 부분을 import해야함

String str = br.readLine(); // 문자열 형태로 입력가능

System.out.println(str);
// abc 입력시 abc 출력 -> 라인 단위로 가능, 글자 하나가 아닌

char c1 = (char)System.in.read();
System.out.println("c1 : " + c1);
// a 입력시 c1 : a가 출력됨
```

# 14강
- 연산자
	- 상수나 변수 값을 조작할 수 있도록 해주는 것을 연산 어떠한 연산을 할 것인지에 대한 기호가 연산자임
	- 프로그래밍의 특별히 사용되는 연산자가 있고 연산자의 우선순위가 있음
	- 우선 순위는 위에서 아래로
	<img src="https://user-images.githubusercontent.com/32586985/86439263-35207700-bd43-11ea-9308-37ebc8005ce5.PNG">

	- 최우선 연산자
		- . -> 메모리에 생성된 객체의 멤버의 접근 등 특정 매개체의 하위에 접근할 때 사용하는 연산자
		- [] -> 배열에서 요소에 접근하고자 할 때 사용하는 연산자
		- () -> 수식에서 연산의 우선 순위를 조정하고자 할 때 사용
### 실습
```Java
int a1 = 1 + 2 * 3;
System.out.println("1 + 2 * 3 = " + a1); // 7

int a2 = (1 + 2) * 3;
System.out.println("(1 + 2) * 3 = " + a2); // 9, ()안 먼저 계산
```
	- 단항 연산자
		- ! -> true를 false로 false를 true로 변경하는 연산자, 숫자에는 사용할 수 없음, 무조건 true, false에만
		- ~ -> 숫자의 비트를 0은 1로, 1은 0으로 바꾸는 연산자
		- +/- -> 숫자의 부호를 결정해주는 연산자
		- ++ / -- -> 값을 1 증가시키거나 감소시키는 연산자(전위형), a = a + 1, a = a - 1 대신 쓸 수 있음
		- (cast) -> 값의 타입을 변경할 때 사용하는 연산자 
### 실습
```Java
boolean bool1 = true;

System.out.println("bool1 : " + bool1); // true
System.out.println("!bool1 : " + !bool1); // false

int i1 = 100;

System.out.printf("i1 : %32s\n", Integer.toBinaryString(i1)); // 10진수를 2진수로변환
// i1 :                      1100100
System.out.printf("~i1 : %32s\n", Integer.toBinaryString(~i1));
//~i1 :11111111111111111111110011011

System.out.println(~i1); // -101
System.out.println(~i1 + 1); // -100
// 양수 값을 음수로 변환할때 쓰는 방법
// 음수값 표현위해 -100 절대값의 비트를 구하고 뒤집은 다음 더하기 1을 함 
// 2의 보수의 방법, 컴퓨터는 음수표현을 위와같이함

System.out.println(+i1); // 100
System.out.println(-i1); //-100
// 부호를 변환하는 방법

System.out.println("++i1 : " + ++i1); // 101
System.out.println(i1); // 101, 자기 자신을 하나 증가시키는 것

System.out.println("--i1 : " + --i1); // 100
System.out.println(i1); // 100, 자기 자신을 하나 감소시키는 것

i1 = 214712458;

short s1 = (short)i1; // cast함
long l1 = i1; // 정상 출력됨

System.out.println(l1); // 214712458
System.out.println(s1); // 16522 -> 4byte공간을 다 써서 나오는 값
// 강제로 캐스팅하는 것은 피하는 것이 좋음
```

# 15강
- 산술연산자
	- +,-,*,/ -> 일반적인 사칙연산
	- % -> 나머지를 구하는 연산자
### 실습
```Java
System.out.println("100 + 200 = " + (100 + 200)); // 300
System.out.println("100 - 200 = " + (100 - 200)); // -100
System.out.println("100 * 200 = " + (100 * 200)); // 20000
System.out.println("100 / 200 = " + (100 / 200)); // 0
System.out.println("100 % 200 = " + (100 % 200)); // 100

System.out.println("100" + 200 + 300); // 100200300
// 문자열이 먼저 나오므로 문자열로써 합쳐짐
System.out.println(100 + 200 + "300"); // 300300
// 더하기 연산을 한 뒤에 문자열로 합쳐짐
```
- 시프트 연산자
	- >> -> 비트를 오른쪽으로 이동시켜주는 연산(부호를 유지시킴)
		- 0000 1000 -> 0000 0100
		- 1000 1000 -> 1100 0100
	- << -> 비트를 왼쪽으로 이동시켜주는 연산
		- 0000 1000 -> 0001 0000
	- >>> -> 비트를 오른쪽으로 이동시켜주는 연산(무조건 0으로 채워짐)
		- 0000 1000 -> 0000 0100
		- 1000 1000 -> 0100 0100
### 실습
```Java
System.out.printf("%32s %d\n", Integer.toBinaryString(100), 100);
//                        1100100 100
System.out.printf("%32s %d\n", Integer.toBinaryString(100 >> 1), 100 >> 1);
//                         110010 50
System.out.printf("%32s %d\n", Integer.toBinaryString(100 >> 2), 100 >> 2);
//                          11001 25
// 오른쪽으로 시프트 한 번하면 나누기 2한 효과가 있음

System.out.printf("%32s %d\n", Integer.toBinaryString(200), 200);
//                       11001000 200   
System.out.printf("%32s %d\n", Integer.toBinaryString(200 << 1), 200 << 1);
//                      110010000 400
System.out.printf("%32s %d\n", Integer.toBinaryString(200 << 2), 200 << 2);
//                     1100100000 800
// 왼쪽으로 시프트 한 번 하면 곱하기 2한 효과가 있음

System.out.printf("%32s %d\n", Integer.toBinaryString(-100), -100);
//1111111111111111111111110011100 -100 
System.out.printf("$32s %d\n", Integer.toBinaryString(-100 >> 1), -100 >> 1);
//1111111111111111111111111001110 -50, 아래와 비교하면 이 시프트는 부호를 유지함
System.out.printf("%32s %d\n", Integer.toBinaryString(-100 >>> 1), 200 >>> 1);
// 111111111111111111111111001110 2147483598, 특수한 목적에 연산에서 사용함
```
- 관계 연산자
	- > -> 좌측의 값이 우측의 값보다 크면 true, 작거나 같으면 false
	- < -> 좌측의 값이 우측의 값보다 작으면 true, 크거나 같으면 false
	- > = -> 좌측의 값이 우측의 값보다 크거나 같으면 true, 작으면 false
	- < = -> 좌측의 값이 우측의 값보다 작거나 같으면 true, 크면 false
	- == -> 좌측의 값과 우측의 값이 같으면 true, 다르면 false
	- != -> 좌측의 값과 우측의 값이 다르면 true, 같으면 false
### 실습
```Java
System.out.println("100 > 10 : " + (100 > 10)); // 100 > 10 : true
System.out.println("100 < 10 : " + (100 < 10)); // 100 < 10 : false
System.out.println("100 >= 10 : " + (100 >= 10)); // 100 >= 10 : true
System.out.println("100 <= 10 : " + (100 <= 10)); // 100 <= 10 : false
System.out.println("100 == 10 : " + (100 == 10)); // 100 == 10 : false
System.out.println("100 != 10 : " + (100 != 10)); // 100 != 10 : true
```
- 비트 연산자
	- & -> 두 수를 2진수로 변환한 후 각 자리를 비교하여 둘 다 1일 경우만 1이 되는 연산자
		- 1000 1000 & 0000 1000 = 0000 1000
	- | -> 두 수를 2진수로 변환한 후 각 자리를 비교하여 둘 중에 하나라도 1이면 1이 되는 연산자
		- 1000 1000 | 0000 1000 = 1000 1000
	- ^ -> 두 수를 2진수로 변환한 후 각 자리를 비교하여 두 비트가 같으면 0, 다르면 1이 되는 연산자 (XOR)
		- 1000 1000 ^ 0000 1000 = 1000 0000
### 실습
```Java
System.out.printf("%32s %d\n", Integer.toBinaryString(100), 100);
//                         1100100 100
System.out.printf("%32s %d\n", Integer.toBinaryString(200), 200);
//                        11001000 200
System.out.printf("%32s %d\n", Integer.toBinaryString(100 & 200), 100 & 200);
//                         1000000 64
System.out.printf("%32s %d\n", Integer.toBinaryString(100 | 200), 100 | 200);
//                        11101100 236
System.out.printf("%32s %d\n", Integer.toBinaryString(100 ^ 200), 100 ^ 200);
//                        10101100 172
```

# 16강
- 논리연산자
	- && -> 연산자를 기준으로 좌측과 우측에 관계 연산자가 있을 경우 두 값이 모두 true이면 true, 하나라도 false이면 false를 반환함, 좌측의 연산 결과 없이 false라면 이 후의 연산은 수행하지 않고 false를 반환함
		- 10 < 4 && 10 > 3 -> false, 10 > 3 연산은 수행하지 않음
	- & -> 기본적인 연산은 &&와 같지만 좌측 연산 결과 값이 false라고 하더라도 이 후의 연산을 모두 수행함
		- 10 < 4 & 10 > 3 -> false, 10 > 3 연산도 수행함
	- || -> 연산자를 기준으로 좌측과 우측에 관계 연산자가 있을 경우 두 값 중 하나라도 true면 true, 둘 다 false면 false를 반환함, 좌측의 연산 결과 값이 true라면 이 후의 연산은 수행하지 않고 true를 반환함
		- 10 > 3 || 10 < 4 -> true, 10 < 4 연산은 수행하지 않음
	- | -> 기본적인 연산은 ||와 같지만 좌측 연산 결과 값이 true라고 하더라도 이 후의 연산을 모두 수행함
### 실습
```Java
System.out.println(true && true); // true
System.out.println(true && false); // false
System.out.println(false && true); // false
System.out.println(false && false); // false
// 3,4번째는 앞의 값이 false이므로 확인할 필요없이 false를 내놓음

System.out.println(2 > 1 && 3 < 2); // true
System.out.println(2 > 1 && 3 < 1); // false
System.out.println(2 < 1 && 3 > 2); // false
System.out.println(2 < 1 && 3 < 2); // false

System.out.println(true || true); // true
System.out.println(true || false); // true
System.out.println(false || true); // true
System.out.println(false || false); // false

int k1 = 100;
int k2 = 200;
System.out.println(++k1 > 100 && ++k2 > 200); // true
System.out.println(k1 + " " + k2); // 101 201
// true이므로 뒤의 연산을 했기 때문에

k1 = 100;
k2 = 200;
System.out.println(++k1 < 100 && ++k2 > 200); // false
System.out.println(k1 + " " + k2); // 101 200
// false이므로 뒤의 조건을 볼 필요 없이 연산을 안 함

k1 = 100;
k2 = 200;
System.out.println(++k1 < 100 & ++k2 > 200); // false
System.out.println(k1 + " " + k2); // 101 201
// &의 경우 거짓이어도 뒤의 값을 연산함

k1 = 100;
k2 = 200;
System.out.println(++k1 > 100 || ++k2 > 200); // true
System.out.println(k1 + " " + k2); // 101 200
// 앞의 조건이 참이므로 뒤의 연산을 수행하지 않음

k1 = 100;
k2 = 200;
System.out.println(++k1 > 100 | ++k2 > 200); // true
System.out.println(k1 + " " + k2); // 101 201
// 앞의 조건이 참이지만 |에서는 뒤의 연산을 함
```
- 3항 연산자
	- 조건항 ? 항1 : 항2
	- 조건항의 결과 값이 true면 항1, false면 항2를 반환함
### 실습
```Java
int k3 = 10 > 20 ? 100 : 200;
System.out.println(k3); // 200   
```
- 배정 대입 연산자, 줄여서 쓸 수 있는 것들
<img src="https://user-images.githubusercontent.com/32586985/86440567-a2cda280-bd45-11ea-889b-0400eac912b1.PNG">

- 후위형 증감 연산자
	- -- / ++ -> 자기 자신의 값을 하나 증가하거나 감소하는 연산자
	- 기본적으로 전위형 증감 연산자와 같지만 다음과 같은 차이점이 있음
	- 전위형 -> ++a, --a, 연산작업을 수행 후 값을 전달함
	- 후위형 -> a++, a--, 값을 전달한 후 연산을 수행함
	- int b = a++ -> a의 값을 b에 넣은 후 a 값을 증가
	- int b = ++a -> a의 값을 증가한 후 b에 넣어줌
### 실습
```Java
k1 = 100;
k2 = ++k1;
System.out.println(k1 + " " + k2); // 101 101

k1 = 100;
k2 = k1++;
System.out.println(k1 + " " + k2); // 101 100   
```