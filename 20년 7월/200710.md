# 45강
- 쓰레드
	- 프로그램을 작성하다 보면 동시에 여러개의 일을 해야 할 때가 있음
	- 이러한 멀티 프로세싱을 구현 할 수 있도록 제공하는 것이 쓰레드임
- 쓰레드 작성법
	- 쓰레드를 작성하는 방법은 Thread 클래스를 상속 받는 방법과 Runnable 인터페이스를 구현하는 방법 두 가지가 있음
- 클래스 상속 방법
	- Thread 클래스를 상속 받고 run.메소드를 구현해주면 됨 
	- class 클래스이름 extends Thread{
			public void run(){
					소스코드
			}

	  }
- 인터페이스 구현법
	- Runnable 인터페이스를 구현하고 run 메소드를 구현하면 됨
	- class 클래스이름 implements Runnable{
			public void run(){
					소스코드
			}
	  }
- 쓰레드 사용법
	- Thread 클래스를 상속 받았을 경우에는 상속 받은 클래스의 객체를 생성하고 start메소드를 호출해줌
	- interface를 사용할 경우에는 Thread 클래스의 객체를 생성하고 생성자에 인터페이스를 구현한 클래스의 객체를 넣어줌, 그 이후에 start메소드를 호출해줌
### 실습
```Java
public class ThreadTest {


		public static void main(String[] args) {

				while(true) {
						System.out.println("*");
				}
				// 이와 같이 쓰면 위에 것이 무한루프여서 아래 코드는 실행이 안됨 쓰레드를 사용해야함
				while(true) {
						System.out.println("-");
				}

				while(true) {
						System.out.println("_");
				}

				// 위 3가지 일을 동시에 하려한다면 쓰레드를 이용하면 됨 
}
``` 
```Java
public class ThreadTest {


		public static void main(String[] args) {
			
				Thread1 t1 = new Thread1;
				t1.start();

				Thread2 t2 = new Thread2();
				Thread t = new Thread(t2);
				t.start();

				while(true) {
						try{
								Thread.sleep(1000);
						}catch(Exceptione e){ }
						System.out.print("*");
				}

}

class Thread1 extends Thread{

		public void run(){
				while(true){
						try{
								Thread.sleep(1000);
						}catch(Exception e){ }
						System.out.print("-");
				}

}

class Thread2 implements Runnable{

		@Override
		public void run() {
				while(true){
						try{
								Thread.sleep(1000);
						}catch(Exception e){ }
						System.out.print("_");
				}
		}
}

// 쓰레드를 이용해서 3개의 무한루프문이 따로따로 동시에 실행함
// 거의 대부분 동시에 실행되는 것 같지만 * -> - -> _ 순이 아니고 어떤 작업을 먼저할지
// 고정되어 있지 않음
// 코드상의 작업을 여러개 사용한다고 했을 때 사용함
```
### 쓰레드는 동시에 여러개의 작업을 하고 싶을 때 사용하는 개념임

# 46강
- 쓰레드 우선 순위
	- 자바의 쓰레드는 우선 순위라는 것을 가지고 있음
	- 하나의 프로그램에서 동시에 여러 개의 쓰레드가 운영될 경우 우선 처리할 쓰레드를 결정하는데 쓰레드 우선 순위를 이용함
	- 우선 순위 값은 1 ~ 10까지이며 기본값은 5임
	- 쓰레드의 우선 순위 값이 10이면 가장 먼저 처리할 확률이 높아지고 1이면 다른 것보다 늦게 처리될 확률이 높아짐
	- 우선 순위가 높다고해서 반드시 가장 먼저 처리되는 것은 아니고 가장 먼저 처리될 확률이 높아지는 것 뿐임
### 실습
```Java
public class PriorityTest {

		public static void main(String[] args) {
				
				Thread1 t1 = new Thread1();
				Thread2 t2 = new Thread2();

				System.out.println(t1.getPriority());
				System.out.println(t2.getPriority()); // 이와같이 쓴다면 현재 쓰레드의 설정된 우선순위값을 알 수 있음
				// 별다른 설정을 해주지 않으면 기본이 5로 세팅이 됨 
				
				t1.setPriority(1);
				t2.setPriority(10);
				// 우선순위 10 높게주어도 반드시 먼저 처리되는 것은 아니지만 상대적으로 _를 찍는 빈도가 많아지는건 맞음
				// 확률이 높아지는 것임

				t1.start();
				t2.start(); // 계속해서 실행시 *을 먼저 100번찍고 _를 100번찍고 그 다음에 _ 먼저 후에 * 찍고 균등하게 실행됨
		}
}

// 쓰레드가 여러개 동시에 돌아가면 왔다갔다 작업을 함
// 가장 먼저 작업을 많이 할 쓰레드를 결정하는 것임
// 작업량을 짧은 시간안에 많이 할 경우 효과를 봄 
class Thread1 extends Thread{

		public void run(){
				for(int i = 0; i < 100; i++){
						System.out.print("*");
				}
		}
}

class Thread2 extends Thread{
		public void run(){
				for(int i = 0; i < 100; i++) {
						System.out.print("_");
				}
		}
}
```
### 정리
- 우선 처리될 쓰레드를 결정하는데는 우선 순위 값을 이용함
- 1 ~ 10 사이의 값이며 기본값은 5임
- 값이 높으면 먼저 처리될 확률이 높아짐
- 값이 낮으면 나중에 처리될 확률이 높아짐

# 47강
- 임계영역
	- 동시의 여러 개의 쓰레드가 특정 소스코드 혹은 메소드를 동시에 접근할 경우 해당 메소드를 서로 사용하려고 하는데 이처럼 여러 개의 쓰레드가 동시에 접근 할 수 있는 코드 영역 혹은 메소드를 임계 영역이라고 부름
	- 프로그램에서 임계 영역이 있을 경우 프로그램 전체의 심각한 오류를 발생 시킬 수도 있음
	- 자바에서는 동기화를 통해 이러한 부분을 해결 할 수 있음
- 동기화
	- 동기화를 하게 되면 임계영역 때문에 발생되는 문제를 막아 줄 수 있음
	- 동기화를 하게 되면 쓰레드가 접근하는 순서대로 코드를 처리하고 늦게 도착하는 쓰레드는 기다렸다가 먼저 도착한 쓰레드의 작업이 완료가 되면 다음 쓰레드가 작업을 하게 됨 
	- 동기화는 메소드를 동기화 하는 방법과 코드의 일부분을 동기화 하는 방법으로 나눠짐
- 메소드의 동기화
	- 여러 개의 쓰레드가 호출하는 메소드가 있다고 한다면 메소드의 코드는 임계영역에 해당함
	- 이런 경우 메소드 전체를 동기화 하면 되는데 다음과 같이 작성해 주면 됨
	- public synchronized void method(){
				임계영역
	  }
### 실습
```Java
public class Sync1 {

		public static void main(String[] args) {
				
				DataClass d = new DataClass();
				
				Thread1 t1 = new Thread1(d);
				Thread1 t2 = new Thread1(d);
				t1.setName("T1");
				t2.setName("T2");
				
				t1.start();
				t2.start(); // 두 개의 쓰레드가 돌아가면서 동시에 작업이 됨 동기화 하지 않은 상태
		}
}

class Thread1 extends Thread{
		DataClass dc;
		
		public Thread1(DataClass dc) {
				this.dc = dc;
		}
		
		public void run() {
				dc.method(Thread.currentThread().getName());
		}
}

class DataClass{
		
		public void method(String name){
				for(int i = 0; i < 10; i++) {
						try{
								Thread.sleep(1000);
						}catch(Exception e){ }
						System.out.println(name + " : " + i);
				}
		}
}
```
```Java
public class Sync1 {

		public static void main(String[] args) {
				
				DataClass d = new DataClass();
				
				Thread1 t1 = new Thread1(d);
				Thread1 t2 = new Thread1(d);
				t1.setName("T1");
				t2.setName("T2");
				
				t1.start();
				t2.start(); // 동기화를 이용해서 T1이 먼저 쓰레드로 동작하고 그 이후에 T2가 동작함
				 
		}
}

class Thread1 extends Thread{
		DataClass dc;
		
		public Thread1(DataClass dc) {
				this.dc = dc;
		}
		
		public void run() {
				dc.method(Thread.currentThread().getName());
		}
}

class DataClass{
		// 다른 클래스의 메소드를 두 개의 쓰레드가 동시에 접근하고자 할 때
		// 메소드에 synchronized를 활용하여 동기화를 시킬 수 있음
		public synchronized void method(String name){
				for(int i = 0; i < 10; i++) {
						try{
								Thread.sleep(1000);
						}catch(Exception e){ }
						System.out.println(name + " : " + i);
				}
		}
}
```

- 코드의 동기화
	- Run메소드의 코드 일부분을 동기화 하고자 할 때는 임계 영역에 해당하는 코드 부분을 synchronized 블록으로 묶어주면 됨
	- synchronized(클래스 혹은 객체){
			임계영역 코드
	  }
### 실습
```Java
public class Sync2 {

		public static void main(String[] args) {
				Thread1 t1 = new Thread1();
				Thread1 t2 = new Thread1();

				t1.setName("T1");
				t2.setName("T2");

				t1.start();
				t2.start(); // 동기화를 하지 않았으면 번갈아가면서 실행됨
		}

}

class Thread1 extends Thread{

		public void run() {
				for(int i = 0; i < 10; i++) {
						try{
								Thread.sleep(1000);
						}catch(Exception e){ }
						System.out.println(Thread.currentThread().getName() + " : " + i);
				}
		}
}
```
```Java
public class Sync2 {

		public static void main(String[] args) {
				Thread1 t = new Thread1();
				
				Thread t1 = new Thread(t, "T1");
				Thread t2 = new Thread(t, "T2"); // 별도로 두 개의 쓰레드를 만들어서 돌림 

				t1.start();
				t2.start(); // 두 개의 쓰레드가 동시에 돌아감 
				// 하지만 아래와 같이 동기화를 할 경우 t1이 먼저 실행되고 그 이후 t2가 실행됨
		}

}

// 이런 상황에서 run 메소드의 코드를 동기화 하려면 아래와 같이 쓰면됨
class Thread1 extends Thread{

		public void run() {
				synchronized(this){ // synchronized로 동기화를 함
						for(int i = 0; i < 10; i++) {
								try{
										Thread.sleep(1000);
								}catch(Exception e){ }
								System.out.println(Thread.currentThread().getName() + " : " + i);
						}
				}
		}
}
```
### 정리
- 여러 개의 쓰레드가 메소드 혹은 특정 코드를 같이 사용하는 것을 임계 영역이라고 부름
- 임계 영역으로 인해 발생되는 오류를 방지하기 위해서는 동기화를 해주면 됨 
