# 40강
- Static
	- 변수나 메소드에 static을 붙혀 주게 되면 객체의 생성 없이 사용할 수 있음
	- 같은 클래스로부터 생성된 모든 객체들은 static.변수를 개별적으로 가질 수 없으며 하나의 변수를 공용으로 사용함
	- 객체를 생성하지 않고 사용할 수 있으며 변수나 메소드를 사용할 때는 클래스이름.멤버의 형태로 접근해서 사용함
	- 단 static메소드에서 사용할 수 있는 멤버 변수는 static변수뿐이며 static변수가 아닌 일반 변수들은 객체를 생성해야지만 사용이 가능하기 때문임
	- 무분별하게 사용할 수 있음, 꼭 필요할 때만 사용하는 것이 좋음
### 실습
```Java
// main 클래스
public class StaticTest {
		
		int a;
		static int b;
		
		public static void main(String[] args) {

				a = 100; // non-static 변수이므로 접근 할 수 없음 main은 static으로 선언했으므로
				System.out.println(b); // 출력됨 static 메소드는 static 변수만 사용함

				Class1.a = 300; 
				Class1.method1(); // static을 선언했으므로 다른 클래스에서 접근하는 것도 가능

				Class1 c1 = new Class1();
				Class1 c2 = new Class1();

				c1.a = 1000;
				System.out.println(c2.a); // 1000이 출력됨 같은 클래스에 여러개 객체를 형성됐어도
				// 따로따로 할당되지 않음, 메모리에 있는 static 변수를 그대로 가져다 씀
				// 공통적으로 사용함, 공용 변수라고도 함 
				// c1에 할당하고 c2를 해도 1000이 출력된 것임
		}

}
```
```Java
// Class1 
public class Class1 {
		static int a;

		public static void method1() {
				System.out.println("변수 a : " + a);
		}

}
```

# 41강
- Final
	- Final은 더 이상 변경할 수 없다는 의미를 가지고 있는 키워드임
	- 변수 : 변수에 값을 넣을 수 없으며 변수의 선언과 동시에 초기화를 반드시 해줘야함
	- 메소드 : 상속관계 있을 때 자식 클래스에서 메소드를 Overriding 할 수 없음
	- 클래스 : 상속을 하지 못하도록 막아 줄 수 있음
### 실습
```Java
public class FinalTest {

		public static void main(String[] args) {
				
				Class1 c1 = new Class1();
				c1.a = 300; // 새로운 객체를 사용하더라도 final이므로 할당할 수 없음
				System.out.println(c1.a); // 하지만 값을 사용할 순 있음

		}

}

class Class1 extends Class2{
		final int a = 100;

		public void method1(){
				a = 200; // final 변수이므로 할당 할 수 없음
		}
		public void method2(){ // final 메소드이므로 overriding을 할 수 없음
				System.out.println("overriding method");
		}
}

class Class2{
		public final void method2() {
				System.out.println("final method");
		}
}

final class Class3 {

}

class Class4 extends Class3 { // final 클래스이므로 상속 받을 수 없음

}
```

# 42강
- 중첩 클래스
	- 클래스 내부에 클래스를 만들어서 사용하는걸 의미함 
	- 프로그래밍을 할 때 여러 군데서 사용하는 클래스가 아니라면 파일을 새로 만들거나 코드의 아래 부분으로 내려서 만들지 않고 바로 만들어서 바로 쓸 수 있도록 하는 개념
	- 경우에 따라서는 객체를 생성할 수 있는 부분이 클래스를 설계할 부분으로 한정되어 있는 경우도 있음
	- 클래스 내부에 만든 클래스를 Inner Class라고 부르며 Inner 클래스를 감싸고 있는 클래스를 Outer Class라고 부름
- 일반 중첩 클래스
	- 클래스 내부에 클래스를 만들어서 사용하는 경우임
	- Inner 클래스의 객체를 만들기 위해서는 반드시 Outer 클래스의 객체를 생성하고 이를 통해 Inner 클래스를 만들어야함
	- Inner 클래스는 Outer 클래스의 멤버에 접근할 수 있지만 Outer 클래스는 Inner 클래스의 멤버에 접근할 수 없음
	- Inner 클래스의 멤버는 Outer 클래스의 객체가 생성되어 있다는 가정하에 사용하므로 접근이 가능하지만 Outer 클래스는 Inner 클래스의 객체의 생성과 관계가 없으므로 Inner 클래스에 대한 접근이 자유롭지 못함
### 실습
```Java
public class ReiterationClass1 {

		public static void main(String[] args) {
				Outer out = new Outer();
				Outer.Inner inner = out.new Inner(); // 중첩클래스이므로 내부 클래스 역시 객체 생성
				//해서 만들어야함 

				out.outerMethod();
				inner.innerMethod();
		}

}

class Outer{
		int outer1 = 10;
		
		void outerMethod(){
				System.out.println("Outer의 메소드입니다");
				System.out.println(inner1); // inner1이 선언되지 않은 변수라고 나옴
				// outer가 생성되고 그 다음에 inner가 생성됐다고 하기 때문에
				// outer에서 inner의 멤버 접근은 못 함 
		}
		// 중첩클래스
		class Inner {
				int inner1 = 20;

				void innerMethod(){
						System.out.println("Inner의 메소드입니다");
						System.out.println(outer1); // Outer클래스의 멤버의 접근 가능함
				}

		}

}
```
- static 중첩 클래스
	- 일반 중첩 클래스에서 Inner 클래스가 static으로 정의된 경우임
	- Inner 클래스가 static으로 정의되어 있어 Outer 클래스의 객체 생성 없이 바로 객체 생성이 가능함
	- Inner 클래스에서는 Outer 클래스에 정의된 멤버 중에 static 멤버만 접근이 가능함
	- Outer 클래스의 객체 생성없이 바로 Inner 클래스의 객체를 생성하므로 Outer 클래스의 객체가 생성되지 않았다는 가정하여 개발을 해야함
### 실습
```Java
public class ReiterationClass2 {

		public static void main(String[] args) {
				Outer.Inner inner = new Outer.Inner(); // Outer가 아니라 바로 Inner객체 생성
				inner.innerMethod();

				Outer.Inner.innerMethod(); // innerMethod가 static이 아니므로 안됨, class만 static임
				
		}
		
}

class Outer{
		int outer1 = 10;
		static int outer2 = 20;

		void outerMethod(){
				System.out.println("Outer의 메소드입니다.");
		}
		
		static class Inner{
				int inner1 = 20;
				
				void innerMethod(){
						System.out.println("Inner의 메소드입니다");
						System.out.println(outer1); // 접근 안 됨 outer1이 static이 아니므로 
						System.out.println(outer2); // static이므로 자유롭게 접근가능
				}
		}
}
```
- 메소드 내부의 중첩 클래스
	- 클래스를 메소드 내부에 만든 경우를 의미함
	- 메소드 내부에 만든 중첩 클래스는 다른 곳에서 참조 변수조차 선언할 수 없음
	- Inner 클래스에서는 클래스 내부에 선언한 변수만 사용할 수 있으며 클래스를 만든 메소드 내부에 있는 지역 변수 중 final 변수만 접근이 가능함, 그 외의 모든 변수는 접근이 불가능함
### 실습
```Java
public class ReiterationClass3 {
		
		Inner in; // 참조변수에서 선언 불가능, 객체 역시 불가능함
		int a;
		final int fa = 100;

		public static void main(String[] args) {
				int b;
				final int fb = 200;
				class Inner {
			
						void innerMethod() {
								System.out.println(a); // static이 아니어서 접근이 불가능한 것도 있지만
								// 바깥쪽 클래스에 있는 멤버 변수여서 접근이 불가능함
								System.out.println(b); // 지역변수여도 접근이 불가능함
								System.out.println(fb); // final이 붙어있는 변수에만 접근이 가능함
								System.out.println(fa); // final이어도 클래스의 멤버 변수는 접근할 수 없음, 메소드 외부에 있으므로
								// 즉 메소드 내부에서만 객체를 생성해서 사용할 수 있음
								// 메소드내부에서도 지역변수도 final만이 접근 가능함
						}	

				}
				Inner inner = new Inner();
				inner.innerMethod();

			
		}

}
```
- 익명 중첩 클래스
	- 클래스로부터 객체 생성을 할 때 클래스 내부 코드를 바로 작성하는 것을 의미함
	- 원본 클래스가 가지고 있는 메소드를 Overriding해야 할 경우 상속받은 클래스를 만들지 않고 바로 Overriding을 할 수 있음
	- 추상 클래스라는 것을 이용할 때 자주 사용하는 기법임
### 실습
```Java
public class ReiterationClass4 {

		public static void main(String[] args) {
				Class200 c1 = new Class200();
				c1.disp();

				Class200 c2 = new Class200() {
						public void disp(){
								System.out.println("익명 중첩 클래스의 메소드");
						}
				};
				c2.disp(); // overriding하여서 c2 참조변수를 통해서 사용함, 즉 일회성임
				// 특정 클래스의 메소드를 계속해서 overriding할 경우 유용함
		}

}

class Class200{
		public void disp(){
				System.out.println("원본 클래스의 disp 메소드");
		}
}
```
### 중첩 클래스는 클래스를 만들고 다음번에 사용하지 않을때만 사용하는 것이 좋음, 클래스 내부에서 클래스 객체를 생성해서 그 때에만 사용한다고 할 경우 편하게 사용할 수 있음

# 43강
- 추상 메소드
	- 클래스를 작성 할 때 메소드를 구현하지 않고 선언만 해 놓은 메소드를 추상 메소드라고 부름
	- 추상 메소드는 구현되지 않은 메소드이므로 메소드를 구현을 해야지만 사용이 가능함
	- 추상 메소드는 접근 제한자와 리턴 타입 중간에 abstract라는 키워드를 붙혀줌
- 구현 된 메소드
	- public void method(){

	}
- 구현 되지 않은 메소드
	- public abstract void method();
- 추상 클래스
	- 추상 메소드를 하나라도 가진 클래스를 추상 클래스라고 부름
	- 추상 클래스는 구현되지 않은 메소드인 추상 메소드를 가지고 있기 때문에 직접 객체 생성할 수 없음
	- 추상 클래스의 기능을 사용하기 위해서는 반드시 추상 클래스를 상속받는 서브 클래스가 있어야함
	- 추상 클래스를 상속받은 서브 클래스는 추상 메소드를 반드시 구현해야함
	- 추상 클래스는 접근 제한자와 class 키워드 사이에 abstract를 붙혀줌
	- 추상 클래스를 사용하면 특정 메소드의 구현에 대한 강제성을 줄 수 있음
	- public abstract class ClassName{

	}
### 실습
```Java
public class AbstractTest {

		public static void main(String[] args) {
				Animal a = new Animal; // Animal이라는 추상 class이므로 객체 선언 할 수 없음
				
				Human h = new Human(); // Animal(부모 클래스) 추상 클래스를 상속받음
				// Human 자체는 그냥 클래스이므로 객체 생성해서 씀
				h.sayHi(); // 안녕하세요 출력함, 상속받은 부모클래스에서의 추상 메소드를
				// 오버라이딩해서 썼으므로 오버라이딩된 안녕하세요가 출력됨 

				Animal a = new Human();
				a.sayHi(); // 부모클래스에서도 역시 상속받은 클래스에서 메소드가 오버라이딩 되서
				// 안녕하세요가 출력됨
				
				// 중첩 클래스
				Animal a2 = new Animal() {
						
						@Override
						public void sayHi() {
								System.out.println("반갑습니다");
						}
				};  // 추상 클래스가 가지고 있는 메소드를 바로 사용함

				a2.sayHi(); // 그래서 이와같이 출력시 기존의 메소드를 오버라이딩한 반갑습니다 출력
				// 중첩 클래스 사용해서 일회성으로 사용하여 출력된 것임 바로 사용한 것이어서
		}

}

abstract class Animal{ // 추상 메소드를 정의하면 무조건 추상 class로 정의해야함
		public abstract void sayHi();
}

class Human extends Animal{ // abstract method를 상속 받아야 함
		
		@Override
		public void sayHi() {
				System.out.println("안녕하세요"); // 상속받아서 이용가능 
		}
}
```
### 어떠한 메소드 구현의 표준안 마련, 자바 가상머신이 호출해야되는 메소드를 개발자로 하여금 구현을 하게끔 제공을 할 때 가상머신이 알고 있는 이름으로 구현을 해야함 그러한 상황에서 개발자로 하여금 메소드 개발의 구현에 강제성을 부여할 때도 사용됨

# 44강
- 인터페이스
	- 인터페이스는 추상 메소드로만 구현되어 있는 것을 가르킴
	- 자바에서는 단일 상속만 지원을 하므로 추상 클래스를 하나 이상 상속 받을 수 없음
	- 자바에서는 인터페이스를 통해 반드시 구현해야 할 메소드를 동시에 여러 개를 구현할 수 있음
	- 인터페이스는 다중 상속을 지원하기 위해서 제공하는 것이 아니라 하나의 클래스를 여러 종류의 참조 변수를 통해 접근할 수 있고 메소드를 호출 할 수 있도록 지원되는 개념임
	- 인터페이스에 정의된 메소드는 모두 추상 메소드이며 변수는 static final 변수임
	- 메소드를 선언할 때 abstract 키워드를 붙히지 않아도 추상 메소드로 간주함
	- 변수에 static final을 붙히지 않아도 staic final로 간주함
- 인터페이스의 작성
	- interface 인터페이스이름{
				변수 선언...
				메소드 선언...

	}
- 인터페이스의 구현
	- class 클래스이름 extends 부모클래스 implements 인터페이스1, 인터페이스2{

	}
	- 클래스를 상속 받을 경우에만 extends쓰면 됨(위에 예시에서)
	- 구현한 인터페이스를 쉼표로 구분해서 다 적어주면 됨 
	- 인터페이스형 참조변수로 호출받고 사용함
### 실습
```Java
// main 클래스
public class InterfaceTest {

			public static void main(String[] args) {
					InterA a = new InterA(); // 객체를 생성할 때는 반드시 클래스로만 해야함
					// 인터페이스는 안됨

					TestClass t = new TestClass();

					t.methodA();
					t.methodB(); // 정상적으로 아래 Overide한 메소드가 호출됨

					System.out.println(t.a);
					System.out.println(t.b); // 정상적으로 사용할 인터페이스 안의 값이 출력됨

					t.a = 100;
					t.b = 200; // 컴파일 오류 발생됨 인터페이스에서 선언한 변수는 모두 static final이므로
					
					InterA ia = new TestClass();
					InterB ib = new TestClass(); // 인터페이스형 참조 변수 받음

					ia.methodA();  
					ib.methodB(); // 인터페이스형 참조 변수로 선언한 뒤 해당 메소드를 직접 호출함

					System.out.println(InterA.a); 
					System.out.println(InterB.b); // main이 static이므로 바로 접근 가능함
			}

}

class TestClass implements InterA, InterB{ // 인터페이스에 있는 추상메소드를 반드시 구현해야함 
		
		@Override
		public void methodA() {
				System.out.println("InterA의 메소드");
		}

		@Override
		public void methodB() {
				System.out.println("InterB의 메소드");
		}
}

class TestClass2 implements InterC{
		public void methodC() {

		}
		
		@Override
		public void methodA() { // InterC는 InterA를 상속받았으므로 InterA의 추상메소드도 구현해야함
	
		}
}
```
```Java
// 만들 때 new -> Interface로 만들면 됨 
// 사용할 인터페이스
public interface InterA {
		int a = 10;
		
		public void methodA(); // 선언만 해야함
}
```
```Java
// 사용할 인터페이스
public interface InterB {
		int b = 20;
		
		public void methodB(); 
}
```
```Java
// 사용할 인터페이스
public interface InterB {
		int b = 20;
		
		public void methodB(); 
}
```