## ArrayList
- ArrayList는 List 인터페이스를 상속받은 클래스로 크기가 가변적으로 변하는 선형리스트임
- 배열과 같은 순차리스트이지만 인덱스로 관리하는 점이 유사하지만 배열은 한 번 생성되면 크기가 변하지 않지만, ArrayList는 객체들이 추가되어 저장용량을 초과한다면 자동으로 부족한 크기만큼 저장 용량이 늘어남
<img src="https://user-images.githubusercontent.com/32586985/87738653-d403a380-c818-11ea-8c34-bf1add037a56.PNG">

- ArrayList 선언
- ArrayList를 사용할 시에는 ArrayList에 타입을 명시해주는 것이 좋음
- 예를 들어 ArrayList<String> list = new ArrayList<String>(): 선언 시 String 객체들만 add 될 수 있고 다른 타입의 객체는 사용이 불가능함
```Java
// 예시
ArrayList list = new ArrayList(); // 타입 미설정 Object로 선언됨
ArrayList<Student> members = new ArrayList<Student>(); // 타입설정 Student객체만 사용가능
ArrayList<Integer> num = new ArrayList<Integer>(); // 타입설정 int타입만 사용가능
ArrayList<Integer> num2 = new ArrayList<>(); // new에서 타입 파라미터 생략가능
ArrayList<Integer> num3 = new ArrayList<Integer>(10); // 초기 용량(capacity)지정
ArrayList<Integer> list2 = new ArrayList<Integer>(Arrays.asList(1,2,3)); // 생성시 값추가
```
- ArrayList 값 추가
- ArrayList의 add(index, value) 메소드를 사용하면 됨, index를 생략하면 ArrayList 맨 뒤에 데이터가 추가되며 index 중간에 값을 추가하면 해당 인덱스부터 마지막 인덱스까지 모두 1씩 뒤로 밀려남
<img src="https://user-images.githubusercontent.com/32586985/87738796-2775f180-c819-11ea-8503-e1f26bb4b996.PNG">

```Java
// 예시
ArrayList<Integer> list = new ArrayList<Integer>();
list.add(3); // 값 추가
list.add(null); // null값도 add가능
list.add(1,10); // index 1뒤에 10 삽입
```
```Java
// 예시
ArrayList<Student> list = new ArrayList<Student>();
Student student = new Student(name,age);
members.add(student);
members.add(new Member("홍길동", 15));
```
- ArrayList 값 삭제
- ArrayList에 값을 제거하려면 ArrayList의 remove(index)메소드를 사용하면 됨, remove()함수를 사용하여 특정 인덱스의 객체를 제거하면 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨짐, 모든 값을 제거하려면 clear() 메소드 사용하면 됨
```Java
// 예시
ArrayList<Integer> list = new ArrayList<Integer>(Arrays.asList(1,2,3));
list.remove(1); // index 1 제거
list.clear(); // 모든 값 제거
```
- ArrayList크기 구하기
- ArrayList의 크기를 구하기 위해서 ArrayList의 size() 메소드를 사용해야함
```Java
// 예시
ArrayList<Integer> list = new ArrayList<Integer>(Arraysa.asList(1,2,3));
System.out.println(list.size()); // list 크기 : 3
```
- ArrayList 값 출력
- ArrayList의 get(index)메소드를 사용하면 ArrayList의 원하는 index의 값이 리턴됨, for문이나 Iterator를 사용해서 전체출력을 할 수 있음
```Java
// 예시
ArrayList<Integer> list = new ArrayList<Integer>(Arrays.asList(1,2,3));

System.out.println(list.get(0)); // 0번째 index 출력

for(Integer i : list) { // for문을 통한 전체출력
		System.out.println(i);
}

Iterator iter = list.iterator(); // Iterator 선언
while(iter.hasNext()) { // 다음값이 있는지 체크
		System.out.println(iter.next()); // 값 출력
}
```
- ArrayList 값 검색
- ArrayList에서 찾고자 하는 값을 검색하려면 ArrayList의 contains(value)메소드를 사용하면 됨, 만약 값이 있다면 true가 리턴되고 값이 없다면 false가 리턴됨, 값이 있는 index를 찾으려면 indexOf(value)메소드를 사용하면 되고 만약 값이 없다면 -1을 리턴함
```Java
ArrayList<Integer> list = new ArrayList<Integer>(Arrays.asList(1,2,3));
System.out.println(list.contains(1)); // list에 1이 있는지 검색 : true
System.out.println(list.indexOf(1)); // 1이 있는 index 반환 없으면 -1
```

## for each문
- 기본적인 구조
	- for(type var : iterate) {
		body-of-loop
	}
	- iterate는 루프를 돌릴 객체이고, iterate 객체에서 한 개씩 순차적으로 var에 대입되어 for문이 수행됨, iterate 부분에 들어가는 타입은 루프를 돌릴 수 있는 형태인 배열 및 ArrayList등이 있음
- 배열이나 ArrayList에서 자주 사용함, 가변하는 복잡한 배열이나 리스트의 크기를 일일이 구할 필요가 없음
- 여러 컬렉션에 중첩되는 순환문을 만들 때는 더 쉽게 만들 수 있음
- 주의할 점은 오직 배열의 값을 가져다 사용할 수만 있고(read) 수정할 수 없다는 것(write)임
	- 필터링(filtering) - 컬렉션을 순회하다가 특정한 원소를 삭제할 필요가 있다면, 반복자를 명시적으로 사용해야함, 반복자의 remove 메소드를 호출해야 하기 때문임
	- 변환(transforming) - 리스트나 배열을 순회하다가 그 원소 가운데 일부 또는 전부의 값을 변경해야 한다면, 원소의 값을 수정하기 위해서 리스트 반복자나 배열 첨자가 필요함
	- 병렬 순회(parallel iteration) - 여러 컬렉션을 병렬적으로 순회해야하고, 모든 반복자나 첨자 변수가 발맞춰 나아가도록 구현해야 한다면 반복자나 첨자 변수를 명시적으로 제어할 필요가 있음
- 예시
```Java
// 일반적인 for문
String[] members = {"홍길동", "김길동", "최길동"};

for(int i = 0; i< members.length; i++) {
		String member = member[i];
		System.out.println(member + "상담을 받았습니다.");
}
```
```Java
// for-each문 사용
String[] members = {"최진혁", "최유빈", "한아람"};

for(String e : members) {
		System.out.println(e + "이 상담을 받았습니다");
}
```
- 일반적인 for문 이용시 members의 내용을 하나씩 꺼낸 후에 상담 결과를 화면에 출력하고 있음
- for-each문 사용시 members의 값을 변수 e에 담아서 중괄호 구간 안으로 전달해줌
- 훨씬 가독성이 높아지고 간결해졌으며 내용을 탐색시 더 간결하게 사용할 수 있음
- ArrayList에서 사용
```Java
// 일반적인 for문 사용시
ArrayList<String> number_list = new ArrayList<String>();
number_list.add("num_1");
number_list.add("num_2");
number_list.add("num_3");
number_list.add("num_4");
number_list.add("num_5");

System.out.print("[For Loop]         ");
int size = number_list.size();
for(int i=0; i<size; i++) {
		System.out.print(number_list.get(i) +" ");
}
```
```Java
// for-each문 사용
ArrayList<String> number_list = new ArrayList<String>();
number_list.add("num_1");
number_list.add("num_2");
number_list.add("num_3");
number_list.add("num_4");
number_list.add("num_5");

System.out.print("[For Loop]         ");
for(String s : number_list) {
		System.out.print(s + " ");
}
```
- 위의 코드 중 일반적인 for문의 경우는 List의 크기를 구해서 그 해당 크기만큼 출력을 함, 하지만 이같이 구현한다면 size를 구해서 정해진 값만큼 돌리기가 귀찮을 수 있음
- 이런 컬렉션이나 배열을 접근하기 위해서 for-each를 많이씀, 그러면 크기도 구하지 않고 형식을 적는 것만으로 모든 항목에 접근할 수 있음 

### 1.추상클래스와 인터페이스 차이
- 추상클래스 자체는 일단 클래스에 속하기 때문에 상속을 하는 것이고 인터페이스 자체는 상속이 아닌 하나의 클래스가 참조를 하여서 메소드를 호출할 수 있게 만드는 것이라 결 자체가 다름
- 추상 클래스 자체는 특정 메소드 구현에 대한 강제성을 즉 추상 클래스 사용시 반드시 추상 클래스와 추상 메소드를 사용해야 하는 강제성이 있기 때문에 업무상 그런 강제성이 필요로 할 때 쓰지만 인터페이스는 자바 자체가 단일 상속만을 지원하기 때문에 그러한 부분에 있어서 클래스에 인터페이스를 이용해 참조변수를 통해 접근하여 단일 상속에 단점을 보완하는 개념으로 쓰임

### 2.쓰레드를 왜 사용할까?
- 여태까지의 내 코딩 구력에 의하면 코드를 짜고 컴파일하는 아무리 코드가 길어도 문제풀이 방식이기 때문에 크게 무리없이 바로 컴파일하고 실행을 하였지만 만일 이게 실제 무언가 서비스를 직접 개발한다고 했을 경우 코드의 길이는 늘어날 것이며 파일도 많아질 것이 확실한데 이 경우 이런 작업을 한 번에 할 경우 시간이 굉장히 오래걸리고 또 에러가 생길수도 있음
- 이러한 부분에 있어서 쓰레드를 사용하게 된다면 여러개의 일을 하나에만 집중시키는 것이 아니라 분산시켜서 동시에 여러가지 일을 할 수 있게끔 할 수 있기 때문에 쓰레드를 사용한다
- 단 여기서 쓰레드를 무작정 많이 사용한다고 좋은 것이 아니다, 멀티 프로세싱 즉 동시에 여러개의 일을 하여서 일처리가 빨라져 보이는 것이지 성능은 동일하기 때문에 필요한 적재적소의 요소에 사용해서 일처리 능률을 올리는 용도로 사용해야한다

### 3.쓰레드 동기화는 왜 사용할까?
- 만일 쓰레드를 이용하는데 동일한 코드나 메소드를 사용하게 될 경우, 그것을 쓰는 쓰레드가 동시에 작업을 하게 되는데 이렇게 되면 오류가 발생할 수 있고 능률적인 부분에서 떨어질 수도 있음
- 이를 방지하기 위해서 동기화를 사용해서 쓰레드의 접근순서에 맞춰서 코드를 처리하게끔 하기위해서 동기화를 씀

### 4.접근제한자는 왜 사용할까?
- 접근제한자의 경우 public, protected, default, private등이 있는데 각각의 접근제한자마다 접근할 수 있는 영역이 다르고 제약조건이 다름
- 단순히 개념만을 생각하게 된다면 왜 다르게 사용하나 생각할 수 있지만 만일 실제 앱을 개발한다고 가정한다면 앱을 개발하는데 있어서 이 앱의 기능중에 사용자의 정보를 담거나 사용자의 정보를 불러오는 기능이 있을 경우 이것을 public으로 선언할 경우 큰 보안적인 문제가 발생할 수 있음
- 그리고 개발과정 자체에서 단일 파일로 만드는 것이 아니기 때문에 예를 들어 특정 기능만을 구현하고 다른 기능은 필요가 없고 이 기능을 고유하게 유지해야할 경우 혹은 이 기능을 쓰되 오버라이딩을 해서 수정을 하면 안될 경우 그때는 또 public이 아닌 private이나 protected제한자로 선언해서 둬야하는 경우도 있음
- 정리를 하자면 자바 특성상 참조, 상속, 오버라이딩으로 쉽게 클래스에 접근하고 수정을 할 수 있기 때문에 수정을 하면 안되거나 건드리면 안될 고유한 클래스에 대해서는 접근제한자를 이용해서 관리와 유지보수를 하기 위해서 사용함 