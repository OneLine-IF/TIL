# 35강
- 생성자
	- 생성자는 Java 클래스에서 객체를 생성할 때 자동으로 호출되는 메소드를 의미함
	- 생성자는 return type이 없으며 메소드의 이름은 클래스의 이름과 동일함
	- 생성자는 객체를 생성할 때 반드시 수행되야하는 코드가 있거나 초기화의 작업을 하는데 사용되어짐
- 사용 양식
	- public 클래스명(매개변수) {
		코드
	}
- default 생성자
	- 생성자를 클래스에 만들지 않으면 매개변수가 없는 생성자가 자동으로 만들어지며 내부에는 소스코드가 없음
	- 이렇게 매개변수가 없는 생성자를 default 생성자라고 부름
	- 생성자를 개발자가 직접 만들 경우 default 생성자는 자동으로 생성되지 않음
- 매개변수가 있는 생성자
	- 생성자는 매개 변수를 가질 수 있으며 매개 변수가 있는 생성자를 만들 경우 default 생성자가 생성되지 않음
	- 매개 변수의 형태를 다르게하여 여러개의 생성자를 생성할 수 있으며 객체를 생성할 때 선택할 수 있음
### 실습
```Java
public class ConstructorTest{


		public static void main(String[] args) {
					
				new ConstructorTest(); // 객체 생성 Default 생성자 출력됨
				new ConstructorTest(10); // 넘겨 받은 정수 값 : 10 출력됨
				new ConstructorTest(100, 200); // 두 수의 합 : 300 출력됨
		}


		// 매개변수가 없는 생성자 - default 생성자
		public ConstructorTest() {
				System.out.println("Default 생성자");
		}
		
		// 매개변수가 있는 생성자
		public ConstructorTest(int a) {
				System.out.println("넘겨 받은 정수 값: " + a);
		}
		
		// 매개변수가 있는 생성자
		public ConstructorTest(int a, int b) {
				System.out.println("두 수의 합 : " + (a + b));

		}
		
}
// 그냥 new ConstructorTest()만을 생성자 없이 만들 경우 자동으로 default 생성자가 추가됨
// 단 코드가 없음
```
- 클래스를 설계하고 클래스로부터 객체가 생성이 될 때 어떠한 특정 소스코드가 자동으로 이루어져야 하는 경우 사용함

# 36강
- 상속
	- 클래스를 만들 때 다른 클래스가 가지고 있는 메소드 혹은 변수를 가져와서 사용하는 방법 중에 하나임 
	- 참조와는 달리 메소드와 변수를 물려받아 자기 자신것처럼 사용하는 개념임
	- 기존에 만든 클래스에 새로운 기능을 추가하거나 이미 만들어진 메소드를 다시 구현할 경우 사용함
	- 기존에 만들어진 클래스를 직접 손대지 않고 추가 혹은 수정을 가할 수 있으므로 객체 지향 프로그래밍에서는 굉장히 많이 사용하는 기법임
	- 자바에서는 다중 상속을 지원하지 않으며 단일 상속만을 지원함
	- 자바에서는 상속을 받기 위한 코드르 작성하지 않으면(개발자가 직접 상속시킨 클래스가 없다면) Object라는 클래스를 자동으로 상속 받게됨
- 부모와 자식
	- 객체 지향 언어에서는 물려주는 쪽을 부모클래스(Super Class)라고 부르며 물려 받는 쪽을 자식 클래스(Sub Class)라고 부름
- extends
	- 클래스를 만들 때 특정 클래스를 상속 받기 위해서는 다음과 같이 함
	- class 클래스이름 extends 부모클래스
### 실습
```Java
// main 클래스
public class InheritanceTest {

	public static void main(String[] args) {
			
			Class1 c1 = new Class1();
			c1.v1 = 100;
			c1.method1(); // Class1의 변수 v1 : 100 출력함
			
			// Class2의 변수와 메소드를 상속 받았으므로 Class1을 통해서 이용가능함
			c1.v2 = 200;
			c1.method2(); 

			c1.method3(); // Class1에 있는 method3을 사용함
	}
}
```
```Java
// 상속을 테스트할 클래스
public class Class1 extends Class2{ // extends를 이용 Class1은 Class2를 상속받음
// Class2의 있는 변수와 메소드가 Class1의 일부로 동작함
		int v1;
	
		public void method1() {
				System.out.println("Class1의 변수 v1 : " + v1);
		}
		
		public void method3() { // 상속 받았으므로 Class2가 가지고 있는 요소 직접 사용함
				v2 = 1000;
				method2();
		}
}
```
```Java
// 상속을 테스트할 클래스
public class Class2 {

		int v2;
	
		public void method2() {
				System.out.println("Class2의 변수 v2 : " + v2);
		}

}
```
- 클래스를 만들 때 특정 클래스의 메소드와 변수를 물려 받는 걸 상속이라고 부름

# 37강
- 참조변수를 통한 객체 접근
	- 클래스로부터 객체를 생성하고 생성된 객체의 주소값을 참조 변수에 넣어 줄 때 참조 변수의 타입에 따라 생성된 객체에 접근 할 수 있는 영역은 달라짐
<img src="https://user-images.githubusercontent.com/32586985/86866228-7d58e400-c10b-11ea-817d-7d656077c8fa.PNG">

### 실습
```Java
// main 클래스
public class PolyTest{

		public static void main(String[] args) {
				
			Class c1 = new Class1(); // 외부 클래스 사용하기 위해 객체 생성해서 사용

			c1.superV1 = 100;
			c1.superMethod();
			
			c1.class1V1 = 300;
			c1.class1Method(); // c1에 있는 것이므로 당연히 실행됨 
			
			SuperClass super1 = new Class1(); // 참조변수 활용 SuperClass 사용해서 만듬 객체는 Class1
			super1.superV1 = 200;
			super1.superMethod(); // Class1이 상속받았으므로 SuperClass 사용가능함

			/* super1.classV1 = 400; 
			super1.class1Method();
			// 객체 생성시 사용한 class는 Class1이지만 해당 객체의 주소값을 담고 있는 참조변수가
			// 부모클래스형 SuperClass이므로 접근할 수 없으므로 위의 두 코드는 에러가 뜸
			// 즉 SuperClass의 내용만을 접근할 수 있고 아래에 있는 Class1의 메소드는 사용불가
			*/
		}

}
```
```Java
// 다양성 테스트 할 클래스
public class SuperClass{
		
		int superV1;

		public void superMethod(){
				System.out.println("SuperClass의 메소드 - superV1 : " + superV1);
		}

}
```
```Java
// 다양성 테스트 할 클래스
public class Class1 extends SuperClass{ // SuperClass 상속받음
		int class1V1;

		public void class1Method(){
				System.out.println("Class1의 메소드 - classc1 : " + class1V1);
		}
		
}
```

- Overriding
	- 부모 클래스가 가지고 있는 메소드를 자식 클래스에서 다시 구현한 것을 가르킴
	- 메소드를 Overriding을 하고 부모 클래스의 메소드를 호출하고자 할 때는 super를 이용함
### 실습
```Java
// main 클래스
public class PolyTest{

		public static void main(String[] args) {
				
			Class c1 = new Class1(); // 외부 클래스 사용하기 위해 객체 생성해서 사용

			c1.superV1 = 100;
			c1.superMethod();
			
			c1.class1V1 = 300;
			c1.class1Method(); // c1에 있는 것이므로 당연히 실행됨 

			c1.superMethod2(); // c1에 있으므로 실행가능함, Overriding한 경우 그 형태로 출력됨
			
			SuperClass super1 = new Class1(); // 참조변수 활용 SuperClass 사용해서 만듬 객체는 Class1
			super1.superV1 = 200;
			super1.superMethod(); // Class1이 상속받았으므로 SuperClass 사용가능함

			/* super1.classV1 = 400; 
			super1.class1Method();
			// 객체 생성시 사용한 class는 Class1이지만 해당 객체의 주소값을 담고 있는 참조변수가
			// 부모클래스형 SuperClass이므로 접근할 수 없으므로 위의 두 코드는 에러가 뜸
			// 즉 SuperClass의 내용만을 접근할 수 있고 아래에 있는 Class1의 메소드는 사용불가
			*/
			
			super1.superMethod2(); // 아래에서 자식클래스에서 Overriding한 메소드가 출력됨
			// 원래 부모 클래스가 가지고 있는 메소드를 Overriding한 경우 Overring한 메소드가 출력됨
		}

}
```
```Java
// 다양성 테스트 할 클래스
public class SuperClass{
		
		int superV1;
		
		public SuperClass(){
				System.out.println("부모클래스의 생성자"); // 생성자가 출력이 됨, 클래스에서 생성됐으므로
		} // main 클래스 실행시 부모클래스의 생성자가 먼저 출력됨
		
		public SuperClass(int a){
				System.out.println("부모클래스의 생성자2 : a - " + a);
		}
		
		public void superMethod(){
				System.out.println("SuperClass의 메소드 - superV1 : " + superV1);
		}
		
		public void superMethod2(){
				System.out.println("SuperClass의 메소드2");
		}
}
```
```Java
// 다양성 테스트 할 클래스
public class Class1 extends SuperClass{ // SuperClass 상속받음
		int class1V1;
		
		public Class1() {
				super(100); // 부모클래스의 생성자를 선택해서 호출함
				// 위와 같이 쓰면 자식클래스에 생성자에서 부모클래스의 생성자를 호출하여
				// 부모클래스에 있는 부모클래스의 생성자2가 호출되서 출력됨
				// 이렇게 쓰면 부모클래스의 생성자가 아닌 부모클래스의 생성자2가 호출됨
				// 선택하고 싶을 때 생성자를 통해 선택하여 호출해 줄 수 있음
				System.out.println("자식클래스의 생성자");
		}
		public void class1Method(){
				System.out.println("Class1의 메소드 - classc1 : " + class1V1);
		}
		
		@Override
		public void superMethod2() { // 자식 클래스에서 Overriding 했으므로 main에서 출력시
		// 아래와 같이 출력됨
				System.out.println("자식 클래스에서 Overriding한 메소드");
				super.superMethod2(); // super를 사용하면 부모 class에서의 SuperClass의 메소드2
															// 가 호출, 출력됨
		}
}
```
	- 참조 변수의 활용
		- 부모 클래스형 참조 변수를 통해 객체에 접근하면 부모 클래스의 영역에 접근을 하지만 호출하려는 메소드가 Overriding된 경우에는 자식 클래스에 재정의한 메소드가 호출이 됨
		<img src="https://user-images.githubusercontent.com/32586985/86866429-f0faf100-c10b-11ea-8120-4a5354af694e.PNG">>

# 38강
- 접근 제한자
	- 프로그램을 제작하다보면 클래스에 선언한 변수나 메소드를 접근하지 못하도록 막아야 할 경우가 있음
	- 이러한 접근의 제한을 두기 위해 제공하는 것이 접근 제한자이며 상황에 맞는 접근 제한자를 사용하면 됨 
	- 접근 제한자는 클래스의 정보 보호를 위한 캡슐화의 개념에 적용되므로 아주 중요함
	- 클래스 : public, default
	- 생성자 : public, protected, default, private
	- 멤버 변수 : public, protected, default, private
	- 멤버 메소드 : public, protected, default, private
	- default는 아무것도 적지 않는 것을 의미
	- 지역 변수 : 접근 제한자 불가, 메소드 내부에서만 사용하므로
- 클래스의 접근 제한자
	- 지정하는 파일의 파일명을 결정하는데 사용함
	- 하나의 자바 파일에 여러 개의 클래스를 만들 경우 파일명으로 사용하는 이름은 public이 있는 클래스 이름이며 public은 오로지 하나의 클래스에만 붙힐 수 있음
### 실습
```Java
public class AccessableTest {

}

class Class1 { // public을 쓰면 오류가 발생함, public이 없을 경우 파일이름은 상관이 없음

}
```

- public 접근 제한자
	- public은 아무 제약없이 자유롭게 접근이 가능한 접근 제한자임
	<img src="https://user-images.githubusercontent.com/32586985/86866720-78e0fb00-c10c-11ea-862e-9435b14d50ae.PNG">

### 실습
```Java
import com.test.BClass;
// main 클래스
public class AccessableTest {
		public static void main(String [] args) {
				new Class1();
				new Class2();
				new Class3();
				new Class4();
				// 객체 생성
		}
}
// 같은 패키지의 클래스를 객체생성해서 참조할 경우
class Class1 { 
		public Class1() { // 생성자 생성
				AClass a = new AClass();
				
				a.publicValue = 10;
				a.publicMethod(); 
				// 만일 빨간줄이 뜬다면 접근이 불가능한 것을 의미함
		}
}
// 같은 패키지의 클래스를 상속받아서 사용할 경우
class Class2 extends AClass {
		public Class2() { // 생성자 생성
				publicValue = 10;
				publicMethod();
		}
}
//다른 패키지의 클래스를 객체 생성해서 참조할 경우
class Class3 {
		public Class3() { // 생성자 생성
				BClass b = new BClass();

				b.publicValue2 = 10;
				b.publicMethod2();
		}
}
// 다른 패키지의 클래스를 상속받아서 사용할 경우
class Class4 extends BClass {
		public Class4() { // 생성자 생성
			 publicValue2 = 10;
			 publicMethod2();
		}
}
// 오류가 뜨지 않음 즉, public을 이용 접근이 자유롭게 가능함
```
```Java
// 테스트를 위한 클래스
public class AClass {
		public int publicValue;
		
		public void publicMethod() {
			System.out.println("public 메소드");
		}
}
```
```Java
package com.test;

public class BClass {
		public int publicValue2;

		public void publicMethod2() {
			System.out.println("public 메소드");
		}
}
```

- protected 접근 제한자
	- protected는 패키지가 다르고 참조할 경우에만 접근이 불가능함
	- 패키지가 같은 경우에는 얼마든지 접근이 가능하지만 패키지가 다를 경우 상속에 의해서만 접근이 가능함
	<img src="https://user-images.githubusercontent.com/32586985/86866834-ab8af380-c10c-11ea-8ea2-3664706a0925.PNG">

### 실습
```Java
import com.test.BClass;
// main 클래스
public class AccessableTest {
		public static void main(String [] args) {
				new Class1();
				new Class2();
				new Class3();
				new Class4();
				// 객체 생성
		}
}
// 같은 패키지의 클래스를 객체생성해서 참조할 경우
class Class1 { 
		public Class1() { // 생성자 생성
				AClass a = new AClass();
				
				a.publicValue = 10;
				a.publicMethod(); 
				// 만일 빨간줄이 뜬다면 접근이 불가능한 것을 의미함

				a.protectedValue = 20;
				a.protectedMethod(); // 사용가능함
		}
}
// 같은 패키지의 클래스를 상속받아서 사용할 경우
class Class2 extends AClass {
		public Class2() { // 생성자 생성
				publicValue = 10;
				publicMethod();
				
				protectedValue = 20;
				protectedMethod(); // 사용가능함
		}
}
//다른 패키지의 클래스를 객체 생성해서 참조할 경우
class Class3 {
		public Class3() { // 생성자 생성
				BClass b = new BClass();

				b.publicValue2 = 10;
				b.publicMethod2();

				b.protectedValue2 = 20;
				b.protectedMethod2(); // 상속 받지 않았으므로 클래스에서 사용 불가능함
				// 패키지가 다르므로
		}
}
// 다른 패키지의 클래스를 상속받아서 사용할 경우
class Class4 extends BClass {
		public Class4() { // 생성자 생성
			 publicValue2 = 10;
			 publicMethod2();

			 protectedValue2 = 20;
			 protectedMethod2();
		}
}
// 오류가 뜨지 않음 즉, public을 이용 접근이 자유롭게 가능함
```
```Java
// 테스트를 위한 클래스
public class AClass {
		public int publicValue;
		protected int protectedValue;	
	
		public void publicMethod() {
			System.out.println("public 메소드");
		}
		protected void protectedMethod() {
			System.out.println("protected 메소드");
		}
}
```
```Java
package com.test;

public class BClass {
		public int publicValue2;
		protected int protectedValue2;	
	
		public void publicMethod2() {
			System.out.println("public 메소드");
		}
		protected void protectedMethod2() {
			System.out.println("protected 메소드");
		}
}
```

- default 접근 제한자
	- default는 패키지가 다르면 상속이나 참조를 통해 접근이 불가능함
	<img src="https://user-images.githubusercontent.com/32586985/86866912-d7a67480-c10c-11ea-8016-896a37c54650.PNG">

### 실습
```Java
import com.test.BClass;
// main 클래스
public class AccessableTest {
		public static void main(String [] args) {
				new Class1();
				new Class2();
				new Class3();
				new Class4();
				// 객체 생성
		}
}
// 같은 패키지의 클래스를 객체생성해서 참조할 경우
class Class1 { 
		public Class1() { // 생성자 생성
				AClass a = new AClass();
				
				a.publicValue = 10;
				a.publicMethod(); 
				// 만일 빨간줄이 뜬다면 접근이 불가능한 것을 의미함

				a.protectedValue = 20;
				a.protectedMethod(); // 접근가능함

				a.defaultValue = 30;
				a.defaultMethod(); // 접근가능함
		}
}
// 같은 패키지의 클래스를 상속받아서 사용할 경우
class Class2 extends AClass {
		public Class2() { // 생성자 생성
				publicValue = 10;
				publicMethod();
				
				protectedValue = 20;
				protectedMethod(); // 접근가능함

				defalutValue = 30;
				defaultMethod(); // 접근가능함
		}
}
//다른 패키지의 클래스를 객체 생성해서 참조할 경우
class Class3 {
		public Class3() { // 생성자 생성
				BClass b = new BClass();

				b.publicValue2 = 10;
				b.publicMethod2();

				b.protectedValue2 = 20;
				b.protectedMethod2(); // 상속 받지 않았으므로 클래스에서 접근 불가능함
				// 패키지가 다르므로
				
				b.defalutValue = 30;
				b.defaultMethod(); // 접근 불가능함
		}
}
// 다른 패키지의 클래스를 상속받아서 사용할 경우
class Class4 extends BClass {
		public Class4() { // 생성자 생성
			 publicValue2 = 10;
			 publicMethod2();

			 protectedValue2 = 20;
			 protectedMethod2();
			
			 defalutValue = 30;
			 defaultMethod(); // 접근 불가능함, 패키지가 다른 경우 상속이던 아니더 다 접근 불가함
		}
}
// 오류가 뜨지 않음 즉, public을 이용 접근이 자유롭게 가능함
```
```Java
// 테스트를 위한 클래스
public class AClass {
		public int publicValue;
		protected int protectedValue;	
		int defaultValue;
		
		public void publicMethod() {
			System.out.println("public 메소드");
		}
		protected void protectedMethod() {
			System.out.println("protected 메소드");
		}
		void defaultMethod() {
			System.out.println("default 메소드");
		}
}
```
```Java
package com.test;

public class BClass {
		public int publicValue2;
		protected int protectedValue2;	
		int defaultValue2;

		public void publicMethod2() {
			System.out.println("public 메소드");
		}
		protected void protectedMethod2() {
			System.out.println("protected 메소드");
		}
		void defaultMethod2() {
			System.out.println("default 메소드");
		}
}
```

- private 접근 제한자
	- private는 어떠한 상황에서든지 모두 접근이 불가능함
	<img src="https://user-images.githubusercontent.com/32586985/86867013-0290c880-c10d-11ea-8897-b076608a6ba1.PNG">

### 실습
```Java
import com.test.BClass;
// main 클래스
public class AccessableTest {
		public static void main(String [] args) {
				new Class1();
				new Class2();
				new Class3();
				new Class4();
				// 객체 생성
		}
}
// 같은 패키지의 클래스를 객체생성해서 참조할 경우
class Class1 { 
		public Class1() { // 생성자 생성
				AClass a = new AClass();
				
				a.publicValue = 10;
				a.publicMethod(); 
				// 만일 빨간줄이 뜬다면 접근이 불가능한 것을 의미함

				a.protectedValue = 20;
				a.protectedMethod(); // 접근가능함

				a.defaultValue = 30;
				a.defaultMethod(); // 접근가능함

				a.privateValue = 40;
				a.privateMethod(); // 접근 불가능함
		}
}
// 같은 패키지의 클래스를 상속받아서 사용할 경우
class Class2 extends AClass {
		public Class2() { // 생성자 생성
				publicValue = 10;
				publicMethod();
				
				protectedValue = 20;
				protectedMethod(); // 접근가능함

				defalutValue = 30;
				defaultMethod(); // 접근가능함

				privateValue = 40;
				privateMethod(); // 접근불가능함
		}
}
//다른 패키지의 클래스를 객체 생성해서 참조할 경우
class Class3 {
		public Class3() { // 생성자 생성
				BClass b = new BClass();

				b.publicValue2 = 10;
				b.publicMethod2();

				b.protectedValue2 = 20;
				b.protectedMethod2(); // 상속 받지 않았으므로 클래스에서 접근 불가능함
				// 패키지가 다르므로
				
				b.defalutValue = 30;
				b.defaultMethod(); // 접근 불가능함
			
				b.privateValue2 = 40;
				b.privateMethod2(); // 접근 불가능함
		}
}
// 다른 패키지의 클래스를 상속받아서 사용할 경우
class Class4 extends BClass {
		public Class4() { // 생성자 생성
			 publicValue2 = 10;
			 publicMethod2();

			 protectedValue2 = 20;
			 protectedMethod2();
			
			 defalutValue = 30;
			 defaultMethod(); // 접근 불가능함, 패키지가 다른 경우 상속이던 아니더 다 접근 불가함
				
			 privateValue = 40;
			 privateMethod(); // 접근 불가능함, private는 전부 다 접근이 불가능함
		}
}
// 오류가 뜨지 않음 즉, public을 이용 접근이 자유롭게 가능함
```
```Java
// 테스트를 위한 클래스
public class AClass {
		public int publicValue;
		protected int protectedValue;	
		int defaultValue;
		private int privateValue;

		public void publicMethod() {
			System.out.println("public 메소드");
		}
		protected void protectedMethod() {
			System.out.println("protected 메소드");
		}
		void defaultMethod() {
			System.out.println("default 메소드");
		}
		private void privateMethod() {
			System.out.println("private 메소드");
		}
}
```
```Java
package com.test;

public class BClass {
		public int publicValue2;
		protected int protectedValue2;	
		int defaultValue2;
		private int privateValue2;

		public void publicMethod2() {
			System.out.println("public 메소드");
		}
		protected void protectedMethod2() {
			System.out.println("protected 메소드");
		}
		void defaultMethod2() {
			System.out.println("default 메소드");
		}
		private void privateMethod2() {
			System.out.println("private 메소드");
		}
}
```

# 39강
- 캡슐화
	- 클래스에 선언한 변수의 접근 제한자를 private로 주고 접근을 못하게 차단한 후 접근을 가능하게 허용하는 변수만 메소드를 통해 접근하도록 하는 방법을 캡슐화라고 함
	- 캡슐화를 이용하면 변수의 직접 접근이 불가능하여 정보 보호를 할 수 있으며 메소드를 통해 접근을 해야 하기 때문에 접근에 제한을 줄 수 있음
- 접근을 위한 메소드
	- Setter : 멤버 변수에 값을 넣기 위해 제공하는 메소드
	- Getter : 멤버 변수의 값을 주기 위해 제공하는 메소드
### 실습
```Java
public class EnCapsulation {

		public static void maint(String[] args) {
				Class1 c = new Class1();
				
				c.a = 200
				System.out.println(c.a); // default일 때는 같은 패키지니깐 사용가능
			
				c.setB(300); // b의 매개변수를 통해서 this.b에 300을 대입함
				System.out.println(c.getB());	// 300을 대입받고 그 값을 return하여서 300이 출력됨
		}   // 특정 변수의 값을 가져오는 건 가능하고 대입을 하지 않게 하기 위해서는 Setter를
				// 쓰지 않으면 됨

}
```
```Java
public class Class1 {
		int a = 100;
		private int b = 200; // 접근이 불가능함 private이므로

		// Setter
		public void setB(int b) {
				this.b = b; // this.b로 Class1의 멤버 변수인 private b에 접근을 함 
		}
		// Getter
		public int getB() {
				return this.b; // this.b를 return 받으므로 값을 가져올 수 있음, private b에 접근을함
		}
}
```
- 만일 private 변수가 무수히 많을 경우 자동으로 만들게 할 수 있음, 2번째 사진과 같이 자동으로 Setter, Getter를 만들 수 있음
<img src="https://user-images.githubusercontent.com/32586985/86867262-7cc14d00-c10d-11ea-8f3f-77690b7e3a65.PNG">
<img src="https://user-images.githubusercontent.com/32586985/86867273-8054d400-c10d-11ea-9e4f-6c8184faabb5.PNG">

- 변수의 접근 제한자를 private로 주고 메소드를 public으로 줌