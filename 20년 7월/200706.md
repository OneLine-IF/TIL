# 27강
- 절차 지향 프로그래밍
	- 프로그램을 개발할 때 프로그램이 동작하는 순서대로 프로그래밍을 하는 기법
	- 프로그램이 수행되고 종료될 때까지의 모든 기능이 작업 순서대로 기술되어짐
	- 유지 보수가 어렵고 프로그램을 각 기능별로 구분하여 작성하기가 힘듬
	- 코드의 재사용이 어려움
	- 프로그램에서 사용하는 모든 기능들을 작업 순서대로 작성하여 프로그램을 만드는 기법
- OOP
	- Object Oriented Programming 
	- 프로그램을 작성할 때 먼저 프로그램에서 사용할 기능들을 정리하고 정리한 기능을 가지고 있는 작은 부품들을 만들어서 프로그램에서는 이렇게 만든 부품들을 사용하여 프로그램을 작성하는 기법
	- 프로그램에서 사용되어지는 작은 부품들을 객체라고 부르며 이러한 객체들을 만들 수 있는 것을 클래스라고 부름
	- 개발자는 프로그램 코드를 통해 클래스를 만들고 클래스를 통해 객체를 생성하여 사용을 함
	- 프로그램의 기능들이 작은 부품 단위인 클래스로 나눠져 있어 유지보수가 용이함
	- 코드의 재사용성이 높아져 새로운 프로젝트를 만들 때 상당한 시간과 비용을 절약할 수 있음
- 참고
<img src="https://user-images.githubusercontent.com/32586985/86551973-92a20700-bf81-11ea-949a-290ba813fa0b.PNG">
<img src="https://user-images.githubusercontent.com/32586985/86551978-96ce2480-bf81-11ea-8889-0d313f60f311.PNG">\

- 클래스 설계 방법
	- 내가 필요한 기능이 무엇인가?
	- 필요한 기능들을 단위별로 구분을 할 수 있는가?
	- 클래스간의 종속성을 최소한으로 하였는가?
	- 이미 존재하는 클래스와 중복되는 부분이 있는가?
	- 사용하기 쉽게 만들었는가?
	- 꼭 필요한 기능만을 가진 클래스인가?

# 28강
- 클래스에 대한 문법
	- 클래스는 다음과 같이 작성
		- class 클래스이름
	- { }와 사이에 클래스의 내용을 작성함
		- 클래스는 멤버 변수와 멤버 메소드의 구성요소를 가짐
- 객체의 생성 및 접근
	- 클래스로부터 객체를 생성하기 위해서는 다음과 같이 작성
		- new 클래스이름();
	- new를 통해 객체를 생성하면 생성된 객체의 메모리의 주소값을 넘겨줌, 이 주소값을 변수에 받아두었다가 그 이후에 사용할 때 이 주소값을 이용하여 접근하면 됨, 이 주소값을 담는 변수를 가르켜 참조변수라고 부름
	- 참조 변수를 통해 멤버에 접근할 때는 "참조변수.멤버"라고 기술하여 사용함
```Java
// 기존의 파일을 만들 때 메인 클래스를 만들고 NEW -> 새로운 클래스 만듬
// Class1의 클래스
public class Class1 {
		// 멤버 변수
		int va;
		// 멤버 메소드
		public void setVa(int _va){
				va = _va;
		}
		public int getVa(){
				return va;
		}
// 클래스 생성시 첫 글자를 대문자로 하는 것이 좋음
```
```Java
// main 클래스
public static void main(String[] args) {
			// 객체 생성
			Class1 c1 = new Class1(); // 객체가 생성됨
			// 멤버의 접근
			c1.va = 100;
			System.out.println(c1.va); // 위의 Class1에 있는 va에 직접 접근함
			
			c1.setVa(1000); // Class1에 있는 메소드에 접근
			System.out.println(c1.getVa()); // 메소드의 접근해서 1000값 할당한 것은 getVa를 통해 받음

			
			Class1 c2 = new Class1(); // 또다른 객체 생성함, c1과 별도로 돌아감 
			c2.va=200;
			System.out.println(c2.va);

			c2.setVa(2000);
			System.out.println(c2.getVa());
}
// Class1 클래스 자체에 접근하는 것이 아니라 이를 통해서 객체가 생성되는데
// 생성된 객체에 접근하는 것이고 .연산자로 접근함
```

# 29강
- 멤버 메소드 
	- 클래스 내에서 개발자가 만드는 소스 코드의 단위를 나타냄
	- 클래스가 가지고 있는 기능들을 정의할 때 사용하며 개발자는 프로그래밍을 할 때 작성되는 소스 코드는 메소드 내부에 작성을 해야함
	- 메소드는 클래스에서의 작업의 단위임
- 메소드 작성 문법
	- 메소드는 다음과 같은 구조를 가짐
	- [접근 제한자][리턴 타입]메소드이름([매개 변수]){
			소스코드
	}
	- 접근 제한자:같은 클래스 내부가 아닌 외부에서 접근하고자 할 때 제한을 두는 부분임
	- 리턴 타입:메소드의 코드를 수행 후 메소드를 사용한 부분에 값을 전달 할 때 전달되는 값의 타입을 적어줌, 전달할 값이 없다면 void라고 작성함
	- 매개 변수:메소드를 사용하는 부분에서 이 메소드에 값을 전달 해주고자 할 때 매개 변수를 통해 값을 사용할 수 있음, 메소드를 사용하는 곳에서 값을 전달 해주면 매개 변수에 값이 셋팅이되어지고 메소드 내부에서는 매개 변수를 통해 받은 값을 사용할 수 있음
```Java
// 새로운 클래스
public class Class1 {
		public void method1(){
				System.out.println("메소드 1번 입니다");
				method2(); // 같은 클래스에 있는 메소드는 자유롭게 사용할 수 있음
									// 이렇게 쓰면 main에서 실행시 출력문이 2개가 출력이 됨 
		}
		public void method2(){
				System.out.println("메소드 2번 입니다");
		}
		
		public void add(int a, int b){ // 메소드를 호출 시 던져주는 값이 1대1 대응됨 
				int result = a + b;
				System.out.println("정수 연산 : a + b = " + result);
		}

		public int resultAdd(int a, int b){ // 되돌려줄 값의 타입을 적고 return문 사용
																				// 되돌려줄 값 없으면 void로
				int result = a + b;
				return result;
		}
}
```
```Java
// main 클래스
public static void main(String[] args){
		
		Class1 c1 = new Class1(); // 클래스 사용하기 위해 객체 생성
		
		c1.method1(); // 다른 클래스에 method1을 호출함

		c1.add(100, 200); // add메소드 호출시 100과 200을 던져줌 100은 a변수 200은 b변수에 들어감
											// 변수타입에 맞춰서 받아야함

		int result  = c1.resultAdd(500,600); // 500,600을 받고 그 결과값을 리턴해줌
																				// 리턴 받은 값이 받아짐
		System.out.println("리턴 받은 값 : " + result); // 리턴 받은 값: 1100
}
```
- Overloading
	- 클래스 내부의 모든 메소드들은 그 이름이 모두 달라야함
	- 객체 지향 프로그램이 언어에서는 개발자가 메소드 사용을 좀 더 편하게 할 수 있도록 같은 이름으로 여러 개의 메소드를 만들어 사용하는 것을 지원함
	- 원래 메소드와 메소드의 구분은 메소드의 이름을 가지고 하지만 메소드의 이름이 같을 경우 내부의 매개변수를 가지고 구분을 하게 됨 즉, 이름은 같지만 매개변수의 형태가 다를 경우 다른 메소드로 취급 받음
	- 이러한 개념을 메소드의 Overloading이라고 부름
```Java
public class Class1 {
		public void method1(){
				System.out.println("메소드 1번 입니다");
				method2(); // 같은 클래스에 있는 메소드는 자유롭게 사용할 수 있음
									// 이렇게 쓰면 main에서 실행시 출력문이 2개가 출력이 됨 
		}
		public void method2(){
				System.out.println("메소드 2번 입니다");
		}
		
		public void add(int a, int b){ // 메소드를 호출 시 던져주는 값이 1대1 대응됨 
				int result = a + b;
				System.out.println("정수 연산 : a + b = " + result);
		}
		public void add(int a, int b, int c) { // overloading 매개변수가 다르므로 
																					// 같은 메소드명이어도 다르게 인식함
				int result = a + b + c;
				System.out.println("정수 3개 연산 : a + b + c = " + result); 
				// 매개변수 타입이 다르므로 위에 add와 같이 쓰더라도 다르게 출력하고 인식됨
		}

		public int resultAdd(int a, int b){ // 되돌려줄 값의 타입을 적고 return문 사용
																				// 되돌려줄 값 없으면 void로
				int result = a + b;
				return result;
		}
}
```

# 30강
- 멤버 변수
	- 클래스에서 선언되어 같은 클래스 내부라면 자유롭게 접근하여 사용할 수 있는 변수
	- 중복된 이름으로 선언될 수 없음
	- 다른 클래스에서 접근하기 위해서는 "." 연산자를 이용함
- 지역 변수
	- 메소드 내부에서 선언된 변수를 가르키며 지역변수는 선언된 메소드 내부에서만 사용이 가능함
	- 클래스의 멤버 변수와 지역 변수의 이름이 동일한 경우 지역 변수가 우선이 되며 클래스의 멤버 변수를 접근하기 위해서는 this를 이용함
```Java
// 새로운 클래스
public class Class1 {
			int a; // 클래스의 멤버 변수

			public void method1() {
					int a = 20; // 출력 시 20이 출력됨 멤버 변수와 지역변수의 이름이 같을 경우
// 지역변수를 우선으로 처리함 
					System.out.println("메서드의 지역 변수 a : " + a); 
					System.out.println("클래스의 멤버 변수 a : " + this.a); 
// 같은 클래스 내부는 자유롭게 접근 가능
// this를 사용하여 지역 변수가 있을 경우 클래스의 멤버 변수를 사용함
// 자기자신을 가르키는 키워드 자기 자신을 즉 멤버 변수를 참조함
			}

			public void method2() {
					int a = 30; // 메소드가 다를경우 method1의 a와 서로 다른 변수로 취급함
					System.out.println("메소드 2의 지역 변수 a : " + a);
			}
}
```
```Java
// main 클래스
public static void main(String[] args) {
		Class1 c1 = new Class1();
		
		c1.a = 100; // c1 객체에 있는 a라는 변수에 100 대입
		System.out.println("c1.a = " + c1.a);
		
		c1.method1(); // 클래스의 멤버 변수 a : 100 위의 100이 대입되어 있으므로
									// 첫번째는 20 두번째는 100으로 출력
		c1.method2(); // 30 출력
}
```
### 정리
- 같은 클래스 내부라면 어디서든지 자유롭게 접근이 가능한 변수를 클래스의 멤버 변수라고 함
- 메소드 내부에 선언되어 메소드 내부에서만 쓸 수 있는 변수를 지역 변수라고 부름
- 클래스의 멤버 변수를 다른 클래스에서 접근할 경우에는 "." 연산자를 이용함 
- 클래스의 멤버 변수와 지역 변수의 이름이 같은 경우 지역 변수가 우선이 되며 클래스의 멤버 변수에 접근하고자 할 때는 this를 이용함

# 31강
- 패키지의 정의
	- 자바 프로그램을 작성할 때 소스 코드 파일이 너무 많으면 관리하기가 힘들어짐
	- 패키지는 많은 소스코드들을 개발자 나름대로의 기준을 삼아 나눠서 관리하는 방법
	- 자바에서는 패키지를 폴더 단위로 구분함
	- 같은 패키지에 있는 클래스는 자유롭게 사용할 수 있으며 패키지가 다른 클래스의 경우 패키지를 import를 통해 소스에 포함시켜주면 사용할 수 있음
	<img src="https://user-images.githubusercontent.com/32586985/86552644-933b9d00-bf83-11ea-9622-d34dd541cacb.PNG">

	- 위와 같이 default 패키지외에 또다른 패키지를 생성하고 클래스를 생성함, 폴더 단위로 형성됨, 각각이 존재함, 패키지 단위가 폴더로 구분됨
```Java
// 새로운 패키지의 새로운 클래스 생성
package test.pack1; // 아래 클래스는 해당 패키지안에 들어있는 클래스라고 알려줌

public class PClass1 {

			public void method1() {
					System.out.println("패키지 1번의 클래스 1번");
			}
}
```
```Java
// 새로운 패키지의 새로운 클래스 생성
package test.pack1;

public class PClass2 {
			
			public void method1() {
					System.out.println("패키지 1번의 클래스 2번");
			}
}
```
```Java
// 새로운 패키지의 새로운 클래스 생성
package test.pack2;

public class P2Class1 {
		public void method1() {
				System.out.println("패키지 2번의 클래스 1번");
		}
}
```
```Java
// 새로운 패키지의 새로운 클래스 생성
package test.pack2;

public class P2Class2 {
		public void method1() {
				System.out.println("패키지 2번의 클래스 2번"); // System 역시 클래스지만
// 기본 클래스이므로 import하지 않아도 됨 
		}
}
```
```Java
// main 클래스
import test.pack1.PClass1;
import test.pack1.PClass2;
// import test.pack1.*;를 이용해서 test.pack1의 모든 클래스를 사용할 수 있음


public static void main(String[] args) {
		PClass1 p1c1 = new PClass1(); // 그냥 치면 오류가 뜨므로 import해줘야함
		PClass2 p1c2 = new PClass2(); // 그냥 치면 오류가 뜨므로 import해줘야함
		
		p1c1.method1(); // 패키지 1번의 클래스 1번
		p1c2.method1(); // 패키지 1번의 클래스 2번

		test.pack2.P2Class1 p2c1 = new test.pack2.P2Class1();
		// 위아래와 같은 방식으로 쓰게 된다면 import를 쓰지 않고 사용할 수 있음
		test.pack2.P2Class2 p2c2 = new test.pack2.P2Class2();

		p2c1.method1(); // 패키지 2번의 클래스 1번
		p2c2.method1(); // 패키지 2번의 클래스 2번
}

// 기능별로 하나의 기능을 구현하기 위한 자바파일을 폴더별로 구분해서 사용할 수 있음
```
- 기본 패키지
	- 제공되어지는 모든 패키지 중에서 java.lang패키지는 import하지 않아도 클래스를 사용할 수 있음
	- java.lang안에는 자바 프로그램을 만들고 실행시키기 위한 가장 기본적인 클래스들과 가장 중요한 클래스들이 들어 있음
	- 자바에는 수십 개의 패키지를 제공하며 이러한 패키지를 통해 클래스를 사용하는 목적에 따라 나누어 제공을 하고 있음
	- 자바 프로그램은 이러한 패키지에 들어 있는 클래스들을 사용함으로써 프로그램을 작성하게 됨
	- 나머지 패키지는 쓰려면 import를 사용해야함
	