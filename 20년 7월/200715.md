# 테스트
```Java
// Interface를 활용한 클래스
public class Function implements FunctionInterface{
	@Override
	public double add(int a,int b) {
		return a+b;
	}
	
	@Override
	public double add(double a, int b) {
		return a+b;
	}
	
	@Override
	public double add(int a, double b) {
		return a+b;
	}
	
	@Override
	public double add(double a, double b) {
		return a+b;
	}
	
	@Override
	public double subtract(int a, int b) {
		return a-b;
	}
	
	@Override
	public double subtract(double a, int b) {
		return a-b;
	}
	
	@Override
	public double subtract(int a, double b) {
		return a-b;
	}
	
	@Override
	public double subtract(double a, double b) {
		return a-b;
	}
	
	@Override 
	public double multiple(int a, int b) {
		return a*b;
	}
	
	@Override 
	public double multiple(double a, int b) {
		return a*b;
	}
	
	@Override
	public double multiple(int a, double b) {
		return a*b;
	}
	
	@Override
	public double multiple(double a, double b) {
		return a*b;
	}
	
	@Override
	public double divide(int a, int b) {
		return a/b;
	}
	
	@Override
	public double divide(double a, int b) {
		return a/b;
	}
	
	@Override
	public double divide(int a, double b) {
		return a/b;
	}
	
	@Override
	public double divide(double a, double b) {
		return a/b;
	}
	
	@Override
	public int countOfBInA(int a, int b) {
		int cnt = 0;
		while(a!=0) {
			if(a%10==b) {
				cnt++;
				a/=10;
			}
			else {
				a/=10;
			}
		}
		return cnt;
	}
	
	@Override 
	public int countOfBInA(double a, int b) {
		int cnt = 0;
		while(a!=0) {
			if(a%10==b) {
				cnt++;
				a/=10;
			}
			else {
				a/=10;
			}
		}
		return cnt;
	}
	
	@Override
	public double calculate(int a, String operand, int b) {
		double result = 0;
		switch(operand) {
		case "+":
			result=add(a,b);
			break;
		case "-":
			result=subtract(a,b);
			break;
		case "*":
			result=multiple(a,b);
			break;
		case "/":
			result=divide(a,b);
			break;
		case "&":
			result=(int)result;
			result=countOfBInA(a,b);
			break;
		}
		return result;
	}
}
```
```Java
// Main 클래스
import java.io.BufferedReader;
import java.io.InputStreamReader;

// 계산기 만들기
// 계산기에 들어갈 처리
// 1.더하기 -> 2개의 변수를 받아서 더하기 처리를함, 빼기, 곱하기, 나누기도 동일함
// 숫자카운트 -> 받은 변수에서 지정한 숫자가 몇번 들어가 있는지 숫자를 센다

// 숫자 문자 숫자 입력받음 -> 각 문자별로 메소드 구현
// 숫자 입력시 정수 실수 판별(메소드 안에서 구현)
// +,-,/,*,&로 입력 받음

public class test {
static int cal1, cal2,cal3,count2;
static double cnt1,cnt2,cnt3,count1;
	public static void main(String[] args) {
		Function Func = new Function();
		String num1, calc,num2,num3,calc2;
		try {
			InputStreamReader ir = new InputStreamReader(System.in);
			BufferedReader br = new BufferedReader(ir);
			num1=br.readLine();
			calc=br.readLine();
			num2=br.readLine();
			cal2=Integer.parseInt(num1);
			cal3=Integer.parseInt(num2);
			count1=Func.calculate(cal2, calc, cal3);
			System.out.println(Func.calculate(cal2,calc,cal3));
			count2=(int)count1;
			while(true) {
				calc2=br.readLine();
				num3=br.readLine();
				cal1=Integer.parseInt(num3);
				System.out.println(Func.calculate(count2,calc2,cal1));
				count2=(int) Func.calculate(count2,calc2,cal1);
				
			}
			
		}catch(Exception e) {}
	}
}
```
## 수정사항
- 보내준 인터페이스 파일을 새로운 클래스에 implements하고 override하여서 메소드들을 만들고 해당 메소드 중 calculate 메소드를 활용하여 계산하고 메인 클래스에다가 사용함

### QnA
- 말해준 것 중에 형변환해서 변수를 줄이는 부분에 대해서 해결을 하지 못한 것 같음, 만일 한 번 더 피드백을 받아야 한다면 수정해야 할 사항 같음
- 같은 메소드 명이더라도 매개변수로 참조받는 변수가 다르면 다른 메소드로 인식하여 쓰이는 걸로 알고 있음 근데 지금 내 코드는 저번 코드의 실수 범주라고 생각하면서 계산하는 클래스에 있는 메소드들을 다 활용하지 못 한 것 같음 

### 자체리뷰
- 오버라이딩이 객체지향에서 왜 중요한가에 대해서 이 프로그램으로 생각해 본 것은 지금 프로그램은 단순히 계산기를 만드는 프로그램이지만 실제 내가 이것보다 스케일이 큰 프로그래밍을 할 시 다른 메소드를 사용하거나 클래스나 인터페이스를 사용하는 경우가 있을텐데 내가 쓰는 기능에 맞춰서 수정을 해야 할 경우 메소드를 참조받은 클래스나 인터페이스가 아닌 오버라이딩을 통해서 내가 원하는 기능으로 맞춰서 쓰고 그리고 원본은 건드리지 않음으로써 유지 보수나 협업의 측면에서 혼란을 주지 않고 각자 파트에 맞춰서 유동적으로 그리고 다양하게 활용할 수 있는 부분에서 중요하다고 생각함