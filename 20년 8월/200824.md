## 스레드 이해하기
### 스레드 사용하기
- 스레드는 하나의 실행 단위임
- 스레드와 애니메이션
<img src="https://user-images.githubusercontent.com/32586985/91044423-376ec580-e650-11ea-9134-f9f4a4bfc8f8.PNG">

- 멀티 스레드
<img src="https://user-images.githubusercontent.com/32586985/91044459-4786a500-e650-11ea-9ab4-accc63a552e7.PNG">

- 앱 실행시 메인 스레드 자동 생성, 앱이 한아의 프레스삭 생성되고 그 프로세스 위에서 VM, ART라고 하는게 실행이 되고 그 위에 앱이 동작을 하게 됨
- 앱 실행 시 리눅스 기반인데 그 리눅스 위에서 프로세스 하나가 만들어지고 그 프로세스 안에서 동시 작업을 하고 싶으면 스레드를 만드는 것
- 앱 실행 시 메인 스레드가 만들어지고 그것이 앱을 동작시키는 가장 기본적인 스레드임
- 이 메인 스레드가 이미지나 UI 쪽에 접근하면서 컨트롤 함
- 하지만 스레드를 직접 만들어서 다른 스레드가 이미지나 UI 쪽에 접근할 수 있음
- 안드로이드에서는 리소스를 직접 접근하면 문제가 생기고, 직접 접근할 수 없음, 만일 스레드 생성시 메인 스레드에서 접근하여 제어하는 것과 생성된 스레드 간에 시스템이 어떤 걸 먼저 처리할 지 모르는 상황이 발생하여서 멈출 수 있는 데드락 상황이 생기게 됨 
- 이 때 빌드나 앱 실행 시점에 에러가 생김

- 메인 액티비티
	- 애플리케이션이 실행될 때 하나의 프로세스에서 처리
	- 이벤트를 처리하거나 필요한 메소드를 정의하여 기능을 구현하는 경우에도 동일한 프로세스 내에서 실행
- 문제점
	- 대기 시간이 길어지는 네트워크 요청 등의 기능을 수행할 때는 화면에 보이는 UI도 멈춤 상태로 있게 됨
- 해결 방안
	- 하나의 프로세스 안에서 여러 개의 작업이 동시 수행되는 멀티 스레드 방식을 사용
- 멀티 스레드
	- 같은 프로세스 안에 들어 있으면서 메모리 리소스를 공유하게 되므로 효율적인 처리가 가능
	- 동시에 리소스를 접근할 경우 데드락(DeadLock) 발생

- 핸들러 사용하기
<img src="https://user-images.githubusercontent.com/32586985/91044588-7e5cbb00-e650-11ea-859c-07281c4f3738.PNG">

- 서비스의 경우 UI가 없으므로 UI를 직접 접근할 일이 없고 액티비티로 데이터를 보내서 보여주게 됨, 이런 경우 데드락이 생기지 않음
- 액티비티에서 UI 객체를 스레드 안에서 접근하는 경우 문제가 생기게 됨 

- 표준 자바에서 스레드 사용 방법
- 스레드는 new 연산자를 이용하여 객체를 생성한 후 start() 메소드를 호출하면 시작함
- Thread 클래스에 정의된 생성자는 크게 파라미터가 없는 경우와 Runnable 객체를 파라미터로 가지는 두 가지로 구분함
<img src="https://user-images.githubusercontent.com/32586985/91044639-92a0b800-e650-11ea-82c9-aa0446c74773.PNG">

- 버튼을 누르면 value 변수에 들어있는 정수 타입의 값을 텍스트뷰에 보여줌
- 스레드를 BackgroundThread라는 이름으로 정의
<img src="https://user-images.githubusercontent.com/32586985/91044679-a3512e00-e650-11ea-8895-993fae39ba90.PNG">

- 메시지 전송하여 실행하기
- 메인 스레드
	- 애플리케이션 객체인 액티비티, 브로드캐스트 수신자 등과 새로 만들어지는 원도우를 관리하기 위한 메시지 큐(Message Queue)를 실행함
- 메시지 큐 : Message Queue
	- 순차적으로 코드를 수행함
- 핸들러 : Handler
	- 메시지 큐를 이용해 메인 스레드에서 처리할 메시지를 전달하는 역할을 담당함
	- 특정 메시지가 미래의 어떤 시점에 실행되도록 스케줄링 할 수 있음
- 메인 스레드에 핸들러를 만들어서 직접 만든 스레드를 핸들러에서 요청하여서 처리하게끔 함

- 메시지 전송하여 실행하는 구조
<img src="https://user-images.githubusercontent.com/32586985/91044767-c67bdd80-e650-11ea-9873-f2edf74ae357.PNG">

- UI가 관련한 메인 스레드가 있으면 핸들러가 붙어있는 형태로 되어 있음 만든 스레드에서 요청을 보내어서 메인 스레드가 필요한, 동작하는 데 필요한 것과 충돌하지 않도록 순서대로 실행시켜주게 됨
- 요청을 보내기 위해서 메시지라고 하는 객체를 가지고 거기 안에 데이터를 넣어서 보내면 핸들러라고 하는 게 처리할 수 있는 방식이 됨
- obtainMessage()
	- 호출의 결과로 메시지 객체를 리턴받게함
- sendMessage()
	- 메시지큐에 넣음
- handleMessage()
	- 메소드에 정의된 기능이 수행됨
	- 코드가 수행되는 위치는 새로 만든 스레드가 아닌 메인 스레드가 됨

- 버튼을 누르면 내부에서 스레드를 하나 만들고 스레드에서 값을 꼐속 특정한 값을 특정한 변수에 넣어둔 값을 증가 시키고 증가를 시킨 상태에서 값을 표시할 것임, 스레드 시작을 누르고 진행 값 확인을 누르면 스레드에서 만들어낸 값 중에 지금 현재 값을 표시해주는 기능
<img src="https://user-images.githubusercontent.com/32586985/91044864-f0cd9b00-e650-11ea-8ba3-0f5eb3178009.PNG">
<img src="https://user-images.githubusercontent.com/32586985/91044893-fa570300-e650-11ea-8ab4-a892d9f1a887.PNG">

- 스레드 시작을 누르면 내부에서 value값이 증가되고 진행 값 확인을 누르면 증가한 값을 알게 됨 
- 위의 예시는 스레드에서 UI, 텍스트 뷰에 직접 접근할 수 없기 때문에 만들어 본 것

- 직접 스레드 안에서 value를 증가시키고 바로 접근할 수 있게끔 만들 수 있음, 하지만 여기서 스레드 클래스 안에 직접 뷰에 접근하는 코드를 작성시 에러가 뜨고 안됨, 이때 핸들러를 사용해야함
- 핸들러 역시 클래스를 정의해서 씀
- 데이터를 넘기기 위해서 핸들러를 사용함 메인에다가 핸들러 객체를 정의하고 그 객체를 정의한 것을 바탕으로 생성한 스레드에 sendMessage와 bundle을 생성하여 데이터를 넣고 그 데이터를 messag를 통해 데이터 처리하고 sendMessage로 보냄 그리고 그 message는 handleMessage를 거치게 됨, 자동으로 호출됨, handleMessage는 UI에 접근할 수 있고 이 부분에서 bundle을 통해서 보낸 데이터를 받게끔 함
<img src="https://user-images.githubusercontent.com/32586985/91044959-122e8700-e651-11ea-89f0-a4c9380169a8.PNG">
<img src="https://user-images.githubusercontent.com/32586985/91044985-1b1f5880-e651-11ea-836b-faaf9494cc0d.PNG">

- 스레드가 만들어지고 메인스레드 핸들러가 핸들이 자동으로 호출되면서 현재값이 바뀌는걸 실시간으로 볼 수 있게함

- 핸들러가 살짝 복잡함 다양한 UI를 접근할 수 있기 때문에 새로운 핸들러를 정의하고 각각 케이스별 UI 접근을 알고 전달해야하는 것이 복잡할 수 있음, 이 부분을 안하고 할 수 있는 방법이 있음
- 실제로 실무에서는 좀 더 단순한 형태를 사용함, 핸들러를 단순화 시킴
- 핸들러라고 하는 일반 객체를 쓰는 방식을 사용함, 스레드 내부에서 쓸 수 있는 핸들러를 정의하는 것, 그 메소드를 이용해서 처리를 하도록 함
- 위에서 첫번째 버튼 클릭시 BackgroundThread 객체를 만드는 것 말고 Runnable 객체를 implement하는 것임
- 위의 예시에서 따로 스레드를 정의한 것을 Runnable을 집어넣어서 만듬 
<img src="https://user-images.githubusercontent.com/32586985/91045043-325e4600-e651-11ea-8184-69015ad0cbc5.PNG">

- 아래와 같이 코드를 만들게 되면 클래스를 2개 나누어서 쓴 코드가 Runnable을 사용하여서 한 번에 코드로 정리하여서 간편하게 보이게 할 수 있음
<img src="https://user-images.githubusercontent.com/32586985/91045070-3e4a0800-e651-11ea-8db6-83556580ffe2.PNG">

- 인터넷 기능을 쓰게 되는데 인터넷 기능을 쓰려면 쓰레드를 쓰게끔 강제하고 있음, 스레드에 나온 값을 UI에 뿌려주기 위해 핸들러를 쓰게 됨, 별도의 라이브러리가 있지만 이해하기 위해서 핸들러를 써야하는걸 이해하는게 중요함

- 핸들러의 기능 
	- 새로 만든 스레드에서 메인 스레드로 메시지를 전달하는 것임
- 스레드의 작업 결과물을 메시지로 만들어 전달하는 이유
	- 별도의 스레드에서 메인 스레드가 관리하는 UI 객체에 직접 접근할 수 없기 때문임
- 메인 스레드에서 별도의 스레드로 메시지를 전달하는 방법이 필요한 경우
	- 일반적으로 변수 선언을 통해 데이터를 전달하는 것이 가장 쉬운 방법임
	- 핸들러가 사용하는 메시지 큐를 이용하여 순차적으로 메시지를 실행하는 방식이 필요한 경우가 발생함
	- 특히 별도의 스레드가 동일한 객체에 접근할 때 다른 스레드들이 동시에 메소드를 호출하는 경우가 있을 수 있으므로 메시지 큐를 이용한 접근 방식에 대해 이해가 필요함

- 루퍼를 이용한 메시지 처리
- 새로 만든 스레드 안에 핸들러 정의한 스레드의 핸들러가 됨, 루퍼를 이용함, 별도로 만들 경우 직접 만들어야함
<img src="https://user-images.githubusercontent.com/32586985/91045148-6174b780-e651-11ea-8b5a-eab2c2d89474.PNG">

- 루퍼
	- 무한 루프 방식을 이용해 메시지 큐에 들어오는 메시지를 지속적으로 보면서 하나씩 처리함
- 실습
<img src="https://user-images.githubusercontent.com/32586985/91045184-75b8b480-e651-11ea-9b85-be02522655d1.PNG">
<img src="https://user-images.githubusercontent.com/32586985/91045209-7e10ef80-e651-11ea-8df5-a0a254265175.PNG">

- 생각해보기
- Message 객체를 사용하는 방식보다 post 메소드를 호출하는 방식이 좋은 이유가 뭘까요?
- 불필요한 코드 길이를 단축시키고 좀 더 간단하게 코드를 짤 수 있고 UI나 접근해야하는 데이터가 많아질 경우 처리해야할 때 좀 더 간편하게 이용할 수 있다
- 일정 시간 후에 코드가 실행되도록 만들면서 그 때 다시 또 한 번 일정 시간 후에 코드가 실행되도록 만들면 어떻게 될까요?
- 일정시간에 맞춰서 계속해서 코드가 실행되게 될 것이다

### AsyncTask 사용하기
- AsyncTask
	- 백그라운드 작업을 좀 더 쉽고 간단하게 하고 싶다면 AsyncTask 클래스를 사용할 수 있음
	- AsyncTask 객체를 만들고 execute() 메소드를 실행하면 이 객체는 정의된 백그라운드 작업을 수행하고 필요한 경우에 그 결과를 메인 스레드에서 실행하므로 UI 객체에 접근하는데 문제가 없게 됨
<img src="https://user-images.githubusercontent.com/32586985/91045307-a7318000-e651-11ea-9275-dd462695ffb7.PNG">
<img src="https://user-images.githubusercontent.com/32586985/91045339-b44e6f00-e651-11ea-9c25-fa0ba2cda7a1.PNG">
<img src="https://user-images.githubusercontent.com/32586985/91045371-bd3f4080-e651-11ea-8e76-15875084ba89.PNG">

- AsyncTask 사용하기 예제
<img src="https://user-images.githubusercontent.com/32586985/91045413-ccbe8980-e651-11ea-9e24-dbe62f68dfb2.PNG">
<img src="https://user-images.githubusercontent.com/32586985/91045432-d6e08800-e651-11ea-918b-e6adc55f83b3.PNG">

- 핸들러 없이 AsyncTask 클래스를 정의하고 그걸 가지고 객체를 만들고 그 안에서 스레드로 동작하는 코드와 UI로 접근하는 코드를 메소드로만 분리를 해서 코드를 같이 넣을 수 있음
<img src="https://user-images.githubusercontent.com/32586985/91045466-e364e080-e651-11ea-80d1-49aed4a389da.PNG">

- 위의 실습에서 쓴 부분을 AsyncTask를 이용해서 구현을 함

- 생각해보기
- AsyncTask로 만든 클래스는 별도의 자바 파일로 만들어두는 것이 좋을까요?
- 관리면에서는 별도로 만드는 것이 좋을수도 있게지만 UI가 존재하는 예제같은 경우는 좋은 방법은 아닌 것 같다
- 일정 시간 후에 코드가 실행되도록 만들면서 그 때 다시 또 한 번 일정 시간 후에 코드가 실행되도록 만들면 어떻게 될까요?
- 그에 맞춰서 그만큼의 일정시간이 늦춰지면서 그 시간에 맞춰서 실행이 됨