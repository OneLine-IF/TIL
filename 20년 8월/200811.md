## 프래그먼트 이해하기
### 프래그먼트 만들기
- 한 화면에 여러 부분화면을 넣는 방식
	- 태블릿과 같이 큰 화면에서는 한 화면에 여러 부분화면을 넣는 것이 효율적임
<img src="https://user-images.githubusercontent.com/32586985/89859119-3911a580-dbdb-11ea-82db-8df5cce40d29.PNG">

- 부분화면은 화면의 일부만을 차지함, xml 레이아웃을 넣고 뷰처럼 새로 정의를 하고 부분화면을 뷰로 만들어서 집어넣어서 씀
- 하지만 화면이 한 개가 아니라 여러개일 경우 그 부분화면을 계속 반복해서 넣어야 함
- 추가한 내용들을 다른 화면에도 필요할 경우에 레이아웃과 기능을 계속 반복해서 넣어줘야함 
- 그러한 부분화면 부분적으로 레이아웃을 잡아야하는 것을 독립적으로 운용하는 방식이 있음
- 부분화면을 만들고 부분화면이 액티비티처럼 독립적으로 동작하고 만들게 된다면 독립적으로 부분화면을 구성할 수 있는데 이것을 프래그먼트라고 함
- UI 구성을 할 때 직접 UI를 넣는 경우 프래그먼트를 많이 사용함

- 부분화면을 독립적으로 만들기
	- 프래그먼트는 부분화면을 독립적으로 만들어주며 액티비티를 그대로 본떠 만든 것임
<img src="https://user-images.githubusercontent.com/32586985/89859167-58103780-dbdb-11ea-827e-6d344e7ae6dc.PNG">

- 프래그먼트 역시 액티비티처럼 만들었으므로 바로 접근을 할 수 없음
- 프래그먼트 역시 다른 프래그먼트를 요청시 프래그먼트 매니저에게 요청해야함
- 프래그먼트도 액티비티 위에 있어야 동작을 할 수 있음, 액티비티 사용하는 방법과 상당히 유사함
- 프래그먼트는 액티비티 위에서 쓰이기 때문에 인텐트를 사용할 수 없고 메소드를 정의해서 사용해야함
- 위의 사진과 같이 액티비티의 작동원리와 같이 프래그먼트 역시 액티비티 안에서 비슷한 원리로 작동한다는 것을 기억해야한다

- 프래그먼트를 이용해 화면 전환하기
	- 하나의 액티비티에 하나의 프래그먼트를 전체 화면으로 보여주면 시스템과 관계없이 전체 화면을 전환하는 효과를 만들 수 있음
<img src="https://user-images.githubusercontent.com/32586985/89859237-842bb880-dbdb-11ea-8d01-53442d7951b7.PNG">

- 프래그먼트가 부분화면이지만 액티비티 화면 전체를 채우도록 부분화면의 영역의 넓이를 넓히면 하나의 액티비티처럼 보이게 됨, 그리고 이 프래그먼트를 다른 프래그먼트하고 교체하게 되면 액티비티 자체는 바뀌지 않지만 프래그먼트가 화면전환 효과를 만들어냄
- 이렇게 하면 액티비티보다 훨씬 가볍게 전환할 수 있음, 보안면에서도 나음
- 즉, 프래그먼트를 전체화면으로 보이게 학고 전환하는 방법도 있음

- 프래그먼트를 화면에 추가하기
	- 프래그먼트는 액티비티 위에 올라가야 프래그먼트로 동작함
	- 인플레이션을 위한 별도의 콜백 메소드를 제공함
<img src="https://user-images.githubusercontent.com/32586985/89859290-9f96c380-dbdb-11ea-96cc-b511123bf9e2.PNG">

- 프래그먼트 역시 xml 레이아웃 파일 하나와 자바 소스 파일 하나로 쌍으로 구성되어 있음
- 연결시켜주기 위해서 인플레이션 과정을 해 줌, setContentview가 없기 때문에 직접 인플레이션 과정을 거쳐야함

- 프래그먼트를 만들어 화면에 추가하기
	- 프래그먼트를 위한 레이아웃 추가
<img src="https://user-images.githubusercontent.com/32586985/89859329-b63d1a80-dbdb-11ea-8ea5-54f5e1fe50b8.PNG">

- xml 레이아웃과 자바 소스 파일을 만들고 자바 소스 파일에는 Fragment를 상속받아서 사용
<img src="https://user-images.githubusercontent.com/32586985/89859351-c3f2a000-dbdb-11ea-8a0f-71594da43240.PNG">

- 프래그먼트도 액티비티를 본떠서 만들었기 때문에 수명주기 메소드를 가질 수 있도록 함
- 프래그먼트는 부분화면을 담기 위한 일종의 틀임
<img src="https://user-images.githubusercontent.com/32586985/89859376-d53bac80-dbdb-11ea-8409-906c7b535725.PNG">

- 위와 같이 정의하면 프래그먼트 하나가 정의가 돼서 만들어진 것임
<img src="https://user-images.githubusercontent.com/32586985/89859401-e4225f00-dbdb-11ea-81a4-7c86eb9dca67.PNG">

- 그리고 xml 파일에 fragment 태그로 추가를 하고 name을 정의해서 만들었던 자바소스 파일의 name을 붙이고 id를 추가하면 위와 같이 나타남
- 즉 자바소스파일로 정의하고 xml에 태그로 추가하여서 화면을 나타나게 함
- 자바 소스 코드를 이용해서 추가를 할 수도 있음, new 연산자로 새로운 객체를 만들고 추가할 수 있음
<img src="https://user-images.githubusercontent.com/32586985/89859429-f69c9880-dbdb-11ea-9b3d-e5bee2b51028.PNG">

- 위와 같이 추가하여서 사용할 수 있음, 여기서 프래그먼트 매니저를 사용하는 것을 잘 기억해야함
- 만일 프래그먼트가 하나가 아니고 두 개일 경우, 서로 번갈어서 보여지게 할 수도 있음
- 메뉴 화면으로를 눌렀을 시 프래그먼트 메뉴라고 하는 걸 만들어서 그쪽으로 전환되게 하고, 그리고 메인화면에서 버튼을 하나 더 만들어 그것을 눌렀을 때 메뉴 화면으로 바뀌게 하는 것까지 할 수 있음
<img src="https://user-images.githubusercontent.com/32586985/89859473-09af6880-dbdc-11ea-8909-afb4a8c8de22.PNG">

- 복사하여서 메뉴 프래그먼트를 만들어서 정의를 함
<img src="https://user-images.githubusercontent.com/32586985/89859500-192eb180-dbdc-11ea-80da-0f81679e6e1b.PNG">
<img src="https://user-images.githubusercontent.com/32586985/89859510-1cc23880-dbdc-11ea-98b8-8aa0e0474334.PNG">

- 위와 같이 코드를 짜서 버튼별로 구동을 할 수 있게끔 반복해서 쓸 수 있음
- 정리하면 프래그먼트가 MainActivity 화면에 추가가 되고 보이게 프래그먼트 간에 서로 전환하는 것과 프래그먼트를 버튼 누를 때마다 전환하게끔 전환하는 효과를 만듬, 프래그먼트가 프래그먼트 매니저라고 하는 거에 의해서 관리됨을 암

- 프래그먼트 화면 안에 들어가 있는 버튼을 눌렀을 때 다른 프래그먼트를 띄우게 할 것임 
- 프래그먼트는 액티비티 위에 올라가서 동작해야 의미가 있음, 액티비티가 시스템에서 관리하지 않으면 액티비티로서 동작할 수가 없음, 프래그먼트도 마찬가지
- 부분화면이므로 항상 액티비티 위에 올라가 있어야함
- 액티비티 위에 올라가는 시점, 프래그먼트 매니저에 의해서 add,replace 되는 시점에 프래그먼트로서의 일생이 시작됨
- 따라서 프래그먼트도 수명주기 메소드가 있음, 프래그먼트가 만들어질 때, 없어질 때, 액티비티에 올라갈 때
- 프래그먼트 자체가 액티비티에 올라가야 하므로, onCreate이전에 onAttach가 먼저 호출됨, onAttach가 프래그먼트가 액티비티에 올라간다는 것이고 onDetach는 다시 내려온다는 의미임, onCreate보다 먼저 그게 호출이 됨
<img src="https://user-images.githubusercontent.com/32586985/89859562-3cf1f780-dbdc-11ea-910a-e721fed3b069.PNG">
<img src="https://user-images.githubusercontent.com/32586985/89859568-411e1500-dbdc-11ea-9f51-c41646331336.PNG">

- 앱 실행 결과
	- 프래그먼트가 부분화면으로 추가됨
<img src="https://user-images.githubusercontent.com/32586985/89859604-54c97b80-dbdc-11ea-83fc-ce6a2e18e4fb.PNG">

- 코드에서 프래그먼트 추가하기
	- 프래그먼트가 액티비티의 프래그먼트 매니저를 통해 의사소통하는 방식
<img src="https://user-images.githubusercontent.com/32586985/89859621-6448c480-dbdc-11ea-98da-b96ae01fa774.PNG">

- 프래그먼트의 수명주기
	- 독립적인 상태 유지를 위해 수명주기 메소드를 제공함
<img src="https://user-images.githubusercontent.com/32586985/89859648-73c80d80-dbdc-11ea-8cbf-eb9595586f85.PNG">

- 만약 프래그먼트가 메인 액티비티에 올라갔다가 또 다른 액티비티에 올라가면 인터페이스를 이용해서 처리를 하면 됨
- 생각해보기
- 프래그먼트 안에 프래그먼트가 들어갈 수도 있을까요?
- 들어갈 수 있음, 프래그먼트 역시 xml 상에 태그로 쓰기 때문에 프래그먼트 안에 프래그먼트를 넣는 작업 역시 충분히 가능할 것임
- 프래그먼트에서 액티비티로 데이터를 전달했다가 액티비티에서 다시 프래그먼트로 데이터를 전달하는 과정을 정리해서 얘기해볼 수 있을까요?
- 먼저 프래그먼트와 액티비티가 서로 전달받기 위해서 액티비티에서 메소드를 우선적으로 정의를 하고 해당 메소드를 프래그먼트에서 액티비티를 선언 객체로 만들어서 액티비티 안에 있는 메소드를 참조해서 사용을 하고 액티비티에서 역시 해당 메소드를 이용해서 프래그먼트의 데이터를 사용할 수 있게끔 할 수 있다

## 프래그먼트 사용하기
### 프래그먼트로 이미지뷰어 만들기
- 이미지를 보여줄 프래그먼트, 이미지를 선택할 수 있는 프래그먼트로 구성
- 위와 같이 자바 소스코드 이용, getSupportFragmentMananger로 넣어 new를 만들어서 할 수도 있지만 
- xml 레이아웃에다가 바로 추가해줄 수도 있음, 그렇다면 레이아웃에 추가한 걸 찾아줘야함
- 다시 말하면 메인 액티비티 xml에서 먼저 추가를 해주고 그 다음에 메인 액티비티에서 찾아서 참조해서 쓰는 것임
<img src="https://user-images.githubusercontent.com/32586985/89859718-a07c2500-dbdc-11ea-9ddc-e5b2cb50e6b6.PNG">

- 프래그먼트가 위와 같이 들어가 있으므로 뷰를 찾는것과는 다름
<img src="https://user-images.githubusercontent.com/32586985/89859746-abcf5080-dbdc-11ea-91b1-5073e02adb3c.PNG">

- 뷰를 찾는 방식과 유사하긴함
- 위의 실습에서는 메인에서 인덱스 값을 처리했지만 지금 실습에서는 프래그먼트에서 메소드를 사용 호출 관리하여서 메인에서의 일을 줄임
<img src="https://user-images.githubusercontent.com/32586985/89859767-bbe73000-dbdc-11ea-95cb-9d6c6bbebab0.PNG">

- 리스트 프래그먼트에서 버튼을 각각 누를시 이미지 바뀌게끔 버튼에 대한 이벤트 처리를 함
- onImageChange라는 메인 액티비티에서의 메소드를 사용하여서 인덱스를 할당하게 함
<img src="https://user-images.githubusercontent.com/32586985/89859796-cc97a600-dbdc-11ea-99d5-6cbf1618af18.PNG">

- 메인에서는 fragment를 직접 xml에 넣어서 할당했으므로 위와 같이 선언하여 받을 수 있고 리스트 프래그먼트에서 쓰는 메소드를 통해서 인덱스에 따라 이미지가 바뀌게 함 그렇지만
<img src="https://user-images.githubusercontent.com/32586985/89859816-db7e5880-dbdc-11ea-8632-cf242a38020a.PNG">

- 이미지 변환에 대한 직접적인 처리는 뷰어 프래그먼트가 처리하도록 setImage 메소드를 활용해서 이미지가 바뀌게함
- 이렇게 되면 버튼을 누를시 각기 다른 이미지가 보이게 됨 

- 앱 실행 결과
<img src="https://user-images.githubusercontent.com/32586985/89859849-eafda180-dbdc-11ea-8d11-840427156659.PNG">

- 프래그먼트를 이용해서 각각을 독립적으로 보면서 사용할 수 있음

- 프래그먼트에서 액티비티의 메소드 호출
- 리스트뷰가 들어가 있는 프래그먼트에서 한 아이템을 선택하면 해당 아이템의 이미지를 이미지뷰가 들어가 있는 프래그먼트에 보내주어야함
- 하나의 프래그먼트에서 다른 프래그먼트로 직접 접근할 수 없으므로 시스템 역할을 하는 액티비티를 통해 명령이나 데어티를 전달해야함
- 액티비티의 메소드를 호출할 때는 프래그먼트가 어떤 액티비티 위에 올라가더라도 프래그먼트의 소스가 변경되지 않도록 인터페이스를 정의하여 사용해야함
- 아래와 같이 ImageSelectionCallBack 인터페이스를 정의했다면 이 인터페이스는 액티비티에서 구현하도록 하고 프래그먼트에서 이 인터페이스에서 정의한 메소드를 호출하도록 함
```Java
public class ListFragment extends Fragment {
...
public static interface ImageSelectionCallback {
	public void onImageSelected(int position);
}

public ImageSelectionCallback callback;

@Override
public void onAttach(Context context) {
	super.onAttach(context);

	if(context instanceof ImageSelectionCallback) {
		 callback = (ImageSelectionCallback) context;
	}
}
```
- 이 액티비티가 인터페이스를 구현하고 있다면 액티비티 객체를 변수에 할당함, 그리고 필요할 때 호출할 수 있음

- 액티비티에서 프래그먼트의 메소드 호출
- 리스트 프래그먼트에서 액티비티의 메소드를 호출하면 액티비티에서는 이미지 프래그먼트의 메소드를 호출할 수 있음
- 액티비티에 변수를 선언하고 프래그먼트 객체를 할당해주면 리스트 프래그먼트 객체나 이미지 프래그먼트 객체를 항상 참조할 수 있게 되며 액티비티의 메소드가 호출되었을 때 이미지 프래그먼트의 메소드를 호출함으로써 이미지를 변경할 수 있음
```Java
public class MainActivity extends AppCompatActivity implements ListFragment.ImageSelectionCallback {
	ListFragment listFragment;
	ViewerFragment viewerFragment;

...

	@Override
	public void onImageSelected(int position) {
		viewerFragment.setImage(images[position])
	}

}
```
- 액티비티에서 프래그먼트의 메소드를 호출할 때는 인터페이스를 사용할 필요가 없음

- 생각해보기
- 액티비티에서 프래그먼트의 메소드를 호출할 때는 왜 인터페이스를 사용할 필요가 없는걸까요?
- 우선 프래그먼트 자체가 액티비티의 올라가는 시점에서 사용되는 것인데 액티비티에서 이미 프래그먼트 객체를 참조하고 선언을 하였으므로 쓰이는 것은 알고 있으나 올라가는 시점에 쓰이는 프래그먼트를 알고 그 시점에서 프래그먼트의 인터페이스를 호출하여 사용하기 때문에 굳이 인터페이스를 사용할 필요가 없는 것 같다. 만일 그렇게 해야만 된다면 사용하는 모든 프래그먼트의 인터페이스를 써야 할 것이다
- 프래그먼트 안에 프래그먼트를 추가했을 때 메소드 호출을 어떻게 하면 될까요?
- 액티비티 → 부모 프래그먼트 → 자식 프래그먼트 순으로 호출이 될 것이다