### 알고리즘 수업
- Selection Sort
- 의사코드
```Markdown
selectionSort(A[], n) // 배열 A[1...n]을 정렬함
{
		for last <- n downto 2 { ........ 1
				A[1...last] 중 가장 큰 수 A[k]를 찾는다; ........ 2
				A[k] <-> A[last]; -> A[k]와 A[last]의 값을 교환 ........ 3
		}
}
```
- 실행시간
	- 1의 for루프는 n-1번 반복
	- 2에서 가장 큰 수를 찾기 위한 비교횟수 : n-1, n-2, .... , 2, 1
	- 3의 교환은 상수시간 작업
- 시간복잡도 T(n) = (n-1) + (n-2) + ... + 2 + 1 =O(n^2), 모든 경우가 다 O(n^2)이 됨
- Insertion Sort
- 의사코드
```Markdown
insertion(A[], n) // 배열 A[1...n]을 정렬함
{
		for i <- 2 to n { ............... 1
			A[1...i]의 적당한 자리에 A[i]를 삽입함 ..............2
}
```
- 수행시간
	- 1의 for 루프는 n-1번 반복
	- 2의 삽입은 최악의 경우 i-1번 비교
- 최악의 경우 : T(n) = (n-1) + (n-2) + ... + 2 + 1 = O(n^2)
- 구현
- Selection Sort
```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void) {
	int i, j, min, index, temp; // i,j는 배열의 값을 탐색하기 위해서 사용, min은 가장 작은 것을 반복적으로 선택, 가장 작은 원소가 존재하는 위차 index, temp 특 정 두 숫자를 바꾸기 위해서
	int array[10] = { 1,10,5,8,7,6,4,3,2,9 };
	for (i = 0; i < 10; i++) {
		min = 9999; //min은 항상 최솟값을 선택해야하므로 큰 값을 넣어줌
		for (j = i; j < 10; j++) {
			if (min > array[j]) { //현재 탐색하고 있는 원소가 현재 최솟값보다 작으면 바꿔줌
				min = array[j];
				index = j; // index로 해당 위치값 넣어줌
			}
		}
		temp = array[i]; // 일시적으로 가장 앞에 있는 값을 넣어줌
		array[i] = array[index]; // 가장 앞에 있는 원소의 값으로 최소값을 넣어주고
		array[index] = temp; // 최소값이 있는 위치에 temp의 값을 넣어줌
		// 스와핑 한다고 함 
	}
	for (i = 0; i < 10; i++) {
		printf("%d ", array[i]);
	}
}
```
- Insertion Sort
```C
#include <stdio.h>

int main(void) {
		int i, j, temp;  // 반복을 위해서 i,j선언, 원소값을 바꾸기 위한 일시적인 변수 temp
		int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
		for(i = 0; i < 9; i++) {
				j = i; // 현재 정렬할 그 원소를 선택해서 적절한 위치에 삽입할 수 있도록 해주기 위해서
				while(array[j] > array[j + 1]) {
						temp = array[j];
						array[j] = array[j + 1];
						array[j + 1] = temps;
						j--;	
				}
		}
		for(i = 0; i < 10; i++) {
				printf("%d ",array[i]);
		}
}
```