### 200910_1일1공.md

1. 알고리즘 과제에 시간을 많이 사용

	- 이차원 단일 연결리스트 구현 및 배열과의 연산 속도 비교 문제 

```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<time.h>

struct Node {
	struct Node* next;
	int e;
};
typedef struct Node node;

struct HNode {
	struct HNode* next;
	node* h;
};
typedef struct HNode Hnode;

node* getNode(node** p) {
	(*p) = (node*)malloc(sizeof(node));
	(*p)->next = NULL;
	return (*p);
}

Hnode* getHNode(Hnode** p) {
	(*p) = (Hnode*)malloc(sizeof(Hnode));
	(*p)->next = NULL;
	return (*p);
}

void addLastnode(node* H, int e) {
	node* p = getNode(&p);
	p->e = e;

	p->next = H->next;
	H->next = p;
}

void addHLastnode(Hnode* H, node* h) {
	Hnode* p = getHNode(&p);
	p->h = h;

	p->next = H->next;
	H->next = p;
}

void makeMetrixby2DS(int** arr1, int** arr2, Hnode* H1, Hnode* H2, int size, int elem1, int elem2) {
	// make Metrix #1 with (size, elem1) by 2-D array as DS
	for (int k = 0; k < size; k++) {
		for (int m = 0; m < size; m++) {
			arr1[k][m] = elem1;
		}
	}

	// make Metrix # with (size, elem2) by 2-D array as DS
	for (int k = 0; k < size; k++) {
		for (int m = 0; m < size; m++) {
			arr2[k][m] = elem2;
		}
	}

	// make Metrix #1 with (size, elem1) by 2-D linked list as DS
	for (int k = 0; k < size; k++) {
		node* h = getNode(&h);
		addHLastnode(H1, h);
		for (int m = 0; m < size; m++) {
			addLastnode(h, elem1);
		}
	}

	// make Metrix #2 with (size, elem2) by 2-D linked list as DS
	for (int k = 0; k < size; k++) {
		node* h = getNode(&h);
		addHLastnode(H2, h);
		for (int m = 0; m < size; m++) {
			addLastnode(h, elem2);
		}
	}
}

void printMetrixbyArray(int **arr, int size, char *str) {
	printf("\n");
	printf("- Metrix #%s:\n\n", str);
	for (int k = 0; k < size; k++) {
		for (int m = 0; m < size; m++) {
			printf(" %d", arr[k][m]);
		}
		printf("\n");
	}
}

void printMetrixbyLinkedlist(Hnode* H, char *str) {
	printf("\n");
	printf("- Metrix #%s:\n\n", str);
	for (Hnode* p = H->next; p != NULL; p = p->next) {
		for (node* q = p->h->next; q != NULL; q = q->next) {
			printf(" %d", q->e);
		}
		printf("\n");
	}
}

int **addMetrixbyArray(int** arr1, int** arr2, int size) {
	//첫번째 행렬, 이차원 배열을 만들기 위해 포인터에 동적할당
	int** result = NULL;
	result = (int**)malloc(size * sizeof(int*));
	for (int i = 0; i < size; i++) *(result + i) = (int*)malloc(size * sizeof(int));

	for (int k = 0; k < size; k++) {
		for (int m = 0; m < size; m++) {
			result[k][m] = arr1[k][m] + arr2[k][m];
		}
	}
	return result;
}

int** multiplyMetrixbyArray(int** arr1, int** arr2, int size) {
	//첫번째 행렬, 이차원 배열을 만들기 위해 포인터에 동적할당
	int** result = NULL;
	result = (int**)malloc(size * sizeof(int*));
	for (int i = 0; i < size; i++) *(result + i) = (int*)malloc(size * sizeof(int));

	for (int k = 0; k < size; k++) {
		for (int m = 0; m < size; m++) {
			result[k][m] = 0;
			for (int i = 0; i < size; i++) {
				result[k][m] += arr1[k][i] * arr2[i][m];
			}
		}
	}
	return result;
}

Hnode *addMetrixbyLinkedlist(Hnode *H1, Hnode *H2, int size) {
	Hnode* result = getHNode(&result), * p1 = H1->next, * p2 = H2->next;

	for (int k = 0; k < size; k++) {
		node* h = getNode(&h);
		addHLastnode(result, h);

		node* q1 = p1->h->next, * q2 = p2->h->next;
		for (int m = 0; m < size; m++) {
			int sum = q1->e + q2->e;
			addLastnode(h, sum);
			q1 = q1->next;
			q2 = q2->next;
		}
		p1 = p1->next;
		p2 = p2->next;
	}
	return result;
}

Hnode* multiplyMetrixbyLinkedlist(Hnode* H1, Hnode* H2, int size) {
	Hnode* result = getHNode(&result), * p1 = H1->next, * p2 = H2->next;

	for (int k = 0; k < size; k++) {
		node* h = getNode(&h);
		addHLastnode(result, h);

		node* q1 = p1->h->next, * q2 = p2->h->next;
		for (int m = 0; m < size; m++) {
			int mul = 0;
			node* s1 = p1->h->next, * s2 = p2->h->next;
			for (int k = 0; k < size; k++) {
				mul += s1->e * s2->e;
				s1 = s1->next;
				s2 = s2->next;
			}
			addLastnode(h, mul);
			q1 = q1->next;
			q2 = q2->next;
		}
		p1 = p1->next;
		p2 = p2->next;
	}
	return result;
}

void main() {
	clock_t start1, start2, end1, end2;
	float res1, res2;
	Hnode* H1 = getHNode(&H1), * H2 = getHNode(&H2), * listResult = NULL;
	int** arr1 = NULL, ** arr2 = NULL, N, size, elem1, elem2, ** arrayResult = NULL;

	printf("How many times will you compare? ");
	scanf("%d", &N);
	// boundary line!
	printf("-------------------------------------------------------------------------");

	for (int i = 0; i < N; i++) {
		printf("\nSize of the N*N Metrix: ");
		scanf("%d", &size);
		printf("\nElement of the N*N Metrix #1 : ");
		scanf("%d", &elem1);
		printf("Element of the N*N Metrix #2 : ");
		scanf("%d", &elem2);

		//첫번째 행렬, 이차원 배열을 만들기 위해 포인터에 동적할당
		arr1 = (int**)malloc(size * sizeof(int*));
		for (int i = 0; i < size; i++) *(arr1 + i) = (int*)malloc(size * sizeof(int));

		//두번째 행렬, 이차원 배열을 만들기 위해 포인터에 동적할당
		arr2 = (int**)malloc(size * sizeof(int*));
		for (int i = 0; i < size; i++) *(arr2 + i) = (int*)malloc(size * sizeof(int));

		// make Matrix #1 and #2 by 2-D array and 2-D linked list as DS
		makeMetrixby2DS(arr1, arr2, H1, H2, size, elem1, elem2);
		
		// print both Metrix #1 and Metrix #2
		//printMetrixbyArray(arr1, size, "1");
		//printMetrixbyArray(arr2, size, "2");

		// print result of adding and multipling by 2-D Array
		start1 = clock();
		arrayResult = addMetrixbyArray(arr1, arr2, size);
		end1 = clock();
		//printMetrixbyArray(arrayResult, size, "add_result_by_Array");
		res1 = (float)(end1 - start1) / CLOCKS_PER_SEC;
		printf("%.6f\n", res1);

		start2 = clock();
		arrayResult = multiplyMetrixbyArray(arr1, arr2, size);
		end2 = clock();
		//printMetrixbyArray(arrayResult, size, "multiply_result_by_Array");
		res2 = (float)(end2 - start2) / CLOCKS_PER_SEC;
		printf("%.6f\n", res2);

		// print result of adding and multipling by 2-D Linkedlist
		listResult = addMetrixbyLinkedlist(H1, H2, size);
		//printMetrixbyLinkedlist(listResult, "add_result_by_Linkedlist");

		listResult = multiplyMetrixbyLinkedlist(H1, H2, size);
		//printMetrixbyLinkedlist(listResult, "multiply_result_by_Linkedlist");

		// boundary line of next compare!
		printf("-------------------------------------------------------------------------");
	}
}
```