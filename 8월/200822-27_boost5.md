### 네이버_부스트코스_5

## 스레드 이해하기

# 스레드 사용하기

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616202">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616226">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616269">


<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616304">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616333">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616346">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616368">

1. 스레드와 핸들러

- 스레드는 동시 작업을 위한 한 단위

- 앱을 실행하면 하나의 스레드가 시작되는데 이것을 메인 스레드

- 바로 앱의 기본 실행을 담당

- 새로 만든 스레드는 메인 스레드와 별개로 실행될 수 있고 독립적인 실행이 가능하기 때문에 자주 사용

- 표준 자바를 공부했다면 안드로이드에서 스레드가 동작하는 방식은 표준 자바와 동일하다고 할 수 있습니다. 다만, 한 가지 차이점이 있는데 메인 스레드에서 관리하는 UI 구성요소를 접근할 때는 핸들러가 반드시 사용되어야 한다는 점

- 그 이유는 UI나 파일과 같은 리소스는 여러 개의 스레드가 동시에 접근했을 때 시스템에서 어떤 것을 먼저 처리해야 하는지 모르는 문제가 발생할 수 있기 때문, 이 때문에 핸들러라는 것이 만들어져 있습니다.

- 핸들러는 각각의 스레드 안에 만들어질 수 있고 다른 스레드에서 요청하는 정보를 순서대로 실행시켜 줄 수 있기 때문에 리소스에 대한 동시 접근의 문제를 해결

1. 핸들러 사용

- 스레드에서 핸들러로 메시지를 보내려면 Message 객체를 사용

- Message 객체를 obtainMessage 메소드로 참조한 후 sendMessage 메시지를 이용해 핸들러로 보내면 handleMessage 메소드가 자동으로 호출되기 때문에 전달된 Message 객체를 처리. 이 때 handleMessage 메소드는 메인 스레드에서 실행

1. Post 메소드 호출

- 핸들러의 post 메소드를 호출하면 Runnable 객체를 전달

- 핸들러로 전달된 Runnable, 객체는 메인 스레드에서 실행될 수 있으며 따라서 UI를 접근하는 코드는 Runnable 객체 안에 넣어두면 됩니다.

```Java
handler.post(new Runnable {
    public void run() {
    ...
    }
);
```

- post 메소드 이외에도 지정된 시간에 실행하는 postAtTime 메소드와 지정된 시간만큼 딜레이된 시간후 실행되는 postDelayed 메소드가 있습니다.

1. MainActivity.java

```Java
package com.example.thread;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

public class MainActivity extends AppCompatActivity {
    TextView textView;

    //int value = 0;

    ValueHandler handler = new ValueHandler();

    Handler handler2 = new Handler();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.textView);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //BackgroundThread thread = new BackgroundThread();
                //thread.start();

                // 위의 클래스를 정의해주는 방법 대신 이렇게 할 수도 있다.
               new Thread(new Runnable() {
                   int value = 0;
                   boolean running = false;

                    @Override
                    public void run() {
                        running = true;
                        while(running) {
                            value += 1;

                            handler2.post(new Runnable() {
                                @Override
                                public void run() {
                                    textView.setText("현재 값 : " + value);// 이 안에서 이제 UI 접근 가능!
                                    // 왜냐하면 이 부분은 메인 스레드에서 실행되기 때문에
                                }
                            });

                            try {
                                Thread.sleep(1000);
                            } catch (Exception e) {};
                        }

                    }
                }).start();
            }
        });

        Button button2 = (Button) findViewById(R.id.button2);
        button2.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //textView.setText("현재 값 : " + value);
            }
        });
    }

    class BackgroundThread extends Thread {
        int value = 0;
        boolean running = false;

        public void run() {
            running = true;
            while(running) {
                value += 1;
                // 이 쓰레드에서 위의 소스에 접근 불가. 메인 스레드만 가능 -> 핸들러 사용 필요
                // textView.setText("현재 값 : " + value); -> 이렇게 넣어주면 사용할 수 없다.

                Message  message = handler.obtainMessage();
                Bundle bundle = new Bundle();
                bundle.putInt("value",value);
                message.setData(bundle);
                handler.sendMessage(message);

                try {
                    Thread.sleep(1000);
                } catch (Exception e) {};

            }
        }
    }

    class ValueHandler extends Handler {
        @Override
        public void handleMessage(@NonNull Message msg) {
            super.handleMessage(msg);

            Bundle bundle = msg.getData();
            int value = bundle.getInt("value");
            textView.setText("현재 값 : " + value);
        }
    }
}
```

# AsyncTask 사용하기

- AsyncTask는 하나의 클래스 안에 스레드로 동작하는 부분과 UI 객체에 접근하는 부분을 함께 넣어둘 수 있도록 합니다. 이 때문에 스레드를 사용하는 하나의 작업 단위가 하나의 클래스로 만들어질 수 있죠.

1. AsyncTask 사용

- 핸들러를 사용하는 코드가 복잡하게 느껴지는 이유는 어떤 코드는 스레드 안에서 실행되고 어떤 코드는 UI를 접근하기 위해 핸들러 안에서 실행되어야 한다는 것을 구분해야 한다는 것 때문

- 이런 혼란스러운 면을 조금이라도 줄일 수 있도록 AsyncTask에서는 하나의 클래스 안에서 스레드 안에 넣을 코드와 UI를 접근할 코드를 모두 넣어둘 수 있도록 했습니다.

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678723395">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678723416">

- 스레드 안에서 실행될 코드는 doInBackground 메소드 안에 넣어두고 UI를 접근할 코드는 onPreExecute, onProgressUpdate, onPostExecute에 넣어둘 수 있습니다.

- AsyncTask도 스레드를 실행하는 것과 같기 때문에 스레드 안에서 실행될 대부분의 코드는 doInBackground 안에 들어가 있게 되며 중간중간 화면에 표시하기 위한 코드 실행을 위해 onProgressUpdate 메소드가 호출

- onProgressUpdate 메소드는 doInBackground 메소드 안에서 publishProgress 메소드가 호출 될 때 마다 자동으로 호출

1. MainActivity.java 에 추가된 코드!

```Java
ProgressTask task = new ProgressTask();
                task.execute("시작");
```

```Java
class ProgressTask extends AsyncTask<String, Integer, Integer> {
        int value = 0;

        @Override
        protected Integer doInBackground(String... strings) {// 처리되는 코드
            while(true) {
                if(value > 30){
                    break;
                }

                value += 1;

                publishProgress(value);// 바로 밑의 메서드가 실행

                try {
                    Thread.sleep(1000);
                } catch (Exception e) {};
            }

            return value;
        }

        @Override
        protected void onProgressUpdate(Integer... values) {// 핸들러에서 실행을 하듯이 UI 업데이트 하는데 문제가 없음
            super.onProgressUpdate(values);

            textView.setText(values[0].toString());
        }

        @Override
        protected void onPostExecute(Integer integer) {// 마지막 완료시 실행
            super.onPostExecute(integer);

            Toast.makeText(getApplicationContext(),"완료됨", Toast.LENGTH_SHORT).show();
        }
    }
```

## 소켓 사용하기

# 소켓 사용하기

- IP 주소를 이용해 목적지 호스트를 찾아내고 포트를 이용해 통신 접속점을 찾아내는 소켓 연결에 대해 알아보고 나면 네트워킹이 무엇인지 좀 더 잘 이해될 것입니다.

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678895130">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678895336">

- 파이프가 연결되어 있다고 생각하면 쉽다. 

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678895396">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678895446">

- 우리는 실습시 2개의 프로젝트에 각각 클라이언트 소켓과 서버 소켓을 구현해볼 것이다.

1. 소켓

- 소켓은 서버 소켓과 클라이언트 소켓을 만들고 서로 연결하는 과정을 거치게 됩니다. 서버 소켓은 연결을 기다리는 역할을 하고 클라이언트 소켓은 연결을 만드는 역할을 합니다. 클라이언트에서 연결을 만들고 나면 데이터를 보내거나 받을 수 있습니다. 서버 소켓을 사용하기 위하여 간단한 안드로이드 서버 앱을 만들어 봅니다.
안드로이드 스튜디오에서 프로젝트를 만들고 서버 소켓을 만듭니다.

1. 서버 소켓

- ServerSocket 클래스를 이용해 객체를 만들고 accept 함수를 호출하면 클라이언트로부터의 접속을 기다리게 됩니다.

```Java
int portNumber = 5001; 
            System.out.println("Starting Java Socket Server ..."); 
 
            ServerSocket aServerSocket = new ServerSocket(portNumber);
            System.out.println("Listening at port " + portNumber + " ...");
 
            while(true) {
                Socket sock = aServerSocket.accept();
```

- 클라이언트 소켓을 기다릴 때는 blocking mode로 동작하므로 프로그램이 대기하게 됩니다. 그리고 accept 메소드 이후의 코드는 클라이언트가 접속했을 때 동작합니다.
이 때문에 while 문을 사용하는 경우가 많습니다.

1. 데이터 보내고 받기

- 데이터를 보내고 받는 가장 간단한 방법은 ObjectOutputStream과 ObjectInputStream을 사용하는겁니다. ObjectOutputStream 객체를 만들고 writeObject 메소드를 이용해 데이터를 보냅니다. 이때 전송하려는 객체(데이터)는 직렬화(Serialization) 되어 있어야 합니다.

```Java
ObjectOutputStream outstream = new ObjectOutputStream(sock.getOutputStream());
outstream.writeObject(obj + " from Server.");
outstream.flush();
```

- ObjectInputStream 객체를 만들고 readObject 메소드를 이용해 데이터를 읽어 들일 수 있습니다.

```Java
ObjectInputStream instream = new ObjectInputStream(sock.getInputStream());
Object obj = instream.readObject();
System.out.println("Input : " + obj);
```

1. 클라이언트 소켓

- Socket 클래스는 클라이언트 소켓을 만들 때 사용합니다. 클라이언트 소켓을 만들 때는 서버의 IP와 포트 번호를 전달해야 하는데, 서버에서 지정한 포트 번호와 동일한 포트 번호를 사용해야 합니다.

```Java
int portNumber = 5001;
Socket sock = new Socket("localhost", portNumber);
```
1. 버튼 클릭 시에 서버에 요청하기

- 앱의 XML 레이아웃에 버튼을 하나 추가하고 버튼을 클릭했을 때 서버에 요청합니다.
서버 소켓을 만들어 두었으므로 클라이언트 소켓을 만들어 접속하면 됩니다. 단, 안드로이드에서는 인터넷을 사용할 때 스레드를 이용해야 하며 INTERNET 권한이 있어야 합니다.

```Java
button01.setOnClickListener(new OnClickListener() {
    public void onClick(View v) {
        String addr = input01.getText().toString().trim();
        ConnectThread thread = new ConnectThread(addr)
        thread.start();
    }
});
```

- 권한은 AndroidManifest.xml 파일에 추가합니다.

```Java
<uses-permission android:name="android.permission.INTERNET"></uses-permission>
```

- 서버 소켓에서 요청을 보내고 응답을 받을 때 사용했던 코드는 클라이언트 소켓에 동일하게 사용될 수 있습니다.

1. MainActivity.java (MyServer)
```Java
package com.example.server;

import androidx.appcompat.app.AppCompatActivity;

import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //ServerTread thread = new ServerTread();
                //thread.start();

                // 액티비티로 만들면 언제든 종료될 수 있으므로 서비스로 만들어 실행하는 것이 더 안정적이다.
                Intent intent = new Intent(getApplicationContext(),ChatService.class);
                startService(intent);

            }
        });
    }
    /*
    class ServerTread extends Thread {
        public void run() {
            int port = 5001;// 클라이언트가 이 포트 번호로 접속을 해야 함

            try {
                ServerSocket server = new ServerSocket(port);
                Log.d("SeverThread", "서버가 실행됨.");

                while(true) {
                    Socket socket = server.accept();// 대기 상태로 있다가 클라이언트가 접속하면 소켓 객체가 리턴

                    // 클라이언트로부터 데이터를 받음
                    ObjectInputStream instream = new ObjectInputStream(socket.getInputStream());// 들어오는 데이터를 처리. 스트림은 일종의 파이프
                    Object input = instream.readObject();
                    Log.d("ServerThread", "input : " + input);

                    // 클라이언트로 데이터를 보냄
                    ObjectOutputStream outstream = new ObjectOutputStream(socket.getOutputStream());
                    outstream.writeObject(input + "from server.");
                    outstream.flush();
                    Log.d("ServerThread", "output 보냄.");

                    socket.close();// 더 이상 연결을 유지할 필요가 없으면 끊어줘야한다.
                }

            } catch (Exception e){
                e.printStackTrace();
            }
        }
    }
    */
}
```

1. ChatService.java (MyServer)
```Java
package com.example.server;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;
import android.util.Log;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class ChatService extends Service {
    public ChatService() {
    }

    @Override
    public void onCreate() {
        super.onCreate();

        ServerTread thread = new ServerTread();
        thread.start();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
    }

    @Override
    public IBinder onBind(Intent intent) {
        throw new UnsupportedOperationException("Not yet implemented");
    }

    class ServerTread extends Thread {
        public void run() {
            int port = 5001;// 클라이언트가 이 포트 번호로 접속을 해야 함

            try {
                ServerSocket server = new ServerSocket(port);
                Log.d("SeverThread", "서버가 실행됨.");

                while(true) {
                    Socket socket = server.accept();// 대기 상태로 있다가 클라이언트가 접속하면 소켓 객체가 리턴

                    // 클라이언트로부터 데이터를 받음
                    ObjectInputStream instream = new ObjectInputStream(socket.getInputStream());// 들어오는 데이터를 처리. 스트림은 일종의 파이프
                    Object input = instream.readObject();
                    Log.d("ServerThread", "input : " + input);

                    // 클라이언트로 데이터를 보냄
                    ObjectOutputStream outstream = new ObjectOutputStream(socket.getOutputStream());
                    outstream.writeObject(input + "from server.");
                    outstream.flush();
                    Log.d("ServerThread", "output 보냄.");

                    socket.close();// 더 이상 연결을 유지할 필요가 없으면 끊어줘야한다.
                }

            } catch (Exception e){
                e.printStackTrace();
            }
        }
    }
}

```

1. MainActivity.java (MySocket)
```Java
package com.example.socket;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;

public class MainActivity extends AppCompatActivity {
    TextView textView;

    Handler handler = new Handler();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.textView);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                ClientThread thread = new ClientThread();
                thread.start();
            }
        });
    }

    class ClientThread extends Thread {
        public void run() {
            String host = "localhost";
            int port = 5001;

            try {
                Socket socket = new Socket(host, port);

                ObjectOutputStream outstream = new ObjectOutputStream(socket.getOutputStream());
                outstream.writeObject("안녕!");
                outstream.flush();
                Log.d("ClientThread", "서버로 보냄.");

                ObjectInputStream instream = new ObjectInputStream(socket.getInputStream());
                final Object input = instream.readObject();
                Log.d("ClientThread","받은 데이터 : " + input);

                handler.post(new Runnable() {
                    @Override
                    public void run() {
                        textView.setText("받은 데이터 : " + input);
                    }
                });

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

## 웹으로 요청하기

# HTTP 이해하기

- 웹브라우저에서 서버에 연결하고 웹페이지를 받아 와 화면에 보여줄 때 사용하는 것이 HTTP이기 때문에 인터넷에서 웹페이지를 요청하고 응답으로 받을 때는 HTTP를 사용한다고 생각하면 쉽습니다.

- HTTP도 앞에서 만들어보았던 소켓을 기반으로 동작

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-679440773">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-679440835">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-679440901">

- HTTP 는 소켓이라고 하는 연결 위에서 데이터가 왔다갔다 하는 포맷을 정의한 것

- 코드가 복잡하고 다 넣어줄 수 없으므로 우리는 라이브러리를 사용하여 이를 처리한다.


1. HTTP 요청과 응답

- 웹서버는 HTTP 요청을 받아 처리

- 웹브라우저와 같은 클라이언트는 웹서버에 연결을 만든 후 요청을 보내고 응답을 받아 화면에 보여주게 됩니다. 요청을 받거나 응답을 줄 때는 HTTP라는 국제표준에 맞는 포맷으로 주고받게 됩니다.

- 데이터를 주고받을 때의 포맷을 보면, 헤더(Header)와 바디(Body)로 구분되고 헤더에 어떤 것들이 들어갈 수 있는지가 표준으로 정해져 있습니다. 그리고 바디에는 보내고 받기 위한 대상 데이터를 넣어둘 수 있습니다.

1. 요청 포맷

- HTTP 요청 포맷을 보면, 첫 번째 줄이 기본적인 요청 정보를 포함하고 있습니다.
GET이나 POST와 같은 요청 방식(Method), 요청 패스 그리고 HTTP 버전 등

1. 응답 포맷

- 응답 포맷은 요청 포맷과 크게 다르지 않습니다. 헤더와 바디로 구분되고 헤더에는 한 줄씩 속성이 들어갑니다. 응답의 첫 줄은 상태를 나타내며 HTTP 버전과 응답 코드, 응답 메시지 등으로 구성

# 웹으로 요청하기

- 앱에서 웹서버에 요청하는 방식은 표준 자바를 이용해 요청할 때와 크게 다르지 않습니다. 다만 스레드를 사용해야 한다는 점을 꼭 기억!

- 웹브라우저에서는 보통 웹페이지를 응답으로 받아 보여주지만 앱에서는 화면을 이미 보여주고 있으므로 데이터만 받아 화면에 있는 뷰에 데이터를 표시하는 경우가 많습니다.

- 앱에서 HTTP로 요청하고 응답을 받는 방법에 대해 알아봅시다.

<img src="웹요청">

<img src="클래스">


1. HttpURLConnection

- 자바에서 웹으로 요청하는 방식은 앱에서도 그대로 사용

- 표준 자바에서 HTTP 클라이언트를 만드는 가장 기본적인 방법은 HttpURLConnection 객체를 사용하는 것입니다. 화면에 버튼을 추가하고 버튼을 클릭했을 때 요청 스레드 객체를 하나 만들어 시작

```Java
requestBtn.setOnClickListener(new OnClickListener() {
  public void onClick(View v) {
    String urlStr = input01.getText().toString();
    
    ConnectThread thread = new ConnectThread(urlStr);
    thread.start();
  }
});
```

- 이 스레드 안에서는 웹으로 요청을 보내고 응답

- 스레드 안에 만들어진 request 메소드를 보면 HttpURLConnection 객체를 사용하고 있습니다. 먼저 사용자가 입력한 URL 정보를 이용해 URL 객체를 만들고 openConnection 메소드를 호출하면 HttpURLConnection 객체가 반환됩니다. 이 객체에 몇 가지 속성을 설정하고 getResponseCode 메소드를 호출하면 웹서버에 연결하고 응답을 받아줍니다.

- 연결이 만들어진 객체의 getInputStream 메소드를 호출하면 InputStream 객체를 참조할 수 있으며 이 객체로부터 응답 데이터를 읽어 들입니다.

```Java
URL url = new URL(urlStr);
HttpURLConnection conn = (HttpURLConnection)url.openConnection();
if (conn != null) {
    conn.setConnectTimeout(10000);
    conn.setRequestMethod("GET");
    conn.setDoInput(true);
    conn.setDoOutput(true);

    int resCode = conn.getResponseCode();
    BufferedReader reader = new BufferedReader(
                new InputStreamReader(conn.getInputStream())) ;
```

- BufferedReader 객체는 한 줄씩 읽어 들일 때 유용하게 사용할 수 있습니다.

1. 응답 데이터를 화면에 표시하기

- Request 메소드를 호출하여 응답 데이터를 읽어 들였다면 화면에 표시할 수 있습니다. 화면을 위한 XML 레이아웃에 TextView를 추가했었다면 이 텍스트뷰의 setText 메소드나 append 메소드를 호출하면 글자가 보이게 됩니다.

- 다만 스레드에서 응답을 받은 것이므로 핸들러를 반드시 이용해야 한다는 것을 잊으면 안됩니다.

```Java
final String output = request(urlStr);
handler.post(new Runnable() {
    public void run() {
        txtMsg.setText(output);
    }
});
```

- 인터넷 권한을 AndroidManifest.xml 파일 안에 추가하는 것도 잊지 말아야 합니다.

```Java
<uses-permission android:name="android.permission.INTERNET"></uses-permission>
```

1. MainActivity.java
```Java
package com.example.http;

import androidx.appcompat.app.AppCompatActivity;

import android.app.DownloadManager;
import android.os.Bundle;
import android.os.Handler;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

import static com.example.http.R.id.textView;

public class MainActivity extends AppCompatActivity {
    EditText editText;
    TextView textView;

    String urlStr;
    Handler handler = new Handler();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        editText = (EditText)findViewById(R.id.editText);
        textView = (TextView)findViewById(R.id.textView);

        Button button = (Button)findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                urlStr = editText.getText().toString();

                RequestThread thread = new RequestThread();
                thread.start();
            }
        });
    }

    class RequestThread extends Thread {
        public void run() {

            try {
                URL url = new URL(urlStr);

                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                if(conn != null) {
                    conn.setConnectTimeout(10000);
                    conn.setRequestMethod("GET");
                    conn.setDoInput(true);
                    conn.setDoOutput(true);

                    int resCode = conn.getResponseCode();
                    // 한줄씩 읽어드릴 수 있는 것이 BufferedReader!
                    BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                    String line = null;

                    while(true) {
                        line = reader.readLine();
                        if(line == null) {
                            break;
                        }

                        println(line);
                    }

                    reader.close();
                    conn.disconnect();
                }


            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public void println(final String data) {// 여기서 final 처리를 하니까 아래 data 변수 사용 가능. 그 이유는?
        handler.post(new Runnable() {
            @Override
            public void run() {
                textView.append(data + "\n");
            }
        });
    }
}
```

## Volley 사용하기

# Volley 사용하기

- 웹서버에 요청하고 응답을 받을 때는 HttpURLConnection을 사용

- 하지만 요청과 응답을 위한 코드의 양이 많은 데다가 스레드를 사용하면서 더 많은 코드를 넣어주게 됩니다. 그렇다면 코드의 양을 좀 더 적게 할 수 있는 방법은 없을까요?

- 안드로이드에서 제공하는 HTTP 라이브러리를 사용하면 쉽고 빠르게 네트워크 통신


<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-680452457">


1. Volley

- Volley 라이브러리는 웹 요청과 응답을 단순화시키기 위해 만들어진 라이브러리들 중의 하나

- 먼저 요청(Request) 객체를 만들고 이 요청 객체를 요청 큐(RequestQueue)라는 곳에 넣어주기만 하면 됩니다. 그러면 요청 큐가 알아서 웹서버에 요청하고 응답까지 받아 여러분이 사용할 수 있도록 지정된 메소드를 호출해줍니다.

- Volley 라이브러리를 사용할 때의 가장 큰 장점은 스레드를 신경 쓰지 않아도 된다는 것

1. Volley의 장점

- 네트워크 요청(Request) 우선 순위를 자동으로 관리한다.

- 동시에 여러 네트워크 요청을 할 수 있다.

- 요청을 할 때 Cache 적용 여부를 의식하지 않아도 된다. 

- 요청 큐가 내부에서 스레드를 만들고 웹서버에 요청하고 응답을 받고 나면 메인 스레드에서 결과를 처리할 수 있도록 만든 후 여러분이 설정한 리스너의 메소드를 호출해줍니다. 따라서 화면에 결과를 표시할 때 핸들러를 사용하지 않아도 됩니다.

1. Volley 사용하기

- Volley는 외부 라이브러리이므로 build.gradle(Module: app) 파일을 열고 dependencies 중괄호 안에 라이브러리 정보를 추가해줍니다.

```Java
implementation 'com.android.volley:volley:1.1.0'
```

- 라이브러리를 사용할 준비가 되면 AndroidManifest.xml 파일 안에 인터넷 권한을 추가하는 일도 잊지 않고 해줍니다.

```Java
<uses-permission android:name="android.permission.INTERNET" />
```

- 사용자가 버튼을 클릭했을 때 요청 객체를 만들고 요청 큐에 넣어줍니다. 요청 객체는 다음과 같이 StringRequest 클래스를 이용해 만들 수 있습니다. 문자열을 주고받기 위해 사용하는 요청 객체이며 Volley 라이브러리 안에는 이외에도 다른 유형의 요청 객체가 몇 가지 제공됩니다. 일반적으로는 StringRequest 클래스만으로도 충분합니다.

```Java
StringRequest request = new StringRequest(
        Request.Method.GET,
        url,
        new Response.Listener<String>() {
            @Override
            public void onResponse(String response) {
                println("응답 -> " + response);

                processResponse(response);
            }
        },
        new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
                println("에러 -> " + error.getMessage());
            }
        }
) {
    @Override
    protected Map<String, String> getParams() throws AuthFailureError {
        Map<String,String> params = new HashMap<String,String>();

        return params;
    }
};
```

1. 요청 객체를 new 연산자로 만들 때는 네 개의 파라미터를 전달

- 첫 번째 파라미터로는 GET 또는 POST 메소드를 전달합니다. 요청 방식을 지정하는 것

- 두 번째 파라미터로는 웹서버의 URL 정보를 전달

- 세 번째는 리스너 객체인데 응답을 성공적으로 받았을 때 이 리스너의 onResponse 메소드를 자동으로 호출

- 네 번째는 에러가 발생했을 때 호출될 리스너 객체

- 만약 POST 방식에서 전달할 요청 파라미터가 있다면 getParams 메소드에서 반환하는 HashMap 객체에 넣어줍니다. 이렇게 만든 요청 객체는 요청 큐에 넣어주는 것만 해주면 됩니다.

```Java
AppHelper.requestQueue.add(request);
```

- 요청 큐는 앱이 시작되었을 때 초기화되어 있기만 하면 되고 한 번 만들어두면 계속 사용할 수 있습니다. 따라서 Application 클래스를 정의하고 앱에 등록하여 사용하는 경우에는 이 Application 클래스 안에 넣어둘 수도 있고 AppHelper와 같은 별도의 클래스를 만들어 그 안에 넣어둘 수도 있습니다. AppHelper 클래스 안에는 static 키워드를 이용해 앱의 어느 곳에서도 접근할 수 있도록 만들어줍니다.

```Java
public class AppHelper {
    public static RequestQueue requestQueue;
}
```

1. MainActivity.java
```Java
package com.example.volley2;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import com.android.volley.AuthFailureError;
import com.android.volley.Request;
import com.android.volley.Response;
import com.android.volley.VolleyError;
import com.android.volley.toolbox.StringRequest;
import com.android.volley.toolbox.Volley;

import java.util.HashMap;
import java.util.Map;

public class MainActivity extends AppCompatActivity {
    TextView textView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView)findViewById(R.id.textView);

        Button button = (Button)findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                // Volley는 외부 라이브러리 사용 -> implementation 'com.android.volley:volley:1.1.0'
                sendRequest();
            }
        });

        if (AppHelper.requestQueue == null) {
            AppHelper.requestQueue = Volley.newRequestQueue(getApplicationContext());
        }

    }

    public void sendRequest() {
        String url = "https://www.google.co.kr";// 우리는 영화진흥위원회 오픈API 주소 사용!

        StringRequest request = new StringRequest(
                Request.Method.GET,
                url,
                new Response.Listener<String>() {
                    @Override
                    public void onResponse(String response) {
                        println("응답 -> " + response);
                    }
                },
                new Response.ErrorListener() {
                    @Override
                    public void onErrorResponse(VolleyError error) {
                        println("에러 -> " + error.getMessage());
                    }
                }

        ) {
            @Override
            protected Map<String, String> getParams() throws AuthFailureError {
                Map<String,String> params = new HashMap<String,String>();

                return params;
            }
        };

        request.setShouldCache(false);// 이전 결과가 있더라도 새로 요청
        AppHelper.requestQueue.add(request);
        println("요청보냄.");
    }

    public void println(String data) {
        textView.setText(data);
    }

}
```

## JSON 이해하기

# JSON 이해하기

- 웹서버로부터 응답을 받았을 때 응답 데이터의 포맷이 JSON이라는 포맷으로 되어 있는 경우가 많습니다.

- 예전에는 XML인 경우도 있고 다른 포맷으로 된 경우도 있었으나 요즘에는 JSON이 대부분

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-681587016">

1. JSON 

- JSON은 자바스크립트 객체 포맷의 데이터를 주고받을 때 사용할 수 있도록 만든 것입니다.

- 자바스크립트 객체 포맷과 거의 동일

- 약간의 차이가 있는데 문자열 형식으로 표현하면서 속성의 이름과 문자열에 큰따옴표를 사용한다는 점

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-681587475">

- 자바스크립트 객체는 중괄호({, })를 이용해 만들 수 있습니다. JSON 포맷에서도 마찬가지죠. 그리고 객체 안에는 여러 개의 속성이 들어갈 수 있습니다. 속성은 속성 이름과 속성 값이 콜론(:)으로 구분됩니다.

- 즉, 콜론 뒤에 값이 들어갈 수 있는데 문자열이나 숫자와 같은 기본 자료형의 값이 올 수도 있고 객체가 올 수도 있습니다. 만약 객체가 온다면 콜론 뒤에 다시 중괄호가 오게 됩니다.

- 만약 여러 개의 객체가 들어있는 배열을 넣어두고 싶다면 대괄호([, ])를 사용

- 응답 데이터는 문자열 형식으로 받게 됩니다. 그리고 JSON 포맷으로 되어 있죠. 응답 데이터는 한 줄로 표시되지만 크롬 브라우저에서 JSONView와 같은 확장프로그램(Extension)을 설치하면 위와 같이 예쁜 모양으로 보여줄 수 있습니다.

- 응답 데이터는 하나의 객체로 되어 있으며 그 객체 안에 boxOfficeResult라는 속성이 들어가 있습니다. 이 속성의 값은 다시 객체여서 중괄호가 다시 시작됩니다. 그 안에는 boxOfficeType과 showRange 그리고 dailyBoxOfficeList라는 이름의 속성이 들어가 있습니다. 그 중에 dailyBoxOfficeList 속성의 값은 배열이라 대괄호로 된 값이 들어가 있습니다. 그 배열 안에 들어가 있는 각각의 객체가 하나의 영화 정보입니다.

# Gson 사용하기

- JSON으로 받은 응답 데이터는 문자열로 되어 있으므로 그 응답 데이터 중에서 특정 속성의 값을 찾아내려면 문자열 처리를 해주어야 합니다. 

- 어떤 객체 안에 들어있는 속성을 찾아내기 위해 중괄호나 콜론, 콤마 등을 이용해야 하는 거죠. 따라서 indexOf나 substring과 같은 메소드들이 사용되고 아주 복잡하고 많은 양의 코드가 만들어지게 됩니다.

- 그런데 자바스크립트에서는 JSON 문자열을 자바스크립트 객체로 만드는 것이 메소드 호출 하나로 끝

- 자바에서도 이렇게 할 수는 없을까요?

- Gson을 사용하면 한 줄의 코드만으로도 JSON 문자열을 자바 객체로 바꾸어줄 수 있습니다.

1. Gson

- Gson은 JSON 문자열을 객체로 변환해 주는 라이브러리. 즉, JSON 문자열이 자바 객체로 만들어질 수 있습니다.

- Volley를 이용해 웹서버로부터 JSON 응답을 받았다면 Gson을 이용해 자바 객체로 바꾸고 그 객체 안에 들어있는 데이터를 사용하게 됩니다.

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-681587957">

- Gson은 외부라이브러리이어서 build.gradle(Module: app) 파일을 열고 dependencies의 중괄호 안에 다음 코드를 추가해야 사용할 수 있습니다.

```Java
implementation 'com.google.code.gson:gson:2.8.2'
```

- 자바스크립트는 객체의 포맷이 객체 안에 속성들이 들어가 있는 구조를 가지고 있지만 자바의 객체는 그런 구조가 아니라서 JSON 문자열을 자바 객체로 변환하기 위해서는 먼저 자바 클래스를 정의

- 자바 클래스는 일종의 붕어빵 틀이고 이 틀에서 각각의 붕어빵을 만들어낼 수 있기 때문에 JSON 문자열에 들어있는 속성들에 맞추어 붕어빵 틀을 먼저 정의해야 자동 변환이 가능

1. JSON 문자열의 속성에 맞는 자바 클래스 정의

- 영화진흥위원회에서 제공하는 영화 정보 JSON에 맞추어 자바 객체를 만들고 싶다면 먼저 자바 클래스를 정의

```Java
public class MovieList {
    MovieListResult boxOfficeResult;
}
```

- 여기에서 배열 안에 들어가는 Movie 객체는 다음과 같이 영화 정보를 담을 변수들을 포함

```Java
public class Movie {
    String rnum;
    String rank;
    String rankInten;
    String rankOldAndNew;
    String movieCd;
    String movieNm;
    String openDt;
    String salesAmt;
    String salesShare;
    String salesInten;
    String salesChange;
    String salesAcc;
    String audiCnt;
    String audiInten;
    String audiChange;
    String audiAcc;
    String scrnCnt;
    String showCnt
}
```

1. Gson으로 변환하기

- 자바 클래스를 정의했다면 Gson을 이용해 변환

```Java
Gson gson = new Gson();
MovieList movieList = gson.fromJson(response, MovieList.class);
```

1. Volley 프로젝트 그대로 사용

1. MainActivity에 추가된 코드
```Java
// sendRequest 메서드
String url = "https:/www.kobis.or.kr/kobisopenapi/webservice/rest/boxoffice/searchDailyBoxOfficeList.json?key=430156241533f1d058c603178cc3ca0e&targetDt=20120101";
        // JSON이라는 자바스크립트 문자열 객체로 넘어오면 우리는 GSON을 이용해 자바에서 알아들을 수 있게 바꿔준다!

// OnResponse 메서드
processResponse(response);

// processResponse 메서드 생성
public void processResponse(String response) {
        Gson gson = new Gson();
        MovieList movieList = gson.fromJson(response, MovieList.class);

        if(movieList != null) {
            int countMovie = movieList.boxOfficeResult.dailyBoxOfficeList.size();
            println("박스오피스 타입 : " + movieList.boxOfficeResult.boxofficeType);
            println("응답받은 영화 갯수 : " + countMovie);
        }
    }

```

## 이미지 다운로드하기

# 이미지 다운로드

- 웹서버에 데이터를 요청하고 응답을 받아 처리하는 과정을 해보았습니다. 그런데 응답으로 받을 데이터가 이미지 파일인 경우에는 조금 다른 방식으로 처리할 필요

- 왜냐하면 이미지 파일 하나의 크기가 1메가바이트가 넘는 경우가 많아지면서 이미지 파일을 다른 데이터와 구분하여 받는 방식이 더 효율적

- 따라서 이미지 파일에 대한 정보만 응답 데이터에 넣어두고 이미지 파일은 별도로 다운로드

1. 이미지 다운로드

- 이미지 파일이 웹서버의 어디에 위치하고 있는지에 대한 정보를 받았다면 그 파일을 다운로드

- 인터넷을 사용해야 하므로 인터넷 권한을 추가하고 스레드를 사용

- 직접 코드를 만들지 않고 외부 라이브러리를 사용하는 경우도 많습니다. UniversalImageLoader와 같은 외부 라이브러리는 간단하게 이미지를 다운로드할 수 있도록 도와줍니다. 하지만 여기에서는 직접 이미지를 다운로드하는 코드를 만들어봅니다.

1. AsyncTask로 이미지 다운로드하기

- 스레드를 사용하기 위해 AsyncTask를 상속하여 새로운 클래스를 정의

- 이 클래스를 이용해 객체를 생성할 때는 이미지가 있는 주소와 함께 이 이미지를 다운로드받은 후 화면에 보여줄 때 사용할 이미지뷰(ImageView) 객체를 파라미터로 전달

```Java
public class ImageLoadTask extends AsyncTask<Void, Void, Bitmap> {
    private String urlStr;
    private ImageView imageView;

    public ImageLoadTask(String urlStr, ImageView imageView) {
        this.urlStr = urlStr;
        this.imageView = imageView;
    }
```

- 스레드 내에서 동작하는 doInBackground 메소드 안에서는 웹서버의 이미지 데이터를 받아 비트맵 객체로 만들어줍니다. BitmapFactory 클래스의 decodeStream 메소드를 사용하면 간단한 코드 만으로도 비트맵 객체를 만들어줄 수 있습니다.

```Java
@Override
protected Bitmap doInBackground(Void... voids) {
    Bitmap bitmap = null;
    try {
        URL url = new URL(urlStr);
        bitmap = BitmapFactory.decodeStream(url.openConnection().getInputStream());     } catch(Exception e) {
        e.printStackTrace();
  }

  return bitmap;
}
```

- 비트맵 객체로 변환하고 나면 메인 스레드에서 이미지뷰에 표시합니다.
onPostExecute 메소드 안에 다음과 같이 넣어줍니다.

```Java
@Override
protected void onPostExecute(Bitmap bitmap) {
    super.onPostExecute(bitmap);

    imageView.setImageBitmap(bitmap);
    imageView.invalidate();
}
```

1. 비트맵 객체의 메모리 해제

- 비트맵 객체는 메모리에 만들어진 후 해제되지 않으면 메모리에 계속 남아있게 됩니다.

- 사용하지 않는 비트맵 객체는 recycle 메소드를 이용해 즉시 해제시키는 것이 필요

-  이전 비트맵 객체를 메모리에서 해제한 후 새로 다운로드하는 방법으로 만들어봅니다. 클래스 안에 HashMap 객체를 만들고 이미지의 주소를 메모리에 만들어진 비트맵 객체와 매핑되도록 해 줍니다.

```Java
public class ImageLoadTask extends AsyncTask<Void, Void, Bitmap> {
    private String urlStr;
    private ImageView imageView;

    private static HashMap<String, Bitmap> bitmapHash = new HashMap<String, Bitmap>();
```

- 이미지 데이터를 이용해 비트맵 객체를 만들었을 때는 해시테이블에 그 객체를 추가합니다. 그리고 새로운 비트맵 객체를 만들기 전에는 항상 해시테이블 안에 동일한 주소를 요청하는 경우에 이전에 만들어졌던 비트맵 객체를 메모리에서 해제

```Java
@Override
protected Bitmap doInBackground(Void... voids) {
    Bitmap bitmap = null;
    try {
        if (bitmapHash.containsKey(urlStr)) {
            Bitmap oldBitmap = bitmapHash.remove(urlStr);
            if (oldBitmap != null) {
                oldBitmap.recycle();
                oldBitmap = null;
            }
        }

        URL url = new URL(urlStr);
        bitmap = BitmapFactory.decodeStream(url.openConnection().getInputStream());

        bitmapHash.put(urlStr, bitmap);
    } catch(Exception e) {
        e.printStackTrace();
    }

    return bitmap;
}
```

1. Main Activity에 추가된 코드
```Java

// 이미지뷰와 버튼2 만들어준 다음

// sendImageRequest 메서드 생성
public void sendImageRequest() {
        String url = "https://img.cgv.co.kr/Movie/Thumbnail/Poster/000083/83381/83381_1000.jpg";

        ImageLoadTask task = new ImageLoadTask(url, imageView);
        task.execute();
    }

```

1. ImageLoadTask.java
```Java
package com.example.volley2;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.AsyncTask;
import android.widget.ImageView;

import java.net.URL;
import java.util.HashMap;

// 이미지를 인터넷 혹은 웹 서버에서 받아와서 비트맵으로 바꾼 다음에 이미지 뷰에 설정하는 방법
public class ImageLoadTask extends AsyncTask<Void, Void, Bitmap> {
    private String urlStr;
    private ImageView imageView;

    // 해쉬태그로 요청 url과 비트맵 객체를 맵핑해놓는 것
    private static HashMap<String, Bitmap> bitmapHash = new HashMap<String, Bitmap>();

    public ImageLoadTask(String urlstr, ImageView imageView) {
            this.urlStr = urlstr;
            this.imageView = imageView;
    }

    @Override
    protected void onPreExecute() {
        super.onPreExecute();
    }

    @Override
    protected Bitmap doInBackground(Void... voids) {
        Bitmap bitmap = null;

        try {
            if (bitmapHash.containsKey(urlStr)) {
                Bitmap oldBitmap = bitmapHash.remove(urlStr);
                if(oldBitmap != null) {
                    oldBitmap.recycle();
                    oldBitmap = null;
                }
            }

            URL url = new URL(urlStr);
            // 주소로 접속해서 스트림을 받는데, 이것이 이미지 스트림이면 그대로 넘어오고 decodeStream을 통해 비트맵으로 바꿔주는 것
            bitmap = BitmapFactory.decodeStream(url.openConnection().getInputStream());

            // 지금 현재 만든 것을 해쉬에 저장. 그래야 다음번에 요청할 때 이전에 만들었던 건 없어져 버림.
            bitmapHash.put(urlStr, bitmap);

        } catch(Exception e) {
            e.printStackTrace();
        }

        // 여기서 리턴해주는 값은 onPostExecute로 넘어감
        return bitmap;
    }

    @Override
    protected void onProgressUpdate(Void... values) {
        super.onProgressUpdate(values);
    }

    @Override
    protected void onPostExecute(Bitmap bitmap) {
        super.onPostExecute(bitmap);

        imageView.setImageBitmap(bitmap);
        imageView.invalidate();
    }
}

```

## 영화 API

# 영화 API

- 영화 API는 안드로이드 앱에서 영화 정보를 요청하고 응답 받아 사용할 수 있도록 웹서버에 만들어 둔 API

- 영화 API는 JSON으로 응답을 보내줍니다. 따라서 Volley를 이용해 요청하고 Gson을 이용해 응답을 자바 객체로 바꾼 후 화면에 표시하면 됩니다.

1. 영화 API

- 여러분이 프로젝트를 진행하기 위해서는 미리 만들어둔 웹서버의  영화 목록, 영화 상세, 영화 이미지 등을 제공하는 API를 사용하여야 합니다. 

- 참고로 이번 코스에서는 서버 쪽의 코드를 직접 만들지는 않기 때문에 미리 만들어둔 서버의 API를 제공하는 것입니다. 영화 API를 요청할 때의 웹서버 주소와 포트 정보는 다음과 같습니다.

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-682239200">

1. 영화 목록 요청하기

- http://boostcourse-appapi.connect.or.kr:10000/movie/readMovieList?type=1

- 응답은 JSON 문자열이며 응답 코드와 응답 메시지를 포함하고 있습니다. result 속성의 값은 배열로 되어 있고 배열 안에는 영화 정보가 각각의 객체로 들어가 있습니다.

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-682239313">

1. 영화 상세 요청하기

- id라는 요청 파라미터에  영화 id 값을 지정할 수 있습니다.
다음은 샘플 URL입니다.

- http://boostcourse-appapi.connect.or.kr:10000/movie/readMovie?id=1

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-682239385">

1. 한줄평 목록과 한줄평 저장

- 한줄평 목록을 조회하거나 한줄평을 저장할 수 있습니다. 한줄평 목록을 조회할 때는 다음과 같은 요청 패스를 사용합니다. /movie/readCommentList

- 한줄평을 저장하거나 기타 다른 기능을 사용하고 싶다면 영화 API 문서를 참조하기 바랍니다.

1. 이미지 다운로드

- 영화 목록이나 영화 상세 데이터에 포함되어 있는 이미지 주소는 이미지를 다운로드 받을 때 사용됩니다. 예를 들어 웹브라우저에 이미지의 주소를 입력하면 영화 포스터 사진을 볼 수 있습니다.

## 내용정리

1. MainActivity.java
```Java
package com.example.movieapi;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import com.android.volley.Request;
import com.android.volley.RequestQueue;
import com.android.volley.Response;
import com.android.volley.VolleyError;
import com.android.volley.toolbox.StringRequest;
import com.android.volley.toolbox.Volley;
import com.example.movieapi.data.MovieInfo;
import com.example.movieapi.data.MovieList;
import com.example.movieapi.data.Responseinfo;
import com.google.gson.Gson;

public class MainActivity extends AppCompatActivity {
    TextView textView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView)findViewById(R.id.textView);

        Button button = (Button)findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                requestMoveList();
            }
        });

        if (AppHelper.requestQueue == null) {
            AppHelper.requestQueue = Volley.newRequestQueue(getApplicationContext());
        }

    }
    // 우선! volley, gson 라이브러리를 gradle에 추가!!
    public void requestMoveList() {
        String url = "http://" + AppHelper.host + ":" + AppHelper.port + "/movie/readMovieList";
        url += "?" + "type=1";

        StringRequest request = new StringRequest(
                Request.Method.GET,
                url,
                new Response.Listener<String>() {
                    @Override
                    public void onResponse(String response) {
                        println("응답 받음 -> " + response);

                        // 이제 여기서 Gson을 이용해서 응답을 자바 객체로 바꿀 수 있도록 그렇게 한번 정의를 해보자.
                        processResponse(response);
                    }
                },
                new Response.ErrorListener() {
                    @Override
                    public void onErrorResponse(VolleyError error) {
                        println("에러 발생 -> " + error.getMessage());
                    }
                }
        );

        request.setShouldCache(false);
        AppHelper.requestQueue.add(request);
        println("영화목록 요청 보냄");
    }

    public void processResponse(String response) {
        Gson gson = new Gson();

        Responseinfo info = gson.fromJson(response, Responseinfo.class);
        // 응답이 정상인지 확인
        if(info.code == 200){
            // 이때, 아까 Responseinfo에서 파싱해주지 않았던 것을 파싱!
            MovieList movieList = gson.fromJson(response, MovieList.class);
            println("영화 갯수 : " + movieList.result.size());

            for (int i=0; i<movieList.result.size(); i++){
                MovieInfo movieInfo = movieList.result.get(i);
                println("영화 #" + i + " -> " + movieInfo.id + ", " + movieInfo.title + ", " + movieInfo.grade);
            }

            // 여기서 생각을 해보면, 파싱해온 형태를 adapter의 ArrayList의 형태와 동일하게 해주면 바로 넣어주기만 하면 됨.
            // 액티비티상에서 구현했으므로 이를 메서드를 통해 프래그먼트로 보내줘서 사용!
        }
    }

    public void println(String data) {
        textView.append(data + "\n");
    }

}
```

1. Responseinfo.java
```Java
package com.example.movieapi.data;
/*

message: "movie readMovieList 성공",
code: 200,
resultType: "list",
result:

 */
public class Responseinfo {

    public String message;
    public int code;
    public String resultType;
    // 여기까지만 파싱!
}

```

1. MovieList.java
```Java
package com.example.movieapi.data;

import java.util.ArrayList;

public class MovieList {

    public ArrayList<MovieInfo> result = new ArrayList<MovieInfo>();


}

```

1. MovieInfo.java
```Java
package com.example.movieapi.data;
/*
id: 1,
title: "꾼",
title_eng: "The Swindlers",
date: "2017-11-22",
user_rating: 4.1,
audience_rating: 8.36,
reviewer_rating: 4.33,
reservation_rate: 61.69,
reservation_grade: 1,
grade: 15,
thumb: "http://movie2.phinf.naver.net/20171107_251/1510033896133nWqxG_JPEG/movie_image.jpg?type=m99_141_2",
image: "http://movie.phinf.naver.net/20171107_251/1510033896133nWqxG_JPEG/movie_image.jpg"
 */
public class MovieInfo {
    // public 붙여서 다른 패키지에서도 사용할 수 있도록!
    public int id;
    public String title;
    public String title_eng;
    public String date;
    public float user_rating;
    public float audience_rating;
    public float reviewer_rating;
    public int reservation_grade;
    public int grade;
    public String thumb;
    public String image;

}

```

- 추가적으로 Manifest의 Application 안에 아래의 코드 추가
- 인터넷 접근, volley, gson을 위한 코드 각각 추가

```Java
android:usesCleartextTraffic="true"

<uses-permission android:name="android.permission.INTERNET"/>

implementation 'com.android.volley:volley:1.1.0'
implementation 'com.google.code.gson:gson:2.8.2'
```

## 프로젝트5 시작