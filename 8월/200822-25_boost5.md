### 네이버_부스트코스_5

## 스레드 이해하기

# 스레드 사용하기

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616202">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616226">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616269">


<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616304">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616333">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616346">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616368">

1. 스레드와 핸들러

- 스레드는 동시 작업을 위한 한 단위

- 앱을 실행하면 하나의 스레드가 시작되는데 이것을 메인 스레드

- 바로 앱의 기본 실행을 담당

- 새로 만든 스레드는 메인 스레드와 별개로 실행될 수 있고 독립적인 실행이 가능하기 때문에 자주 사용

- 표준 자바를 공부했다면 안드로이드에서 스레드가 동작하는 방식은 표준 자바와 동일하다고 할 수 있습니다. 다만, 한 가지 차이점이 있는데 메인 스레드에서 관리하는 UI 구성요소를 접근할 때는 핸들러가 반드시 사용되어야 한다는 점

- 그 이유는 UI나 파일과 같은 리소스는 여러 개의 스레드가 동시에 접근했을 때 시스템에서 어떤 것을 먼저 처리해야 하는지 모르는 문제가 발생할 수 있기 때문, 이 때문에 핸들러라는 것이 만들어져 있습니다.

- 핸들러는 각각의 스레드 안에 만들어질 수 있고 다른 스레드에서 요청하는 정보를 순서대로 실행시켜 줄 수 있기 때문에 리소스에 대한 동시 접근의 문제를 해결

1. 핸들러 사용

- 스레드에서 핸들러로 메시지를 보내려면 Message 객체를 사용

- Message 객체를 obtainMessage 메소드로 참조한 후 sendMessage 메시지를 이용해 핸들러로 보내면 handleMessage 메소드가 자동으로 호출되기 때문에 전달된 Message 객체를 처리. 이 때 handleMessage 메소드는 메인 스레드에서 실행

1. Post 메소드 호출

- 핸들러의 post 메소드를 호출하면 Runnable 객체를 전달

- 핸들러로 전달된 Runnable, 객체는 메인 스레드에서 실행될 수 있으며 따라서 UI를 접근하는 코드는 Runnable 객체 안에 넣어두면 됩니다.

```Java
handler.post(new Runnable {
    public void run() {
    ...
    }
);
```

- post 메소드 이외에도 지정된 시간에 실행하는 postAtTime 메소드와 지정된 시간만큼 딜레이된 시간후 실행되는 postDelayed 메소드가 있습니다.

1. MainActivity.java

```Java
package com.example.thread;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

public class MainActivity extends AppCompatActivity {
    TextView textView;

    //int value = 0;

    ValueHandler handler = new ValueHandler();

    Handler handler2 = new Handler();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.textView);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //BackgroundThread thread = new BackgroundThread();
                //thread.start();

                // 위의 클래스를 정의해주는 방법 대신 이렇게 할 수도 있다.
               new Thread(new Runnable() {
                   int value = 0;
                   boolean running = false;

                    @Override
                    public void run() {
                        running = true;
                        while(running) {
                            value += 1;

                            handler2.post(new Runnable() {
                                @Override
                                public void run() {
                                    textView.setText("현재 값 : " + value);// 이 안에서 이제 UI 접근 가능!
                                    // 왜냐하면 이 부분은 메인 스레드에서 실행되기 때문에
                                }
                            });

                            try {
                                Thread.sleep(1000);
                            } catch (Exception e) {};
                        }

                    }
                }).start();
            }
        });

        Button button2 = (Button) findViewById(R.id.button2);
        button2.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //textView.setText("현재 값 : " + value);
            }
        });
    }

    class BackgroundThread extends Thread {
        int value = 0;
        boolean running = false;

        public void run() {
            running = true;
            while(running) {
                value += 1;
                // 이 쓰레드에서 위의 소스에 접근 불가. 메인 스레드만 가능 -> 핸들러 사용 필요
                // textView.setText("현재 값 : " + value); -> 이렇게 넣어주면 사용할 수 없다.

                Message  message = handler.obtainMessage();
                Bundle bundle = new Bundle();
                bundle.putInt("value",value);
                message.setData(bundle);
                handler.sendMessage(message);

                try {
                    Thread.sleep(1000);
                } catch (Exception e) {};

            }
        }
    }

    class ValueHandler extends Handler {
        @Override
        public void handleMessage(@NonNull Message msg) {
            super.handleMessage(msg);

            Bundle bundle = msg.getData();
            int value = bundle.getInt("value");
            textView.setText("현재 값 : " + value);
        }
    }
}
```

# AsyncTask 사용하기

- AsyncTask는 하나의 클래스 안에 스레드로 동작하는 부분과 UI 객체에 접근하는 부분을 함께 넣어둘 수 있도록 합니다. 이 때문에 스레드를 사용하는 하나의 작업 단위가 하나의 클래스로 만들어질 수 있죠.

1. AsyncTask 사용

- 핸들러를 사용하는 코드가 복잡하게 느껴지는 이유는 어떤 코드는 스레드 안에서 실행되고 어떤 코드는 UI를 접근하기 위해 핸들러 안에서 실행되어야 한다는 것을 구분해야 한다는 것 때문

- 이런 혼란스러운 면을 조금이라도 줄일 수 있도록 AsyncTask에서는 하나의 클래스 안에서 스레드 안에 넣을 코드와 UI를 접근할 코드를 모두 넣어둘 수 있도록 했습니다.

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678723395">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678723416">

- 스레드 안에서 실행될 코드는 doInBackground 메소드 안에 넣어두고 UI를 접근할 코드는 onPreExecute, onProgressUpdate, onPostExecute에 넣어둘 수 있습니다.

- AsyncTask도 스레드를 실행하는 것과 같기 때문에 스레드 안에서 실행될 대부분의 코드는 doInBackground 안에 들어가 있게 되며 중간중간 화면에 표시하기 위한 코드 실행을 위해 onProgressUpdate 메소드가 호출

- onProgressUpdate 메소드는 doInBackground 메소드 안에서 publishProgress 메소드가 호출 될 때 마다 자동으로 호출

1. MainActivity.java 에 추가된 코드!

```Java
ProgressTask task = new ProgressTask();
                task.execute("시작");
```

```Java
class ProgressTask extends AsyncTask<String, Integer, Integer> {
        int value = 0;

        @Override
        protected Integer doInBackground(String... strings) {// 처리되는 코드
            while(true) {
                if(value > 30){
                    break;
                }

                value += 1;

                publishProgress(value);// 바로 밑의 메서드가 실행

                try {
                    Thread.sleep(1000);
                } catch (Exception e) {};
            }

            return value;
        }

        @Override
        protected void onProgressUpdate(Integer... values) {// 핸들러에서 실행을 하듯이 UI 업데이트 하는데 문제가 없음
            super.onProgressUpdate(values);

            textView.setText(values[0].toString());
        }

        @Override
        protected void onPostExecute(Integer integer) {// 마지막 완료시 실행
            super.onPostExecute(integer);

            Toast.makeText(getApplicationContext(),"완료됨", Toast.LENGTH_SHORT).show();
        }
    }
```

## 소켓 사용하기

# 소켓 사용하기

- IP 주소를 이용해 목적지 호스트를 찾아내고 포트를 이용해 통신 접속점을 찾아내는 소켓 연결에 대해 알아보고 나면 네트워킹이 무엇인지 좀 더 잘 이해될 것입니다.

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678895130">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678895336">

- 파이프가 연결되어 있다고 생각하면 쉽다. 

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678895396">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678895446">

- 우리는 실습시 2개의 프로젝트에 각각 클라이언트 소켓과 서버 소켓을 구현해볼 것이다.

1. 소켓

- 소켓은 서버 소켓과 클라이언트 소켓을 만들고 서로 연결하는 과정을 거치게 됩니다. 서버 소켓은 연결을 기다리는 역할을 하고 클라이언트 소켓은 연결을 만드는 역할을 합니다. 클라이언트에서 연결을 만들고 나면 데이터를 보내거나 받을 수 있습니다. 서버 소켓을 사용하기 위하여 간단한 안드로이드 서버 앱을 만들어 봅니다.
안드로이드 스튜디오에서 프로젝트를 만들고 서버 소켓을 만듭니다.

1. 서버 소켓

- ServerSocket 클래스를 이용해 객체를 만들고 accept 함수를 호출하면 클라이언트로부터의 접속을 기다리게 됩니다.

```Java
int portNumber = 5001; 
            System.out.println("Starting Java Socket Server ..."); 
 
            ServerSocket aServerSocket = new ServerSocket(portNumber);
            System.out.println("Listening at port " + portNumber + " ...");
 
            while(true) {
                Socket sock = aServerSocket.accept();
```

- 클라이언트 소켓을 기다릴 때는 blocking mode로 동작하므로 프로그램이 대기하게 됩니다. 그리고 accept 메소드 이후의 코드는 클라이언트가 접속했을 때 동작합니다.
이 때문에 while 문을 사용하는 경우가 많습니다.

1. 데이터 보내고 받기

- 데이터를 보내고 받는 가장 간단한 방법은 ObjectOutputStream과 ObjectInputStream을 사용하는겁니다. ObjectOutputStream 객체를 만들고 writeObject 메소드를 이용해 데이터를 보냅니다. 이때 전송하려는 객체(데이터)는 직렬화(Serialization) 되어 있어야 합니다.

```Java
ObjectOutputStream outstream = new ObjectOutputStream(sock.getOutputStream());
outstream.writeObject(obj + " from Server.");
outstream.flush();
```

- ObjectInputStream 객체를 만들고 readObject 메소드를 이용해 데이터를 읽어 들일 수 있습니다.

```Java
ObjectInputStream instream = new ObjectInputStream(sock.getInputStream());
Object obj = instream.readObject();
System.out.println("Input : " + obj);
```

1. 클라이언트 소켓

- Socket 클래스는 클라이언트 소켓을 만들 때 사용합니다. 클라이언트 소켓을 만들 때는 서버의 IP와 포트 번호를 전달해야 하는데, 서버에서 지정한 포트 번호와 동일한 포트 번호를 사용해야 합니다.

```Java
int portNumber = 5001;
Socket sock = new Socket("localhost", portNumber);
```
1. 버튼 클릭 시에 서버에 요청하기

- 앱의 XML 레이아웃에 버튼을 하나 추가하고 버튼을 클릭했을 때 서버에 요청합니다.
서버 소켓을 만들어 두었으므로 클라이언트 소켓을 만들어 접속하면 됩니다. 단, 안드로이드에서는 인터넷을 사용할 때 스레드를 이용해야 하며 INTERNET 권한이 있어야 합니다.

```Java
button01.setOnClickListener(new OnClickListener() {
    public void onClick(View v) {
        String addr = input01.getText().toString().trim();
        ConnectThread thread = new ConnectThread(addr)
        thread.start();
    }
});
```

- 권한은 AndroidManifest.xml 파일에 추가합니다.

```Java
<uses-permission android:name="android.permission.INTERNET"></uses-permission>
```

- 서버 소켓에서 요청을 보내고 응답을 받을 때 사용했던 코드는 클라이언트 소켓에 동일하게 사용될 수 있습니다.

1. MainActivity.java (MyServer)
```Java
package com.example.server;

import androidx.appcompat.app.AppCompatActivity;

import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //ServerTread thread = new ServerTread();
                //thread.start();

                // 액티비티로 만들면 언제든 종료될 수 있으므로 서비스로 만들어 실행하는 것이 더 안정적이다.
                Intent intent = new Intent(getApplicationContext(),ChatService.class);
                startService(intent);

            }
        });
    }
    /*
    class ServerTread extends Thread {
        public void run() {
            int port = 5001;// 클라이언트가 이 포트 번호로 접속을 해야 함

            try {
                ServerSocket server = new ServerSocket(port);
                Log.d("SeverThread", "서버가 실행됨.");

                while(true) {
                    Socket socket = server.accept();// 대기 상태로 있다가 클라이언트가 접속하면 소켓 객체가 리턴

                    // 클라이언트로부터 데이터를 받음
                    ObjectInputStream instream = new ObjectInputStream(socket.getInputStream());// 들어오는 데이터를 처리. 스트림은 일종의 파이프
                    Object input = instream.readObject();
                    Log.d("ServerThread", "input : " + input);

                    // 클라이언트로 데이터를 보냄
                    ObjectOutputStream outstream = new ObjectOutputStream(socket.getOutputStream());
                    outstream.writeObject(input + "from server.");
                    outstream.flush();
                    Log.d("ServerThread", "output 보냄.");

                    socket.close();// 더 이상 연결을 유지할 필요가 없으면 끊어줘야한다.
                }

            } catch (Exception e){
                e.printStackTrace();
            }
        }
    }
    */
}
```

1. ChatService.java (MyServer)
```Java
package com.example.server;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;
import android.util.Log;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class ChatService extends Service {
    public ChatService() {
    }

    @Override
    public void onCreate() {
        super.onCreate();

        ServerTread thread = new ServerTread();
        thread.start();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
    }

    @Override
    public IBinder onBind(Intent intent) {
        throw new UnsupportedOperationException("Not yet implemented");
    }

    class ServerTread extends Thread {
        public void run() {
            int port = 5001;// 클라이언트가 이 포트 번호로 접속을 해야 함

            try {
                ServerSocket server = new ServerSocket(port);
                Log.d("SeverThread", "서버가 실행됨.");

                while(true) {
                    Socket socket = server.accept();// 대기 상태로 있다가 클라이언트가 접속하면 소켓 객체가 리턴

                    // 클라이언트로부터 데이터를 받음
                    ObjectInputStream instream = new ObjectInputStream(socket.getInputStream());// 들어오는 데이터를 처리. 스트림은 일종의 파이프
                    Object input = instream.readObject();
                    Log.d("ServerThread", "input : " + input);

                    // 클라이언트로 데이터를 보냄
                    ObjectOutputStream outstream = new ObjectOutputStream(socket.getOutputStream());
                    outstream.writeObject(input + "from server.");
                    outstream.flush();
                    Log.d("ServerThread", "output 보냄.");

                    socket.close();// 더 이상 연결을 유지할 필요가 없으면 끊어줘야한다.
                }

            } catch (Exception e){
                e.printStackTrace();
            }
        }
    }
}

```

1. MainActivity.java (MySocket)
```Java
package com.example.socket;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;

public class MainActivity extends AppCompatActivity {
    TextView textView;

    Handler handler = new Handler();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.textView);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                ClientThread thread = new ClientThread();
                thread.start();
            }
        });
    }

    class ClientThread extends Thread {
        public void run() {
            String host = "localhost";
            int port = 5001;

            try {
                Socket socket = new Socket(host, port);

                ObjectOutputStream outstream = new ObjectOutputStream(socket.getOutputStream());
                outstream.writeObject("안녕!");
                outstream.flush();
                Log.d("ClientThread", "서버로 보냄.");

                ObjectInputStream instream = new ObjectInputStream(socket.getInputStream());
                final Object input = instream.readObject();
                Log.d("ClientThread","받은 데이터 : " + input);

                handler.post(new Runnable() {
                    @Override
                    public void run() {
                        textView.setText("받은 데이터 : " + input);
                    }
                });

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

## 웹으로 요청하기

# HTTP 이해하기

- 웹브라우저에서 서버에 연결하고 웹페이지를 받아 와 화면에 보여줄 때 사용하는 것이 HTTP이기 때문에 인터넷에서 웹페이지를 요청하고 응답으로 받을 때는 HTTP를 사용한다고 생각하면 쉽습니다.

- HTTP도 앞에서 만들어보았던 소켓을 기반으로 동작

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-679440773">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-679440835">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-679440901">

- HTTP 는 소켓이라고 하는 연결 위에서 데이터가 왔다갔다 하는 포맷을 정의한 것

- 코드가 복잡하고 다 넣어줄 수 없으므로 우리는 라이브러리를 사용하여 이를 처리한다.


1. HTTP 요청과 응답

- 웹서버는 HTTP 요청을 받아 처리

- 웹브라우저와 같은 클라이언트는 웹서버에 연결을 만든 후 요청을 보내고 응답을 받아 화면에 보여주게 됩니다. 요청을 받거나 응답을 줄 때는 HTTP라는 국제표준에 맞는 포맷으로 주고받게 됩니다.

- 데이터를 주고받을 때의 포맷을 보면, 헤더(Header)와 바디(Body)로 구분되고 헤더에 어떤 것들이 들어갈 수 있는지가 표준으로 정해져 있습니다. 그리고 바디에는 보내고 받기 위한 대상 데이터를 넣어둘 수 있습니다.

1. 요청 포맷

- HTTP 요청 포맷을 보면, 첫 번째 줄이 기본적인 요청 정보를 포함하고 있습니다.
GET이나 POST와 같은 요청 방식(Method), 요청 패스 그리고 HTTP 버전 등

1. 응답 포맷

- 응답 포맷은 요청 포맷과 크게 다르지 않습니다. 헤더와 바디로 구분되고 헤더에는 한 줄씩 속성이 들어갑니다. 응답의 첫 줄은 상태를 나타내며 HTTP 버전과 응답 코드, 응답 메시지 등으로 구성

# 웹으로 요청하기

- 앱에서 웹서버에 요청하는 방식은 표준 자바를 이용해 요청할 때와 크게 다르지 않습니다. 다만 스레드를 사용해야 한다는 점을 꼭 기억!

- 웹브라우저에서는 보통 웹페이지를 응답으로 받아 보여주지만 앱에서는 화면을 이미 보여주고 있으므로 데이터만 받아 화면에 있는 뷰에 데이터를 표시하는 경우가 많습니다.

- 앱에서 HTTP로 요청하고 응답을 받는 방법에 대해 알아봅시다.

<img src="웹요청">

<img src="클래스">


1. HttpURLConnection

- 자바에서 웹으로 요청하는 방식은 앱에서도 그대로 사용

- 표준 자바에서 HTTP 클라이언트를 만드는 가장 기본적인 방법은 HttpURLConnection 객체를 사용하는 것입니다. 화면에 버튼을 추가하고 버튼을 클릭했을 때 요청 스레드 객체를 하나 만들어 시작

```Java
requestBtn.setOnClickListener(new OnClickListener() {
  public void onClick(View v) {
    String urlStr = input01.getText().toString();
    
    ConnectThread thread = new ConnectThread(urlStr);
    thread.start();
  }
});
```

- 이 스레드 안에서는 웹으로 요청을 보내고 응답

- 스레드 안에 만들어진 request 메소드를 보면 HttpURLConnection 객체를 사용하고 있습니다. 먼저 사용자가 입력한 URL 정보를 이용해 URL 객체를 만들고 openConnection 메소드를 호출하면 HttpURLConnection 객체가 반환됩니다. 이 객체에 몇 가지 속성을 설정하고 getResponseCode 메소드를 호출하면 웹서버에 연결하고 응답을 받아줍니다.

- 연결이 만들어진 객체의 getInputStream 메소드를 호출하면 InputStream 객체를 참조할 수 있으며 이 객체로부터 응답 데이터를 읽어 들입니다.

```Java
URL url = new URL(urlStr);
HttpURLConnection conn = (HttpURLConnection)url.openConnection();
if (conn != null) {
    conn.setConnectTimeout(10000);
    conn.setRequestMethod("GET");
    conn.setDoInput(true);
    conn.setDoOutput(true);

    int resCode = conn.getResponseCode();
    BufferedReader reader = new BufferedReader(
                new InputStreamReader(conn.getInputStream())) ;
```

- BufferedReader 객체는 한 줄씩 읽어 들일 때 유용하게 사용할 수 있습니다.

1. 응답 데이터를 화면에 표시하기

- Request 메소드를 호출하여 응답 데이터를 읽어 들였다면 화면에 표시할 수 있습니다. 화면을 위한 XML 레이아웃에 TextView를 추가했었다면 이 텍스트뷰의 setText 메소드나 append 메소드를 호출하면 글자가 보이게 됩니다.

- 다만 스레드에서 응답을 받은 것이므로 핸들러를 반드시 이용해야 한다는 것을 잊으면 안됩니다.

```Java
final String output = request(urlStr);
handler.post(new Runnable() {
    public void run() {
        txtMsg.setText(output);
    }
});
```

- 인터넷 권한을 AndroidManifest.xml 파일 안에 추가하는 것도 잊지 말아야 합니다.

```Java
<uses-permission android:name="android.permission.INTERNET"></uses-permission>
```

1. MainActivity.java
```Java
package com.example.http;

import androidx.appcompat.app.AppCompatActivity;

import android.app.DownloadManager;
import android.os.Bundle;
import android.os.Handler;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

import static com.example.http.R.id.textView;

public class MainActivity extends AppCompatActivity {
    EditText editText;
    TextView textView;

    String urlStr;
    Handler handler = new Handler();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        editText = (EditText)findViewById(R.id.editText);
        textView = (TextView)findViewById(R.id.textView);

        Button button = (Button)findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                urlStr = editText.getText().toString();

                RequestThread thread = new RequestThread();
                thread.start();
            }
        });
    }

    class RequestThread extends Thread {
        public void run() {

            try {
                URL url = new URL(urlStr);

                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                if(conn != null) {
                    conn.setConnectTimeout(10000);
                    conn.setRequestMethod("GET");
                    conn.setDoInput(true);
                    conn.setDoOutput(true);

                    int resCode = conn.getResponseCode();
                    // 한줄씩 읽어드릴 수 있는 것이 BufferedReader!
                    BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                    String line = null;

                    while(true) {
                        line = reader.readLine();
                        if(line == null) {
                            break;
                        }

                        println(line);
                    }

                    reader.close();
                    conn.disconnect();
                }


            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public void println(final String data) {// 여기서 final 처리를 하니까 아래 data 변수 사용 가능. 그 이유는?
        handler.post(new Runnable() {
            @Override
            public void run() {
                textView.append(data + "\n");
            }
        });
    }
}
```

## 