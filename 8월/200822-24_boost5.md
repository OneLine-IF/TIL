### 네이버_부스트코스_5

## 스레드 이해하기

# 스레드 사용하기

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616202">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616226">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616269">


<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616304">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616333">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616346">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616368">

1. 스레드와 핸들러

- 스레드는 동시 작업을 위한 한 단위

- 앱을 실행하면 하나의 스레드가 시작되는데 이것을 메인 스레드

- 바로 앱의 기본 실행을 담당

- 새로 만든 스레드는 메인 스레드와 별개로 실행될 수 있고 독립적인 실행이 가능하기 때문에 자주 사용

- 표준 자바를 공부했다면 안드로이드에서 스레드가 동작하는 방식은 표준 자바와 동일하다고 할 수 있습니다. 다만, 한 가지 차이점이 있는데 메인 스레드에서 관리하는 UI 구성요소를 접근할 때는 핸들러가 반드시 사용되어야 한다는 점

- 그 이유는 UI나 파일과 같은 리소스는 여러 개의 스레드가 동시에 접근했을 때 시스템에서 어떤 것을 먼저 처리해야 하는지 모르는 문제가 발생할 수 있기 때문, 이 때문에 핸들러라는 것이 만들어져 있습니다.

- 핸들러는 각각의 스레드 안에 만들어질 수 있고 다른 스레드에서 요청하는 정보를 순서대로 실행시켜 줄 수 있기 때문에 리소스에 대한 동시 접근의 문제를 해결

1. 핸들러 사용

- 스레드에서 핸들러로 메시지를 보내려면 Message 객체를 사용

- Message 객체를 obtainMessage 메소드로 참조한 후 sendMessage 메시지를 이용해 핸들러로 보내면 handleMessage 메소드가 자동으로 호출되기 때문에 전달된 Message 객체를 처리. 이 때 handleMessage 메소드는 메인 스레드에서 실행

1. Post 메소드 호출

- 핸들러의 post 메소드를 호출하면 Runnable 객체를 전달

- 핸들러로 전달된 Runnable, 객체는 메인 스레드에서 실행될 수 있으며 따라서 UI를 접근하는 코드는 Runnable 객체 안에 넣어두면 됩니다.

```Java
handler.post(new Runnable {
    public void run() {
    ...
    }
);
```

- post 메소드 이외에도 지정된 시간에 실행하는 postAtTime 메소드와 지정된 시간만큼 딜레이된 시간후 실행되는 postDelayed 메소드가 있습니다.

1. MainActivity.java

```Java
package com.example.thread;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

public class MainActivity extends AppCompatActivity {
    TextView textView;

    //int value = 0;

    ValueHandler handler = new ValueHandler();

    Handler handler2 = new Handler();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.textView);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //BackgroundThread thread = new BackgroundThread();
                //thread.start();

                // 위의 클래스를 정의해주는 방법 대신 이렇게 할 수도 있다.
               new Thread(new Runnable() {
                   int value = 0;
                   boolean running = false;

                    @Override
                    public void run() {
                        running = true;
                        while(running) {
                            value += 1;

                            handler2.post(new Runnable() {
                                @Override
                                public void run() {
                                    textView.setText("현재 값 : " + value);// 이 안에서 이제 UI 접근 가능!
                                    // 왜냐하면 이 부분은 메인 스레드에서 실행되기 때문에
                                }
                            });

                            try {
                                Thread.sleep(1000);
                            } catch (Exception e) {};
                        }

                    }
                }).start();
            }
        });

        Button button2 = (Button) findViewById(R.id.button2);
        button2.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //textView.setText("현재 값 : " + value);
            }
        });
    }

    class BackgroundThread extends Thread {
        int value = 0;
        boolean running = false;

        public void run() {
            running = true;
            while(running) {
                value += 1;
                // 이 쓰레드에서 위의 소스에 접근 불가. 메인 스레드만 가능 -> 핸들러 사용 필요
                // textView.setText("현재 값 : " + value); -> 이렇게 넣어주면 사용할 수 없다.

                Message  message = handler.obtainMessage();
                Bundle bundle = new Bundle();
                bundle.putInt("value",value);
                message.setData(bundle);
                handler.sendMessage(message);

                try {
                    Thread.sleep(1000);
                } catch (Exception e) {};

            }
        }
    }

    class ValueHandler extends Handler {
        @Override
        public void handleMessage(@NonNull Message msg) {
            super.handleMessage(msg);

            Bundle bundle = msg.getData();
            int value = bundle.getInt("value");
            textView.setText("현재 값 : " + value);
        }
    }
}
```

# AsyncTask 사용하기

- AsyncTask는 하나의 클래스 안에 스레드로 동작하는 부분과 UI 객체에 접근하는 부분을 함께 넣어둘 수 있도록 합니다. 이 때문에 스레드를 사용하는 하나의 작업 단위가 하나의 클래스로 만들어질 수 있죠.

1. AsyncTask 사용

- 핸들러를 사용하는 코드가 복잡하게 느껴지는 이유는 어떤 코드는 스레드 안에서 실행되고 어떤 코드는 UI를 접근하기 위해 핸들러 안에서 실행되어야 한다는 것을 구분해야 한다는 것 때문

- 이런 혼란스러운 면을 조금이라도 줄일 수 있도록 AsyncTask에서는 하나의 클래스 안에서 스레드 안에 넣을 코드와 UI를 접근할 코드를 모두 넣어둘 수 있도록 했습니다.

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678723395">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678723416">

- 스레드 안에서 실행될 코드는 doInBackground 메소드 안에 넣어두고 UI를 접근할 코드는 onPreExecute, onProgressUpdate, onPostExecute에 넣어둘 수 있습니다.

- AsyncTask도 스레드를 실행하는 것과 같기 때문에 스레드 안에서 실행될 대부분의 코드는 doInBackground 안에 들어가 있게 되며 중간중간 화면에 표시하기 위한 코드 실행을 위해 onProgressUpdate 메소드가 호출

- onProgressUpdate 메소드는 doInBackground 메소드 안에서 publishProgress 메소드가 호출 될 때 마다 자동으로 호출

1. MainActivity.java 에 추가된 코드!

```Java
ProgressTask task = new ProgressTask();
                task.execute("시작");
```

```Java
class ProgressTask extends AsyncTask<String, Integer, Integer> {
        int value = 0;

        @Override
        protected Integer doInBackground(String... strings) {// 처리되는 코드
            while(true) {
                if(value > 30){
                    break;
                }

                value += 1;

                publishProgress(value);// 바로 밑의 메서드가 실행

                try {
                    Thread.sleep(1000);
                } catch (Exception e) {};
            }

            return value;
        }

        @Override
        protected void onProgressUpdate(Integer... values) {// 핸들러에서 실행을 하듯이 UI 업데이트 하는데 문제가 없음
            super.onProgressUpdate(values);

            textView.setText(values[0].toString());
        }

        @Override
        protected void onPostExecute(Integer integer) {// 마지막 완료시 실행
            super.onPostExecute(integer);

            Toast.makeText(getApplicationContext(),"완료됨", Toast.LENGTH_SHORT).show();
        }
    }
```

## 소켓 사용하기

# 소켓 사용하기

- IP 주소를 이용해 목적지 호스트를 찾아내고 포트를 이용해 통신 접속점을 찾아내는 소켓 연결에 대해 알아보고 나면 네트워킹이 무엇인지 좀 더 잘 이해될 것입니다.

<img src="네트워킹">

<img src="소켓 사용하기">

- 파이프가 연결되어 있다고 생각하면 쉽다. 

<img src="주의할 점">

<img src="소켓 클라이언트">

- 우리는 실습시 2개의 프로젝트에 각각 클라이언트 소켓과 서버 소켓을 구현해볼 것이다.

1. 소켓

- 소켓은 서버 소켓과 클라이언트 소켓을 만들고 서로 연결하는 과정을 거치게 됩니다. 서버 소켓은 연결을 기다리는 역할을 하고 클라이언트 소켓은 연결을 만드는 역할을 합니다. 클라이언트에서 연결을 만들고 나면 데이터를 보내거나 받을 수 있습니다. 서버 소켓을 사용하기 위하여 간단한 안드로이드 서버 앱을 만들어 봅니다.
안드로이드 스튜디오에서 프로젝트를 만들고 서버 소켓을 만듭니다.

1. 서버 소켓

- ServerSocket 클래스를 이용해 객체를 만들고 accept 함수를 호출하면 클라이언트로부터의 접속을 기다리게 됩니다.

```Java
int portNumber = 5001; 
            System.out.println("Starting Java Socket Server ..."); 
 
            ServerSocket aServerSocket = new ServerSocket(portNumber);
            System.out.println("Listening at port " + portNumber + " ...");
 
            while(true) {
                Socket sock = aServerSocket.accept();
```

- 클라이언트 소켓을 기다릴 때는 blocking mode로 동작하므로 프로그램이 대기하게 됩니다. 그리고 accept 메소드 이후의 코드는 클라이언트가 접속했을 때 동작합니다.
이 때문에 while 문을 사용하는 경우가 많습니다.

1. 데이터 보내고 받기

- 데이터를 보내고 받는 가장 간단한 방법은 ObjectOutputStream과 ObjectInputStream을 사용하는겁니다. ObjectOutputStream 객체를 만들고 writeObject 메소드를 이용해 데이터를 보냅니다. 이때 전송하려는 객체(데이터)는 직렬화(Serialization) 되어 있어야 합니다.

```Java
ObjectOutputStream outstream = new ObjectOutputStream(sock.getOutputStream());
outstream.writeObject(obj + " from Server.");
outstream.flush();
```

- ObjectInputStream 객체를 만들고 readObject 메소드를 이용해 데이터를 읽어 들일 수 있습니다.

```Java
ObjectInputStream instream = new ObjectInputStream(sock.getInputStream());
Object obj = instream.readObject();
System.out.println("Input : " + obj);
```

1. 클라이언트 소켓

- Socket 클래스는 클라이언트 소켓을 만들 때 사용합니다. 클라이언트 소켓을 만들 때는 서버의 IP와 포트 번호를 전달해야 하는데, 서버에서 지정한 포트 번호와 동일한 포트 번호를 사용해야 합니다.

```Java
int portNumber = 5001;
Socket sock = new Socket("localhost", portNumber);
```
1. 버튼 클릭 시에 서버에 요청하기

- 앱의 XML 레이아웃에 버튼을 하나 추가하고 버튼을 클릭했을 때 서버에 요청합니다.
서버 소켓을 만들어 두었으므로 클라이언트 소켓을 만들어 접속하면 됩니다. 단, 안드로이드에서는 인터넷을 사용할 때 스레드를 이용해야 하며 INTERNET 권한이 있어야 합니다.

```Java
button01.setOnClickListener(new OnClickListener() {
    public void onClick(View v) {
        String addr = input01.getText().toString().trim();
        ConnectThread thread = new ConnectThread(addr)
        thread.start();
    }
});
```

- 권한은 AndroidManifest.xml 파일에 추가합니다.

```Java
<uses-permission android:name="android.permission.INTERNET"></uses-permission>
```

- 서버 소켓에서 요청을 보내고 응답을 받을 때 사용했던 코드는 클라이언트 소켓에 동일하게 사용될 수 있습니다.

##