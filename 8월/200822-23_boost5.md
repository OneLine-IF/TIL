### 네이버_부스트코스_5

## 스레드 이해하기

# 스레드 사용하기

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616202">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616226">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616269">


<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616304">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616333">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616346">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678616368">

1. 스레드와 핸들러

- 스레드는 동시 작업을 위한 한 단위

- 앱을 실행하면 하나의 스레드가 시작되는데 이것을 메인 스레드

- 바로 앱의 기본 실행을 담당

- 새로 만든 스레드는 메인 스레드와 별개로 실행될 수 있고 독립적인 실행이 가능하기 때문에 자주 사용

- 표준 자바를 공부했다면 안드로이드에서 스레드가 동작하는 방식은 표준 자바와 동일하다고 할 수 있습니다. 다만, 한 가지 차이점이 있는데 메인 스레드에서 관리하는 UI 구성요소를 접근할 때는 핸들러가 반드시 사용되어야 한다는 점

- 그 이유는 UI나 파일과 같은 리소스는 여러 개의 스레드가 동시에 접근했을 때 시스템에서 어떤 것을 먼저 처리해야 하는지 모르는 문제가 발생할 수 있기 때문, 이 때문에 핸들러라는 것이 만들어져 있습니다.

- 핸들러는 각각의 스레드 안에 만들어질 수 있고 다른 스레드에서 요청하는 정보를 순서대로 실행시켜 줄 수 있기 때문에 리소스에 대한 동시 접근의 문제를 해결

1. 핸들러 사용

- 스레드에서 핸들러로 메시지를 보내려면 Message 객체를 사용

- Message 객체를 obtainMessage 메소드로 참조한 후 sendMessage 메시지를 이용해 핸들러로 보내면 handleMessage 메소드가 자동으로 호출되기 때문에 전달된 Message 객체를 처리. 이 때 handleMessage 메소드는 메인 스레드에서 실행

1. Post 메소드 호출

- 핸들러의 post 메소드를 호출하면 Runnable 객체를 전달

- 핸들러로 전달된 Runnable, 객체는 메인 스레드에서 실행될 수 있으며 따라서 UI를 접근하는 코드는 Runnable 객체 안에 넣어두면 됩니다.

```Java
handler.post(new Runnable {
    public void run() {
    ...
    }
);
```

- post 메소드 이외에도 지정된 시간에 실행하는 postAtTime 메소드와 지정된 시간만큼 딜레이된 시간후 실행되는 postDelayed 메소드가 있습니다.

1. MainActivity.java

```Java
package com.example.thread;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

public class MainActivity extends AppCompatActivity {
    TextView textView;

    //int value = 0;

    ValueHandler handler = new ValueHandler();

    Handler handler2 = new Handler();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.textView);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //BackgroundThread thread = new BackgroundThread();
                //thread.start();

                // 위의 클래스를 정의해주는 방법 대신 이렇게 할 수도 있다.
               new Thread(new Runnable() {
                   int value = 0;
                   boolean running = false;

                    @Override
                    public void run() {
                        running = true;
                        while(running) {
                            value += 1;

                            handler2.post(new Runnable() {
                                @Override
                                public void run() {
                                    textView.setText("현재 값 : " + value);// 이 안에서 이제 UI 접근 가능!
                                    // 왜냐하면 이 부분은 메인 스레드에서 실행되기 때문에
                                }
                            });

                            try {
                                Thread.sleep(1000);
                            } catch (Exception e) {};
                        }

                    }
                }).start();
            }
        });

        Button button2 = (Button) findViewById(R.id.button2);
        button2.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //textView.setText("현재 값 : " + value);
            }
        });
    }

    class BackgroundThread extends Thread {
        int value = 0;
        boolean running = false;

        public void run() {
            running = true;
            while(running) {
                value += 1;
                // 이 쓰레드에서 위의 소스에 접근 불가. 메인 스레드만 가능 -> 핸들러 사용 필요
                // textView.setText("현재 값 : " + value); -> 이렇게 넣어주면 사용할 수 없다.

                Message  message = handler.obtainMessage();
                Bundle bundle = new Bundle();
                bundle.putInt("value",value);
                message.setData(bundle);
                handler.sendMessage(message);

                try {
                    Thread.sleep(1000);
                } catch (Exception e) {};

            }
        }
    }

    class ValueHandler extends Handler {
        @Override
        public void handleMessage(@NonNull Message msg) {
            super.handleMessage(msg);

            Bundle bundle = msg.getData();
            int value = bundle.getInt("value");
            textView.setText("현재 값 : " + value);
        }
    }
}
```

# AsyncTask 사용하기

- AsyncTask는 하나의 클래스 안에 스레드로 동작하는 부분과 UI 객체에 접근하는 부분을 함께 넣어둘 수 있도록 합니다. 이 때문에 스레드를 사용하는 하나의 작업 단위가 하나의 클래스로 만들어질 수 있죠.

1. AsyncTask 사용

- 핸들러를 사용하는 코드가 복잡하게 느껴지는 이유는 어떤 코드는 스레드 안에서 실행되고 어떤 코드는 UI를 접근하기 위해 핸들러 안에서 실행되어야 한다는 것을 구분해야 한다는 것 때문

- 이런 혼란스러운 면을 조금이라도 줄일 수 있도록 AsyncTask에서는 하나의 클래스 안에서 스레드 안에 넣을 코드와 UI를 접근할 코드를 모두 넣어둘 수 있도록 했습니다.

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678723395">

<img src="https://github.com/OneLine-IF/TestLab/issues/2#issuecomment-678723416">

- 스레드 안에서 실행될 코드는 doInBackground 메소드 안에 넣어두고 UI를 접근할 코드는 onPreExecute, onProgressUpdate, onPostExecute에 넣어둘 수 있습니다.

- AsyncTask도 스레드를 실행하는 것과 같기 때문에 스레드 안에서 실행될 대부분의 코드는 doInBackground 안에 들어가 있게 되며 중간중간 화면에 표시하기 위한 코드 실행을 위해 onProgressUpdate 메소드가 호출

- onProgressUpdate 메소드는 doInBackground 메소드 안에서 publishProgress 메소드가 호출 될 때 마다 자동으로 호출

1. MainActivity.java 에 추가된 코드!

```Java
ProgressTask task = new ProgressTask();
                task.execute("시작");
```

```Java
class ProgressTask extends AsyncTask<String, Integer, Integer> {
        int value = 0;

        @Override
        protected Integer doInBackground(String... strings) {// 처리되는 코드
            while(true) {
                if(value > 30){
                    break;
                }

                value += 1;

                publishProgress(value);// 바로 밑의 메서드가 실행

                try {
                    Thread.sleep(1000);
                } catch (Exception e) {};
            }

            return value;
        }

        @Override
        protected void onProgressUpdate(Integer... values) {// 핸들러에서 실행을 하듯이 UI 업데이트 하는데 문제가 없음
            super.onProgressUpdate(values);

            textView.setText(values[0].toString());
        }

        @Override
        protected void onPostExecute(Integer integer) {// 마지막 완료시 실행
            super.onPostExecute(integer);

            Toast.makeText(getApplicationContext(),"완료됨", Toast.LENGTH_SHORT).show();
        }
    }
```

##