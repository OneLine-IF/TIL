## 알고리즘 중간고사 대비 정리
### 2주차
- ADT(Abstract Data Types) -> 연산과 계산등이 쓰여짐, 어떻게 구동되는지에 포커스를 맞춘 것, 가장 기본적인 방식에 초점을 맞춘 것, 적용에 대한 데이터 타입은 실제 구현할 때 씀 
- 자료구조는 이러한 ADT의 실질적인 적용 모델임
- 큐 -> rear에서 데이터를 추가하면 front에서 데이터를 삭제함, First In First Out(FIFO)형태
- Week2-1 20페이지부터 의사코드 및 구현(실습), 짠 코드 참조 
- 원형 큐 -> Q[1]이 Q[n]을 따르게 됨, 마치 꼬리물기 하는 형태로 자료구조가 형성됨 + 원래의 큐 형태에서 로직이 조금 더 추가됨 
- Deques -> front에서 추가 삭제, rear에서 추가 삭제 둘 다 할 수 있는 형태의 자료구조 기존의 큐에서 추가와 삭제가 양방향에서 모두 가능한 형태임
- 우선순위 큐 -> 요소들이 우선순위가 할당된 자료구조, 요소는 order가 결정되어 있음, 우선순위가 높은 요소가 먼저 실행됨, first-come-first-served를 기반으로 한 형태임
- 우선순위 큐 만일 정렬이 되었다면 O(n)의 시간이 추가하는데 걸리고 O(1)의 시간이 삭제하는데 걸리지만, 정렬이 되어 있지 않다면 O(1)의 시간이 추가하는데 걸리고 O(n)의 시간이 삭제하는데 걸림 
- 하지만 이와 같은 방식은 비효율적이여서 이 두 방법을 혼합하여서 O(logn)의 시간이 걸리곤 함
- 연결리스트로 구현 가능, 데이터 파트 + 우선순위 파트 + 다음 요소를 가르키는 주소
- 우선순위가 같을 경우 추가되어 있는 데이터 뒤에 추가되고 우선순위가 있을 경우 추가하려는 우선순위보다 더 낮은 우선순위 앞에 추가된다
- 위의 의사코드와 구현을 보면서 코딩, 짠 코드 참조

### 3주차
- 정렬은 내림차순이던 오름차순이던 순서에 맞춰서 정렬을 시행하는 것임, 효율적인 정렬은 다른 알고리즘에서도 최적화해서 쓸 수 있어야 함 
- 정렬 알고리즘 수행시 고려해야할 부분 -> 수행되어야 할 정렬의 키 값에 대한 비교수, 리스트가 움직인 횟수, 최상의 경우, 최악의 경우, 평균수행의 경우, 정렬 후에도 위치를 정렬하고 있는 안정성
- 삽입정렬 -> 하나의 요소로 정렬을 한번에 함, 각각의 요소를 적절한 위치에 삽입하면서 리스트를 정렬함, 현재 데이터를 움직일 때 이전의 값은 이미 정렬되었고 반복적으로 정확한 위치를 찾을 때까지 자리를 교환하면서 반복함
- 삽입정렬은 퀵정렬, 힙정렬, 합병정렬보다도 덜 효율적임,
- Week3 17페이지 의사코드 구현(실습), 짠 코드 참조 
- 삽입 정렬은 이미 정렬된 상태라면 최상의 경우로 나타남 이 경우 시간복잡도는 O(n)이 걸림, 반복문에서 첫 요소는 정렬되지 않은 것만 비교하면 되기 때문임 
- 최악의 경우는 하려던 정렬과 반대로 정렬되었을 경우 나타남 이 경우 각각의 반복을 정렬을 하고 그 다음에 삽입을 하기 때문에 오래 걸려 O(n^2)의 시간이 걸림
- 작은 데이터 집단이나 이미 정렬된 경우 유용함, 메모리를 덜 차지함
- 선택정렬 -> O(n^2)의 시간이 걸리므로 큰 리스트에서는 비효율적임, 삽입정렬보다 비효율적이지만 단순함 때문에 알아두면 좋음 
- 가장 작은 값을 찾아서 첫번째 위치에 둔 후 두 번째로 작은 값을 찾아 두번째 위치에 둔다 이와 같은 방식을 반복하여 정렬함 
- 이를 위해서 모든 배열을 확인한다 그러므로 (n-1)+(n-2)+...+2+1=n(n-1)/2가 걸리는데 즉 O(n^2)의 시간이 걸림
- 큐의 실용적인 사용 -> First-Come-First-Served Scheduling, Gantt chart, Shortest-Job-First Scheduling(SJF), Preemption and SJF Scheduling, Priority Scheduling, Starvation and Aging, Round-Robin Scheduling

### 4주차
- 힙은 트리에 기반한 자료구조임, 우선순위 큐의 개념을 적용한 힙이 있음 -> 이진힙
- Full binary tree -> 각각의 노드가 리프노드이거나 2개의 자식노드가 있는 경우, Complete binary tree -> 모든 리프노드가 같은 레벨에 있고 모든 내부노드가 자식노드가 2개인 것
- Height of a node -> 해당 노드로부터 leaf까지 가는데의 길이, Level of a node -> root에서 해당 노드까지 가는데의 길이, Height of tree -> 루트노드의 height
- 이진트리는 최대 2^l의 노드를 l의 레벨에서 가지고 있음, 이진트리의 높이가 d이면 2^(d+1)-1의 노드를 가짐, 이진트리가 n개의 노드를 가지면 최소 log_2(n)의 높이를 가짐
- 힙은 nearly complete binary tree임, 모든 level은 다 차 있음 left에서 right로 차 있는 하나를 제외하고, 차수가 존재함
- 힙은 차수로 채워진 이진트리임 Parent(x)>=x
- 만약 B가 A의 자식이면 key(A)>=key(B)가 됨, 이것은 모든 노드의 요소들에게 해당이 됨
- 키 값이 매우 큰 값이면 max-heap, 키 값이 매우 작은 값이면 min-heap임
- 힙은 complete binary tree 형태이므로 i의 요소가 있으면 왼쪽 자식은 2i, 오른쪽 자식은 2i+1이 됨, 여기서 i의 부모는 i/2가 됨
- Max-heaps A[Parent(i)]>=A[i], Min-heaps A[Parent(i)]<=A[i]임 
- 힙 삽입, 삭제, 최대힙 구현, 힙 정렬, 의사코드 구현, 짠 코드 참조 

### 5주차
- 버블정렬 -> 가장 큰 값을 높은 인덱스값에 반복적으로 옮기면서 시행하는 정렬임, 대소관계를 계속해서 확인하면서 위치를 교환함 
- 버블정렬 의사코드 구현 및 실습, 짠 코드 참조 
- 버블정렬 역시 지속적으로 반복 및 움직임을 수행하므로 (n-1)+(n-2)+(n-3)+...+3+2+1의 반복을 함 f(n)=n(n-1)/2, n^2/2+O(n)=O(n^2)의 시간복잡도를 가지게 됨 
- 좀 더 효율적 사용을 위해서 이미 정렬된 케이스를 조건을 통해서 제어함, 의사코드 구현 및 실습, 짠 코드 참조 
- 합병정렬 -> Divide, Conquer, Combine 3가지를 전략을 사용함
- Divide는 n개의 요소가 있다면 이것은 서브로 n/2로 나눔 A의 행렬이 A1,A2 A의 값을 포함한 것으로 나뉘게됨 
- Conquer 두 개로 쪼개진 행렬을 재귀를 사용하여 mergesort를 사용하여 합침 
- Combine 두 개로 쪼개진 행렬을 정렬된 하나의 행렬로 합침 
- 이미 정렬된 상태로써 큰 리스트를 잘게 쪼개어서 합치는 과정에서 정렬을 시행하면서 시간 및 복잡도를 절약함 
- 두개로 쪼개진 행렬을 하나의 정렬된 행렬로 합치는 것이 포인트 
- 의사코드 구현, 짠 코드 참조
- O(nlogn)의 시간복잡도를 가짐, 효율적인 알고리즘이더라도 임시로 쓸 행렬로 인해 추가적인 공간이 필요하므로 O(n)의 시간이 더 필요함 
- 퀵정렬 -> 일반적으로 O(nlogn)의 시간복잡도를 가진 알고리즘임 n개의 요소를 정렬한다고 했을 경우
- 합병정렬과 마찬가지로 divide-and-conquer전략을 사용함, 정렬되지 않은 한 행렬을 두 개의 서브 행렬로 나눔 
- 이를 위해서 하나의 pivot값을 정함, pivot을 기준으로 적은 값은 그 앞에 큰 값은 그 뒤로 정렬하는 분할을 시행함, 이와 같은 방식을 재귀적으로 반복함 
- 이와 같이 정렬과 바꾸는 것을 반복시행하여 정렬을 완료함
- 의사코드 구현, 짠 코드 참조 
- Radix Sort -> 숫자던, 문자던 buckets이라고 생각하고 숫자면 1의 자리수부터 정렬하고 그 다음 10의 자리로 정렬하는 식의 방식을 표현함 
- radix sort는 k번의 반복과 한 번 반복문 시행시 n번이 실행되므로 O(kn)의 시간복잡도를 가짐, 따라서 시간복잡도는 결과적으로 O(n)이 걸림 
- Shell Sort -> 행과열을 분할해서 행과 열에 맞춰서 반복적으로 정렬을 시행함 
- 의사코드 구현, 짠 코드 참조

### 6주차
- 이진트리 -> 루트와 왼쪽 서브트리, 오른쪽 서브트리로 구성되어 있음, 내부의 고유한 key값과 그와 연관된 value가 저장되어 있음 
- 이진탐색 -> key로 정렬된 구조에서 사전형식을 이용하여서 k의 값을 찾음, 각각의 과정마다 후보군을 절반으로 줄임, O(logn)과정 이후 없앰
- 탐색테이블 -> key에 의해서 정렬되어 있음, 이진탐색은 O(logn)이 걸림, 삽입과 제거는 O(n)이 걸림
- 이진탐색트리 -> 이진탐색트리는 key를 저장하고 있고 u,v,w가 있을 때 u가 v라는 왼쪽 서브트리와 w라는 오른쪽 서브트리를 가지고 있다면 key(u)<=key(v)<=key(w)의 대소관계가 성립됨 
- 이미 키 값이 정렬되어 있으므로 해당 키 값을 가지고 탐색을 쉽게 할 수 있음
- 트리 구현 및 삽입 삭제 탐색 의사코드 구현, 짠 코드 참조 
