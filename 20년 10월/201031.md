## 알고리즘 복습
- Splaying을 통해서 노트를 트리의 루트로 옮기고 이를 통해서 AVL 트리의 단점을 보완, 전체적으로 balanced한 상태로써 트리를 만들 수 있음
- 노드에 parent node, grandparent node 두 개 존재함 
- zig-zig, zig-zag 개념
<img src="https://user-images.githubusercontent.com/32586985/97772121-39d92880-1b87-11eb-8e79-9b660a03c373.PNG">

- x에서 6개의 로테이션 루틴이 있음 
	- Single Rotations(parent node가 root에 있고 grandparent node가 없는 경우)
	- ZigFromLeft, ZigFromRight
	- Double Rotation(parent node, grandparent node 둘 다 있는 경우)
	- ZigZigFromLeft, ZigZigFromRight, ZigZagFromLeft, ZigZagFromRight

- 그림으로 설명 
<img src="https://user-images.githubusercontent.com/32586985/97772159-a5bb9100-1b87-11eb-85b1-a8acc824d5e3.PNG">
<img src="https://user-images.githubusercontent.com/32586985/97772161-a9e7ae80-1b87-11eb-9d60-9f525d531f28.PNG">
<img src="https://user-images.githubusercontent.com/32586985/97772176-d3a0d580-1b87-11eb-983b-5fcf43b5524d.PNG">
<img src="https://user-images.githubusercontent.com/32586985/97772178-d7345c80-1b87-11eb-91e1-d9b9e4e5593a.PNG">

- 이러한 원리로 autobalance가 되면서 depth 역시 감소하고 root에 접근시 아무런 추가적인 연산이 필요하지 않음
- 위의 원리를 이용하여서 내가 원하는 노드에 접근시 위와 같이 로테이션을 하면 됨 

- Insert
- 만일 self-adjustment가 없는 경우에는 O(n^2)에 아무 비율과 조건없이 한 줄로 쭉 삽입만 하게 됨 
- 위의 원리를 이용하게 되면 
<img src="https://user-images.githubusercontent.com/32586985/97772220-4611b580-1b88-11eb-9881-6378621ad556.PNG">
<img src="https://user-images.githubusercontent.com/32586985/97772222-4f028700-1b88-11eb-8bfb-0fea1697d720.PNG">

- Delete
- 삭제의 경우에도 Rotation의 원리를 그대로 적용
<img src="https://user-images.githubusercontent.com/32586985/97772232-68a3ce80-1b88-11eb-99dc-133c4544cf97.PNG">

- Find
- 기존의 주어진 트리에서 Splaying을 기본으로 시작하여서 탐색함
- 루트로 옮김으로써 탐색에 있어서 바로 루트값을 통해서 찾을 수 있음
<img src="https://user-images.githubusercontent.com/32586985/97772247-ad2f6a00-1b88-11eb-9911-942a116b6ce6.PNG">
<img src="https://user-images.githubusercontent.com/32586985/97772249-b02a5a80-1b88-11eb-98b8-0b13b4805462.PNG">
<img src="https://user-images.githubusercontent.com/32586985/97772251-b3bde180-1b88-11eb-82b7-34295933f86d.PNG">

- 이를 바탕으로 일반적으로 depth d인 경우, splay이후에 depth를 d/2로 줄일 수 있고 splaying 과정 자체에서 O(logn)의 시간복잡도가 걸림
- 기본적으로 위의 모든 원리를 BST의 원리를 바탕으로 node를 splay하는 과정임 

- 삽입의 경우 왼쪽 서브트리와 오른쪽 서브트리를 삽입하려는 값 기준으로 작은값들과 큰 값들로 나눈 뒤 삽입을 시행함
<img src="https://user-images.githubusercontent.com/32586985/97772305-334bb080-1b89-11eb-9be6-0c2bcb4800c7.PNG">

- 삭제의 경우 삭제할 노드를 찾아서 루트로 옮긴뒤 삭제한 뒤 왼쪽 서브트리에서 최대값을 찾은뒤 그 최대값을 기준으로 트리를 합침
<img src="https://user-images.githubusercontent.com/32586985/97772334-5ece9b00-1b89-11eb-9e85-ab1d9187e690.PNG">

- 아무것도 없는 상태에서는 M번의 operation이 있으므로 최대 O(Mlog(N))이 걸리게 됨, 모든 splay tree의 과정은 O(logn)이 걸림
- O(N)이 나타날 수는 있지만 Splaying 과정으로 인해서 거의 일어나지 않음
