## 알고리즘 중간고사 대비 정리
### 1주차
- 시간복잡도 측정시, 입력값 그리고 측정할 때의 입력값이 영향을 미친다 
- 연산등이 매 과정과 입력값의 사이즈에 따라서 측정이 된다
- 반복되는 값에 따라서 N번 반복한다고 할 시 이 값이 커지게 된다면 단순한 정수값들은 의미가 없어진다 
- 5N+3의 시간복잡도를 처음에 발견했다면 이 값은 N이 계속 커짐에 따라서 결국 시간복잡도는 N의 수렴하게 된다 
- 디테일 한 값은 무시하고 더 큰 부분에 대해서 집중하는 것이다 
- 입력값이 커진다면 차수가 더 작은 알고리즘이 차수가 큰 알고리즘보다 더 효율적일 것이다 
- 빅오 표기법 -> 낮은 차수의 요소를 떨구고 상수값도 떨군다 
- 입력 사이즈가 무엇인지가 중요하다 해당하는 N의 값이 
- int x = y와 같은 대입, 간단한 사칙연산, 배열 참조,할당, 대부분의 조건문은 단순하게 O(1)의 시간복잡도이다
- 반복문의 경우는 얼마나 반복을 하냐와 매 반복마다 어떤 연산이 시행되는가에 따라 다르다 
- EX) for(j=0;j<N;j++) sum = sum + j; -> N번 반복과 j=0,j++,sum=sum+j,sum+j등 4번의 연산 O(1)의 시간복잡도, 총 시간복잡도는 N*O(1)=O(N*1)=O(N)이 됨 
- EX) for(j=0;j<100;j++) sum = sum + j; -> 100번 반복과 위와 같이 4번 연산 다 상수 값에 수렴하므로 총 시간복잡도는 100*O(1)=O(100*1)=O(100)=O(1)이 됨 
- 이중 반복문의 경우는 각각의 반복문의 경우를 따져본다
```C
	int j,k;
	for(j=0;j<N;j++)
		for(k=N;k>0;k--)
			sum+=k+j;
```
- N번을 반복하고 각각의 반복에 내부 반복문은 O(N)의 반복을 한다, 즉 총 시간복잡도는 N*O(N)=O(N*N)=O(N^2)이 됨 
```C
	int j,k;
	for(j=0;j<N;j++)
		for(k=N;k>0;k--)
			sum+=k+j;
```
- 위와 같은 경우도 두 반복문이 덧셈연산을 같이 하므로 반복은 0+1+2...+(N-1)로 총 시간복잡도는 O(N^2)가 됨
- 만일 위와 같은 반복문이 연속된 사건으로 즉 각각되어 있다면 더해서 계산을 하면 된다
```C
	for(j=0;j<N;j++)
		for(k=0;k<j;k++)
			sum=sum+j*k // O(N^2)
	for(i=0;i<N;i++)
		sum=sum-i; // O(N)
	cout<<"Sum="<<sum; // O(1)
```
- 위의 예시를 보면 시간복잡도는 O(N^2)+O(N)+O(1)이 되는데 시간복잡도 계산에 따라서 결과적으로 시간복잡도는 O(N^2)가 됨
- 조건문의 경우 예를 들어 if문에서 시간복잡도가 O(N)이 걸리고 else문에서 시간복잡도가 O(N^2)가 나오게 된다면 이 경우 최악의 경우를 생각 N의 입력일 경우 최대 실행시간을 생각하므로 O(N^2)이 된다
