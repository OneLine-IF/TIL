## 알고리즘 복습
- Hashing
	- Hash table, hash map이라고도 하는데, 키 1개와 값 1개가 1:1로 연관되어 있는 자료구조, 키를 이용해서 값을 도출할 수 있음
	- Hashing은 일반적으로 O(1)의 시간복잡도가 걸림, Insertion이던, Deletion이던, Retrieval이던
	- insert(key, data) -> a[key]=data, delete(key) -> a[key] = NULL, find(key) -> return a[key]
	- key는 음이 아닌 정수여야함, key들의 범위는 작아야하고, 너무 큰 차이가 있어도 안됨 

- Hash Table
	- Hashing은 큰 정수를 작은 정수로, 음이 아닌 정수를 정수로 map하는 것임 
	- Ex) 66752378(phone number) -> hash function -> 237 (data 66752378)
	- 이런식으로 저장하고자 하는 키를 해시 함수를 이용해서 해시로 변깅이 되고 해시는 값과 매칭되어 저장소에 저장됨
	- 하지만 이런 과정이 모든 것을 만족시킬 순 없음 다른 키 값을 같은 slot에다가 넣으려고 할 때 collision이 일어날 수 있음
	- 두개의 키값이 같은 hash값을 가질 때, collision이 일어난다고 함

- Hash Function
	- hash table의 사이즈가 N일 경우를 가정함, hash function은 hash value를 계산하는데 사용함
	- hash value는 key를 hash function을 사용하여 0부터 N-1까지 사용함, data의 전체 테이블에서 index를 사용함, home address를 key로 생각함
	- 만일 같은 키가 같은 hash value에 있는 것을 collision이라고 함
	- 좋은 해시 함수는 O(1)이고 해시테이블에 키들이 넓게 분포되어 있고, 충돌이 적으며 적은 slots으로 사용됨 
	- 키를 해시테이블의 균일하게 분포시킴, 이를 위해서 [0,X)의 키값의 경우 size m(m<X)의 해시테이블로써 맵핑을 함
	- m slots으로 해시테이블을 맵핑함, 여기서 modulo 연산자 즉 나머지 연산자를 사용해서 값을 0과 m-1 사이로 맵핑함
	- hash(k)=k%m, 가장 많이 쓰이는 방법임
	- m이 2의 제곱일 경우 key mod m n 비트에서 키를 추출하는 것과 같음, 만약 10의 n제곱일 경우 n의 십진수와 같음
	- fraction part로 계산하는 경우도 있음

- Hashing of Strings
	- Lee Chin Tan, Chen Le Tian, Chan Tin Lee 모두 같은 해시 값을 가짐, 각각의 문자를 아스키코드로 변환후 합한뒤 해시함수를 적용시키면 그럼
	- 이를 해결하기 위해서 합하기 전에 그 다음 문자에 곱셈을 적용하면서 더하여 hash code의 영향을 줌 

- Collision Resoultion
	- Separate Chaining
		- 만일 충돌이 일어날 경우, 충돌이 일어나는 키 값에 대해서 연결리스트로 충돌된 키값들을 연결시켜서 충돌을 해결함 
		- n은 hash table에서의 키의 수고 m은 hash table의 전체 사이즈이면 a는 load factor로써 n/m을 통해서 값을 할당함
		- 결국 a는 연결리스트의 평균길이가 됨 
		- 여기서 insert는 O(1)이 걸리고 find, delete는 O(1+a)가 걸림
	- Open Addressing
		- 비어있는 해시를 찾아 데이터를 저장하는 기법임, 1개의 해시와 1개의 값이 매칭된 형태가 유지됨 
		- 여기서 Linear Probing, Quadractic Probing, Double Hashing등의 방법이 있다
		- Linear Probing에서는 충돌이 일어날 경우, 그 다음 빈 slot을 찾게끔 스캔한다
		- 이러한 방식으로 해시테이블을 채우면서 빈슬롯에 지속적으로 채우면 됨 
		- 여기서 삭제를 할 경우에도 그냥 삭제를 하면 안되고 deleted 됐다고 체크를 한 뒤에 삭제를 해야함
		- 그러한 과정을 통해서 find와 insert를 할 경우 deleted 된 것을 인식한 후 probe를 할 수 있는 환경이 주어짐 
		- 문제점1 primary clustering
			- cluster는 해시테이블에 연속적으로 값이 할당되어 있는 경우를 말함, 이와 같은 경우에는 find,insert,delete를 할 경우 시간이 더 걸릴 수 있음 
			- 이 부분을 해결하기 위해서 해시 함수에서 moderator 연산 이전에 값을 더하면서 probe과정을 거쳐서 이런 문제점을 해결할 수 있음 
		- Quadratic Probing
			- 충돌이 일어날 시 제곱수대로 해시테이블을 probe하는 방법 
			- 하지만 이 경우에도 Secondary clustering으로 문제가 생길 수가 있기 때문에 이 부분을 해소하기 위해서 두번째 해시함수를 사용함 
			- 여기서 두번째 해시함수에서 moderator의 경우 hash2(key)가 0이 되어서는 안됨 만일 0이 되는 경우가 나온다면 해당 함수를 재정의 해야함 
			- hash2(key)=(key%s)+1, or hash2(key)=s-(key%s)로 귀결됨
			- hash table의 크기는 prime m이 되어야함, hash2(key)=(key%s)+1을 정의할 때, s < m s는 prime일 필요가 없고 s = m-1임 보통 

- 충돌을 해결하기위한 최고의 방법은
	- clustering을 최소화하는 것
	- 존재한다면 항상 빈 슬롯을 찾는것
	- 2개의 키가 충돌했을 때, 서로 다른 탐색을 하는 것, secondary clustering을 방지하기 위해서
	- O(1)이 걸리는 것
	